{
  "instructions": [
    {
      "mnemonic": "add",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "add.uw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "addi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_iop(op)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "addiw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "I",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let result : xlenbits = add_bits(sign_extend(64, imm), rX_bits(rs1)) in { wX_bits(rd, sign_extend(64, subrange_bits(result, 31, 0))); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "addw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32dsi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "bs",
          "type": "bits(2)"
        }
      ],
      "syntax": "rd,rs1,rs2,bs",
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10101",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknd"
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_inv(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32dsmi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "bs",
          "type": "bits(2)"
        }
      ],
      "syntax": "rd,rs1,rs2,bs",
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknd"
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_inv(si) in { let mixed : bits(32) = aes_mixcolumn_byte_inv(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32esi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "bs",
          "type": "bits(2)"
        }
      ],
      "syntax": "rd,rs1,rs2,bs",
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zkne"
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_fwd(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32esmi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "bs",
          "type": "bits(2)"
        }
      ],
      "syntax": "rd,rs1,rs2,bs",
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zkne"
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_fwd(si) in { let mixed : bits(32) = aes_mixcolumn_byte_fwd(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ds",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11101",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknd"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:408.27-408.28\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_inv_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64dsm",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknd"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:399.27-399.28\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_inv(subrange_bits(sb, 63, 32)), aes_mixcolumn_inv(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64es",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zkne"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:391.27-391.28\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_fwd_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64esm",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zkne"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:382.27-382.28\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_fwd(subrange_bits(sb, 63, 32)), aes_mixcolumn_fwd(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64im",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknd"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:374.27-374.28\"); let w0 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 31, 0)) in { let w1 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 63, 32)) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ks1i",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rnum",
          "type": "bits(4)"
        }
      ],
      "syntax": "rd,rs1,rnum",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "rnum",
          "size": 4
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zkne",
        "Zknd"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:356.27-356.28\"); let prev : bits(32) = subrange_bits(rX_bits(rs1), 63, 32) in { let subwords : bits(32) = aes_subword_fwd(prev) in { let result : bits(32) = if eq_bits(rnum, 0xA) then subwords else xor_vec(rotater(subwords, 8), aes_decode_rcon(rnum)) in { wX_bits(rd, bitvector_concat(result, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ks2",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b11111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zkne",
        "Zknd"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:366.27-366.28\"); let w0 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), subrange_bits(rX_bits(rs2), 31, 0)) in { let w1 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), xor_vec(subrange_bits(rX_bits(rs2), 31, 0), subrange_bits(rX_bits(rs2), 63, 32))) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoadd.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoand.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomax.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomaxu.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amomin.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amominu.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoor.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoswap.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "amoxor.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_amoop(op)",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 292, \"Unexpected AMO width\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\"model/riscv_insts_aext.sail\", 313, \"Unexpected AMO width\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 345, \"Unexpected AMO width\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\"model/riscv_insts_aext.sail\", 349, \"AMO got false from mem_write_value\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "and",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "andi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_iop(op)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "andn",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "auipc",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(20)"
        }
      ],
      "syntax": "rd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 20
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "encdec_uop(op)",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let off : xlenbits = sign_extend(64, bitvector_concat(imm, 0x000)) in { let ret : xlenbits = match op { RISCV_LUI => off, RISCV_AUIPC => add_bits(get_arch_pc(), off) } in { wX_bits(rd, ret); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bclr",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bclri",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001010",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "beq",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(13)"
        }
      ],
      "syntax": "rs1,rs2,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7_6",
          "size": 1
        },
        {
          "field": "imm7_5_0",
          "size": 6
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_bop(op)",
          "size": 3
        },
        {
          "field": "imm5_4_1",
          "size": 4
        },
        {
          "field": "imm5_0",
          "size": 1
        },
        {
          "field": "0b1100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bext",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bexti",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001010",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bge",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(13)"
        }
      ],
      "syntax": "rs1,rs2,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7_6",
          "size": 1
        },
        {
          "field": "imm7_5_0",
          "size": 6
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_bop(op)",
          "size": 3
        },
        {
          "field": "imm5_4_1",
          "size": 4
        },
        {
          "field": "imm5_0",
          "size": 1
        },
        {
          "field": "0b1100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bgeu",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(13)"
        }
      ],
      "syntax": "rs1,rs2,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7_6",
          "size": 1
        },
        {
          "field": "imm7_5_0",
          "size": 6
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_bop(op)",
          "size": 3
        },
        {
          "field": "imm5_4_1",
          "size": 4
        },
        {
          "field": "imm5_0",
          "size": 1
        },
        {
          "field": "0b1100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "binv",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "binvi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001010",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "blt",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(13)"
        }
      ],
      "syntax": "rs1,rs2,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7_6",
          "size": 1
        },
        {
          "field": "imm7_5_0",
          "size": 6
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_bop(op)",
          "size": 3
        },
        {
          "field": "imm5_4_1",
          "size": 4
        },
        {
          "field": "imm5_0",
          "size": 1
        },
        {
          "field": "0b1100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bltu",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(13)"
        }
      ],
      "syntax": "rs1,rs2,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7_6",
          "size": 1
        },
        {
          "field": "imm7_5_0",
          "size": 6
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_bop(op)",
          "size": 3
        },
        {
          "field": "imm5_4_1",
          "size": 4
        },
        {
          "field": "imm5_0",
          "size": 1
        },
        {
          "field": "0b1100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bne",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(13)"
        }
      ],
      "syntax": "rs1,rs2,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7_6",
          "size": 1
        },
        {
          "field": "imm7_5_0",
          "size": 6
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_bop(op)",
          "size": 3
        },
        {
          "field": "imm5_4_1",
          "size": 4
        },
        {
          "field": "imm5_0",
          "size": 1
        },
        {
          "field": "0b1100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "brev8",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011010000111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = reverse_bits_in_byte(subrange_bits(rs1_val, add_atom(i, 7), i)); wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bset",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "bseti",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001010",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbs"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.add",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rsd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "rsd",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(RTYPE((rs2, rsd, rsd, RISCV_ADD)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.add.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addi",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "regidx"
        },
        {
          "name": "nzi",
          "type": "bits(6)"
        }
      ],
      "syntax": "rsd,nzi",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "nzi5",
          "size": 1
        },
        {
          "field": "rsd",
          "size": 5
        },
        {
          "field": "nzi40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = sign_extend(12, nzi) in { execute(ITYPE((imm, rsd, rsd, RISCV_ADDI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addi.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "regidx"
        }
      ],
      "syntax": "rsd",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "rsd",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addi16sp",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "nzi9",
          "size": 1
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "nzi4",
          "size": 1
        },
        {
          "field": "nzi6",
          "size": 1
        },
        {
          "field": "nzi87",
          "size": 2
        },
        {
          "field": "nzi5",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = sign_extend(12, bitvector_concat(imm, 0x0)) in { execute(ITYPE((imm, sp, sp, RISCV_ADDI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addi4spn",
      "name": "TBD",
      "operands": [
        {
          "name": "rdc",
          "type": "cregidx"
        },
        {
          "name": "nzimm",
          "type": "bits(8)"
        }
      ],
      "syntax": "rdc,nzimm,0b00",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "nz54",
          "size": 2
        },
        {
          "field": "nz96",
          "size": 4
        },
        {
          "field": "nz2",
          "size": 1
        },
        {
          "field": "nz3",
          "size": 1
        },
        {
          "field": "rd",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = bitvector_concat(0b00, bitvector_concat(nzimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { execute(ITYPE((imm, sp, rd, RISCV_ADDI))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addiw",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rsd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "rsd",
          "size": 5
        },
        {
          "field": "imm40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(ADDIW((sign_extend(12, imm), rsd, rsd)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addw",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPEW((rs2, rsd, rsd, RISCV_ADDW))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.and",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_AND))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.andi",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rsd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "i5",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "i40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { execute(ITYPE((sign_extend(12, imm), rsd, rsd, RISCV_ANDI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.beqz",
      "name": "TBD",
      "operands": [
        {
          "name": "rs",
          "type": "cregidx"
        },
        {
          "name": "imm",
          "type": "bits(8)"
        }
      ],
      "syntax": "rs,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "i8",
          "size": 1
        },
        {
          "field": "i43",
          "size": 2
        },
        {
          "field": "rs",
          "size": 3
        },
        {
          "field": "i76",
          "size": 2
        },
        {
          "field": "i21",
          "size": 2
        },
        {
          "field": "i5",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(BTYPE((sign_extend(13, bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), RISCV_BEQ)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.bnez",
      "name": "TBD",
      "operands": [
        {
          "name": "rs",
          "type": "cregidx"
        },
        {
          "name": "imm",
          "type": "bits(8)"
        }
      ],
      "syntax": "rs,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "i8",
          "size": 1
        },
        {
          "field": "i43",
          "size": 2
        },
        {
          "field": "rs",
          "size": 3
        },
        {
          "field": "i76",
          "size": 2
        },
        {
          "field": "i21",
          "size": 2
        },
        {
          "field": "i5",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(BTYPE((sign_extend(13, bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), RISCV_BNE)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.ebreak",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(EBREAK())",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fld",
      "name": "TBD",
      "operands": [
        {
          "name": "rdc",
          "type": "cregidx"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rdc,rsc,uimm,0b000",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "rd",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "D"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD_FP((imm, rs, rd, DOUBLE))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fldsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,uimm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "ui5",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "ui43",
          "size": 2
        },
        {
          "field": "ui86",
          "size": 3
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "D"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(LOAD_FP((imm, sp, rd, DOUBLE))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.flw",
      "name": "TBD",
      "operands": [
        {
          "name": "rdc",
          "type": "cregidx"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rdc,rsc,uimm,0b00",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui2",
          "size": 1
        },
        {
          "field": "ui6",
          "size": 1
        },
        {
          "field": "rd",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "F"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD_FP((imm, rs, rd, WORD))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.flwsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "ui5",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "ui42",
          "size": 3
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "F"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(imm, 0b00)) in { execute(LOAD_FP((imm, sp, rd, WORD))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fsd",
      "name": "TBD",
      "operands": [
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rsc1,rsc2,uimm,0b000",
      "format": "TBD",
      "fields": [
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "D"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE_FP((imm, rs2, rs1, DOUBLE))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fsdsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rs2,uimm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "ui86",
          "size": 3
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "D"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(STORE_FP((imm, rs2, sp, DOUBLE))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fsw",
      "name": "TBD",
      "operands": [
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rsc1,rsc2,uimm,0b00",
      "format": "TBD",
      "fields": [
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui2",
          "size": 1
        },
        {
          "field": "ui6",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "F"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE_FP((imm, rs2, rs1, WORD))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fswsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rs2,uimm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "ui52",
          "size": 4
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [
        "C",
        "F"
      ],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(STORE_FP((imm, rs2, sp, WORD))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.illegal",
      "name": "TBD",
      "operands": [
        {
          "name": "s",
          "type": "half"
        }
      ],
      "syntax": "s",
      "format": "TBD",
      "fields": [
        {
          "field": "s",
          "size": 16
        }
      ],
      "extensions": [],
      "function": "{ handle_illegal(); RETIRE_FAIL }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.j",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(11)"
        }
      ],
      "syntax": "imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "i11",
          "size": 1
        },
        {
          "field": "i4",
          "size": 1
        },
        {
          "field": "i98",
          "size": 2
        },
        {
          "field": "i10",
          "size": 1
        },
        {
          "field": "i6",
          "size": 1
        },
        {
          "field": "i7",
          "size": 1
        },
        {
          "field": "i31",
          "size": 3
        },
        {
          "field": "i5",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(RISCV_JAL((sign_extend(21, bitvector_concat(imm, 0b0)), zreg)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.jal",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(11)"
        }
      ],
      "syntax": "imm,0b0",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "i11",
          "size": 1
        },
        {
          "field": "i4",
          "size": 1
        },
        {
          "field": "i98",
          "size": 2
        },
        {
          "field": "i10",
          "size": 1
        },
        {
          "field": "i6",
          "size": 1
        },
        {
          "field": "i7",
          "size": 1
        },
        {
          "field": "i31",
          "size": 3
        },
        {
          "field": "i5",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(RISCV_JAL((sign_extend(21, bitvector_concat(imm, 0b0)), ra)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.jalr",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(RISCV_JALR((zero_extend(12, 0b0), rs1, ra)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.jr",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(RISCV_JALR((zero_extend(12, 0b0), rs1, zreg)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.ld",
      "name": "TBD",
      "operands": [
        {
          "name": "rdc",
          "type": "cregidx"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rdc,rsc,uimm,0b000",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "rd",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD((imm, rs, rd, false, DOUBLE, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.ldsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,uimm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "ui5",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "ui43",
          "size": 2
        },
        {
          "field": "ui86",
          "size": 3
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(LOAD((imm, sp, rd, false, DOUBLE, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.li",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "imm40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = sign_extend(12, imm) in { execute(ITYPE((imm, zreg, rd, RISCV_ADDI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.li.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "imm40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.lui",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "imm17",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "imm1612",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let res : bits(20) = sign_extend(20, imm) in { execute(UTYPE((res, rd, RISCV_LUI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.lui.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "imm17",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "imm1612",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.lw",
      "name": "TBD",
      "operands": [
        {
          "name": "rdc",
          "type": "cregidx"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rdc,rsc,uimm,0b00",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui2",
          "size": 1
        },
        {
          "field": "ui6",
          "size": 1
        },
        {
          "field": "rd",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD((imm, rs, rd, false, WORD, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.lwsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,uimm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "ui5",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "ui42",
          "size": 3
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(LOAD((imm, sp, rd, false, WORD, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.mv",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(RTYPE((rs2, zreg, rd, RISCV_ADD)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.mv.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.nop",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.nop.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        }
      ],
      "syntax": "imm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "im5",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "im40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.or",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_OR))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sd",
      "name": "TBD",
      "operands": [
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rsc1,rsc2,uimm,0b000",
      "format": "TBD",
      "fields": [
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE((imm, rs2, rs1, DOUBLE, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sdsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rs2,uimm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "ui86",
          "size": 3
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(STORE((imm, rs2, sp, DOUBLE, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.slli",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rsd,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "nzui5",
          "size": 1
        },
        {
          "field": "rsd",
          "size": 5
        },
        {
          "field": "nzui40",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SLLI)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.slli.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rsd,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "nzui5",
          "size": 1
        },
        {
          "field": "rsd",
          "size": 5
        },
        {
          "field": "nzui40",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.srai",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rsd,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "nzui5",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "nzui40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SRAI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.srai.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.srli",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rsd,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "nzui5",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "nzui40",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SRLI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.srli.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sub",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_SUB))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.subw",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPEW((rs2, rsd, rsd, RISCV_SUBW))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sw",
      "name": "TBD",
      "operands": [
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        },
        {
          "name": "uimm",
          "type": "bits(5)"
        }
      ],
      "syntax": "rsc1,rsc2,uimm,0b00",
      "format": "TBD",
      "fields": [
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "ui53",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "ui2",
          "size": 1
        },
        {
          "field": "ui6",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b00",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE((imm, rs2, rs1, WORD, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.swsp",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "bits(6)"
        }
      ],
      "syntax": "rs2,uimm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "ui52",
          "size": 4
        },
        {
          "field": "ui76",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(STORE((imm, rs2, sp, WORD, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.xor",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "syntax": "rsd,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "rsd",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 3
        },
        {
          "field": "0b01",
          "size": 2
        }
      ],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_XOR))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmul",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbc",
        "Zbkc"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftl(rs1_val, i)) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmulh",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbc",
        "Zbkc"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(xlen_val, i))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmulr",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbc"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(sub_atom(xlen_val, i), 1))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clz",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from sub_atom(64, 1) to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clzw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 31 to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "cpop",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000010",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "cpopw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000010",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to 31 by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "csrrc",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "csr",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,csr,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "csr",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_imm)",
          "size": 1
        },
        {
          "field": "encdec_csrop(op)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "csrrci",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "csr",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,csr,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "csr",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_imm)",
          "size": 1
        },
        {
          "field": "encdec_csrop(op)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "csrrs",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "csr",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,csr,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "csr",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_imm)",
          "size": 1
        },
        {
          "field": "encdec_csrop(op)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "csrrsi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "csr",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,csr,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "csr",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_imm)",
          "size": 1
        },
        {
          "field": "encdec_csrop(op)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "csrrw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "csr",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,csr,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "csr",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_imm)",
          "size": 1
        },
        {
          "field": "encdec_csrop(op)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "csrrwi",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "csr",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,csr,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "csr",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_imm)",
          "size": 1
        },
        {
          "field": "encdec_csrop(op)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ctz",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000001",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to sub_atom(64, 1) by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ctzw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000001",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to 31 by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "czero.eqz",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000111",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zicond"
      ],
      "function": "{ let value = rX_bits(rs1) in { let condition = rX_bits(rs2) in { let result : xlenbits = if neq_bits(condition, zeros_implicit(64)) then zeros_implicit(64) else value in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "czero.nez",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000111",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zicond"
      ],
      "function": "{ let value = rX_bits(rs1) in { let condition = rX_bits(rs2) in { let result : xlenbits = if neq_bits(condition, zeros_implicit(64)) then zeros_implicit(64) else value in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "div",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q' : int = if and_bool(s, gt_int(q, xlen_max_signed)) then xlen_min_signed else q in { wX_bits(rd, to_bits(64, q')); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "divu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q' : int = if and_bool(s, gt_int(q, xlen_max_signed)) then xlen_min_signed else q in { wX_bits(rd, to_bits(64, q')); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "divuw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q' : int = if and_bool(s, gt_int(q, sub_atom(pow2(31), 1))) then sub_atom(0, int_power(2, 31)) else q in { wX_bits(rd, sign_extend(64, to_bits(32, q'))); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "divw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q' : int = if and_bool(s, gt_int(q, sub_atom(pow2(31), 1))) then sub_atom(0, int_power(2, 31)) else q in { wX_bits(rd, sign_extend(64, to_bits(32, q'))); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ebreak",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000000000001",
          "size": 12
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ handle_mem_exception(PC, E_Breakpoint()); RETIRE_FAIL }",
      "description": "TBD"
    },
    {
      "mnemonic": "ecall",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000000000000",
          "size": 12
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let t : sync_exception = struct { trap = match cur_privilege { User => E_U_EnvCall(), Supervisor => E_S_EnvCall(), Machine => E_M_EnvCall() }; excinfo = None() : option(xlenbits); ext = None() } in { set_next_pc(exception_handler(cur_privilege, CTL_TRAP(t), PC)); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fadd.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fadd.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fadd.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fclass.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111001",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:1004.27-1004.28\"); let rs1_val_X = rX_bits(rs1) in { let rd_val_D = subrange_bits(rs1_val_X, 63, 0) in { wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fclass.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111010",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh"
      ],
      "function": "{ let rs1_val_X = rX_bits(rs1) in { let rd_val_H = subrange_bits(rs1_val_X, 15, 0) in { wF_bits(rd, nan_box_H(rd_val_H)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fclass.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111000",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "F"
      ],
      "function": "{ let rs1_val_X = rX_bits(rs1) in { let rd_val_S = subrange_bits(rs1_val_X, 31, 0) in { wF_bits(rd, nan_box_S(rd_val_S)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.d.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.d.l",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.d.lu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.d.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.d.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.d.wu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.h.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.h.l",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.h.lu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.h.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.h.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.h.wu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.l.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.l.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.l.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.lu.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.lu.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.lu.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.s.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.s.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.s.l",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.s.lu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.s.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.s.wu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.w.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.w.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.w.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.wu.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.wu.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvt.wu.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvtmod.w.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1100001",
          "size": 7
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { let (fflags, rd_val) = fcvtmod_helper(rs1_val_D) in { accrue_fflags(fflags); wX_bits(rd, sign_extend(64, rd_val)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fdiv.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fdiv.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fdiv.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence",
      "name": "TBD",
      "operands": [
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        }
      ],
      "syntax": "pred,succ",
      "format": "I",
      "fields": [
        {
          "field": "0b0000",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let fiom = is_fiom_active() in { let pred = effective_fence_set(pred, fiom) in { let succ = effective_fence_set(succ, fiom) in { match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_rw_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_r_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_r_r()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_rw_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_w_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_w_rw()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_rw_r()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_r_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_w_r()), (_ : bits(4), _ : bits(2) @ 0b00) => (), (_ : bits(2) @ 0b00, _ : bits(4)) => (), _ => { print(\"FIXME: unsupported fence\"); () } }; RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.i",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000000000000",
          "size": 12
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.tso",
      "name": "TBD",
      "operands": [
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        }
      ],
      "syntax": "pred,succ",
      "format": "I",
      "fields": [
        {
          "field": "0b1000",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_tso()), (_ : bits(2) @ 0b00, _ : bits(2) @ 0b00) => (), _ => { print(\"FIXME: unsupported fence\"); () } }; RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "feq.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "feq.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "feq.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "flb",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 397, width, \"floating point load\") } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fld",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 397, width, \"floating point load\") } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fle.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fle.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fle.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fleq.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { let rs2_val_D = rF_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le_quiet(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fleq.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le_quiet(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fleq.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le_quiet(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "flh",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 397, width, \"floating point load\") } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fli.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "constantidx",
          "type": "bits(5)"
        }
      ],
      "syntax": "rd,constantidx",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111001",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let bits : bits(64) = match constantidx { 0b00000 => { 0xbff0000000000000 }, 0b00001 => { 0x0010000000000000 }, 0b00010 => { 0x3Ef0000000000000 }, 0b00011 => { 0x3f00000000000000 }, 0b00100 => { 0x3f70000000000000 }, 0b00101 => { 0x3f80000000000000 }, 0b00110 => { 0x3fb0000000000000 }, 0b00111 => { 0x3fc0000000000000 }, 0b01000 => { 0x3fd0000000000000 }, 0b01001 => { 0x3fd4000000000000 }, 0b01010 => { 0x3fd8000000000000 }, 0b01011 => { 0x3fdc000000000000 }, 0b01100 => { 0x3fe0000000000000 }, 0b01101 => { 0x3fe4000000000000 }, 0b01110 => { 0x3fe8000000000000 }, 0b01111 => { 0x3fec000000000000 }, 0b10000 => { 0x3ff0000000000000 }, 0b10001 => { 0x3ff4000000000000 }, 0b10010 => { 0x3ff8000000000000 }, 0b10011 => { 0x3ffc000000000000 }, 0b10100 => { 0x4000000000000000 }, 0b10101 => { 0x4004000000000000 }, 0b10110 => { 0x4008000000000000 }, 0b10111 => { 0x4010000000000000 }, 0b11000 => { 0x4020000000000000 }, 0b11001 => { 0x4030000000000000 }, 0b11010 => { 0x4060000000000000 }, 0b11011 => { 0x4070000000000000 }, 0b11100 => { 0x40e0000000000000 }, 0b11101 => { 0x40f0000000000000 }, 0b11110 => { 0x7ff0000000000000 }, _ : bitvector(5) => { canonical_NaN_D() } } in { wF_D(rd, bits); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fli.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "constantidx",
          "type": "bits(5)"
        }
      ],
      "syntax": "rd,constantidx",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111010",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let bits : bits(16) = match constantidx { 0b00000 => { 0xbc00 }, 0b00001 => { 0x0400 }, 0b00010 => { 0x0100 }, 0b00011 => { 0x0200 }, 0b00100 => { 0x1c00 }, 0b00101 => { 0x2000 }, 0b00110 => { 0x2c00 }, 0b00111 => { 0x3000 }, 0b01000 => { 0x3400 }, 0b01001 => { 0x3500 }, 0b01010 => { 0x3600 }, 0b01011 => { 0x3700 }, 0b01100 => { 0x3800 }, 0b01101 => { 0x3900 }, 0b01110 => { 0x3a00 }, 0b01111 => { 0x3b00 }, 0b10000 => { 0x3c00 }, 0b10001 => { 0x3d00 }, 0b10010 => { 0x3e00 }, 0b10011 => { 0x3f00 }, 0b10100 => { 0x4000 }, 0b10101 => { 0x4100 }, 0b10110 => { 0x4200 }, 0b10111 => { 0x4400 }, 0b11000 => { 0x4800 }, 0b11001 => { 0x4c00 }, 0b11010 => { 0x5800 }, 0b11011 => { 0x5c00 }, 0b11100 => { 0x7800 }, 0b11101 => { 0x7c00 }, 0b11110 => { 0x7c00 }, _ : bitvector(5) => { canonical_NaN_H() } } in { wF_H(rd, bits); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fli.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "constantidx",
          "type": "bits(5)"
        }
      ],
      "syntax": "rd,constantidx",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111000",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 3
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let bits : bits(32) = match constantidx { 0b00000 => { 0xbf800000 }, 0b00001 => { 0x00800000 }, 0b00010 => { 0x37800000 }, 0b00011 => { 0x38000000 }, 0b00100 => { 0x3b800000 }, 0b00101 => { 0x3c000000 }, 0b00110 => { 0x3d800000 }, 0b00111 => { 0x3e000000 }, 0b01000 => { 0x3e800000 }, 0b01001 => { 0x3ea00000 }, 0b01010 => { 0x3ec00000 }, 0b01011 => { 0x3ee00000 }, 0b01100 => { 0x3f000000 }, 0b01101 => { 0x3f200000 }, 0b01110 => { 0x3f400000 }, 0b01111 => { 0x3f600000 }, 0b10000 => { 0x3f800000 }, 0b10001 => { 0x3fa00000 }, 0b10010 => { 0x3fc00000 }, 0b10011 => { 0x3fe00000 }, 0b10100 => { 0x40000000 }, 0b10101 => { 0x40200000 }, 0b10110 => { 0x40400000 }, 0b10111 => { 0x40800000 }, 0b11000 => { 0x41000000 }, 0b11001 => { 0x41800000 }, 0b11010 => { 0x43000000 }, 0b11011 => { 0x43800000 }, 0b11100 => { 0x47000000 }, 0b11101 => { 0x47800000 }, 0b11110 => { 0x7f800000 }, _ : bitvector(5) => { canonical_NaN_S() } } in { wF_S(rd, bits); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "flt.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "flt.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "flt.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fltq.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { let rs2_val_D = rF_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Lt_quiet(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fltq.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Lt_quiet(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fltq.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Lt_quiet(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "flw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 397, width, \"floating point load\") } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmadd.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmadd.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmadd.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmax.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmax.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmax.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmaxm.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_bits(rs1) in { let rs2_val_D = rF_bits(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_D(rs2_val_D, rs1_val_D, is_quiet) in { let rd_val_D = if or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then canonical_NaN_D() else if and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then rs2_val_D else if and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then rs1_val_D else if rs2_lt_rs1 then rs1_val_D else rs2_val_D in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmaxm.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_H(rs2_val_H, rs1_val_H, is_quiet) in { let rd_val_H = if or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then canonical_NaN_H() else if and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then rs2_val_H else if and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then rs1_val_H else if rs2_lt_rs1 then rs1_val_H else rs2_val_H in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmaxm.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_S(rs2_val_S, rs1_val_S, is_quiet) in { let rd_val_S = if or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then canonical_NaN_S() else if and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then rs2_val_S else if and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then rs1_val_S else if rs2_lt_rs1 then rs1_val_S else rs2_val_S in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmin.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmin.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmin.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fminm.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_bits(rs1) in { let rs2_val_D = rF_bits(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_D(rs1_val_D, rs2_val_D, is_quiet) in { let rd_val_D = if or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then canonical_NaN_D() else if and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then rs1_val_D else if and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then rs2_val_D else if rs1_lt_rs2 then rs1_val_D else rs2_val_D in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fminm.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_H(rs1_val_H, rs2_val_H, is_quiet) in { let rd_val_H = if or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then canonical_NaN_H() else if and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then rs1_val_H else if and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then rs2_val_H else if rs1_lt_rs2 then rs1_val_H else rs2_val_H in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fminm.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_S(rs1_val_S, rs2_val_S, is_quiet) in { let rd_val_S = if or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then canonical_NaN_S() else if and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then rs1_val_S else if and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then rs2_val_S else if rs1_lt_rs2 then rs1_val_S else rs2_val_S in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmsub.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmsub.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmsub.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmul.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmul.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmul.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmv.d.x",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111001",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:1004.27-1004.28\"); let rs1_val_X = rX_bits(rs1) in { let rd_val_D = subrange_bits(rs1_val_X, 63, 0) in { wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmv.h.x",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111010",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh"
      ],
      "function": "{ let rs1_val_X = rX_bits(rs1) in { let rd_val_H = subrange_bits(rs1_val_X, 15, 0) in { wF_bits(rd, nan_box_H(rd_val_H)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmv.w.x",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111000",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "F"
      ],
      "function": "{ let rs1_val_X = rX_bits(rs1) in { let rd_val_S = subrange_bits(rs1_val_X, 31, 0) in { wF_bits(rd, nan_box_S(rd_val_S)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmv.x.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111001",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:1004.27-1004.28\"); let rs1_val_X = rX_bits(rs1) in { let rd_val_D = subrange_bits(rs1_val_X, 63, 0) in { wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmv.x.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111010",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh"
      ],
      "function": "{ let rs1_val_X = rX_bits(rs1) in { let rd_val_H = subrange_bits(rs1_val_X, 15, 0) in { wF_bits(rd, nan_box_H(rd_val_H)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmv.x.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111000",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "F"
      ],
      "function": "{ let rs1_val_X = rX_bits(rs1) in { let rd_val_S = subrange_bits(rs1_val_X, 31, 0) in { wF_bits(rd, nan_box_S(rd_val_S)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmvh.x.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1110001",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = subrange_bits(rF_D(rs1), 63, 32) in { let rd_val_X : xlenbits = sign_extend(64, rs1_val_D) in { wX_bits(rd, rd_val_X); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmvp.d.x",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1011001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_X = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val_X = subrange_bits(rX_bits(rs2), 31, 0) in { let rd_val_D = bitvector_concat(rs2_val_X, rs1_val_X) in { wF_D(rd, rd_val_D); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fnmadd.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fnmadd.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fnmadd.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fnmsub.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fnmsub.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fnmsub.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs3",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rs3,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "rs3",
          "size": 5
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fround.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100001",
          "size": 7
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_bits(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, false) in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fround.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100010",
          "size": 7
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, false) in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fround.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, false) in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "froundnx.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100001",
          "size": 7
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "D",
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, true) in { accrue_fflags(fflags); wF_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "froundnx.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100010",
          "size": 7
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, true) in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "froundnx.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, true) in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsb",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 470, width, \"floating point store\") } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsd",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 470, width, \"floating point store\") } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnj.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnj.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnj.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnjn.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnjn.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnjn.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnjx.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnjx.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsgnjx.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsh",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 470, width, \"floating point store\") } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsqrt.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101001",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_dext.sail:650.27-650.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsqrt.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101010",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_zfh.sail:823.27-823.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsqrt.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1101000",
          "size": 7
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(gteq_int(64, 64), \"model/riscv_insts_fext.sail:789.27-789.28\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsub.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsub.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsub.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        }
      ],
      "syntax": "rd,rs1,rs2,rm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fsw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "D"
      ],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 470, width, \"floating point store\") } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "illegal",
      "name": "TBD",
      "operands": [
        {
          "name": "s",
          "type": "word"
        }
      ],
      "syntax": "s",
      "format": "TBD",
      "fields": [
        {
          "field": "s",
          "size": 32
        }
      ],
      "extensions": [],
      "function": "{ handle_illegal(); RETIRE_FAIL }",
      "description": "TBD"
    },
    {
      "mnemonic": "jal",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(21)"
        }
      ],
      "syntax": "rd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm_19",
          "size": 1
        },
        {
          "field": "imm_18_13",
          "size": 6
        },
        {
          "field": "imm_12_9",
          "size": 4
        },
        {
          "field": "imm_8",
          "size": 1
        },
        {
          "field": "imm_7_0",
          "size": 8
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { wX_bits(rd, get_next_pc()); set_next_pc(target); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "jalr",
      "name": "jump and link register",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "I",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1100111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let t : xlenbits = add_bits(rX_bits(rs1), sign_extend(64, imm)) in { match ext_control_check_addr(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(addr) => { let target = bitvector_update(addr, 0, bitzero) in { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\"C\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { wX_bits(rd, get_next_pc()); set_next_pc(target); RETIRE_SUCCESS } } } } } }",
      "description": "\nThe target address is obtained by adding the sign-extended 12-bit\nI-immediate to the register rs1, then setting the\nleast-significant bit of the result to zero. The address of the\ninstruction following the jump (pc+4) is written to register rd.\nRegister x0 can be used as the destination if the result is not\nrequired.\n "
    },
    {
      "mnemonic": "lb",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lb.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lb.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lb.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lbu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lbu.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lbu.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lbu.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ld",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ld.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ld.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ld.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ldu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ldu.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ldu.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ldu.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lh",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lh.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lh.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lh.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lhu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lhu.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lhu.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lhu.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lui",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(20)"
        }
      ],
      "syntax": "rd,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 20
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "encdec_uop(op)",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let off : xlenbits = sign_extend(64, bitvector_concat(imm, 0x000)) in { let ret : xlenbits = match op { RISCV_LUI => off, RISCV_AUIPC => add_bits(get_arch_pc(), off) } in { wX_bits(rd, ret); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lw.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lw.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lw.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lwu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lwu.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lwu.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lwu.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "max",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "maxu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "min",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "minu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mret",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0011000",
          "size": 7
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if neq_anything(cur_privilege, Machine) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_xret_priv(Machine)) then { ext_fail_xret_priv(); RETIRE_FAIL } else { set_next_pc(exception_handler(cur_privilege, CTL_MRET(), PC)); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mul",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_mul_op(high,signed1,signed2)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mulh",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_mul_op(high,signed1,signed2)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mulhsu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_mul_op(high,signed1,signed2)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mulhu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_mul_op(high,signed1,signed2)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mulw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = signed(rs1_val) in { let rs2_int : int = signed(rs2_val) in { let result32 = subrange_bits(to_bits(64, mult_atom(rs1_int, rs2_int)), 31, 0) in { let result : xlenbits = sign_extend(64, result32) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "or",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "orc.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b001010000111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = if eq_bits(subrange_bits(rs1_val, add_atom(i, 7), i), zeros_implicit(add_atom(sub_atom(add_atom(__id(i), 7), __id(i)), 1))) then 0x00 else 0xFF; wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ori",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_iop(op)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "orn",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "pack",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_PACK => bitvector_concat(subrange_bits(rs2_val, sub_atom(mult_atom(8, 4), 1), 0), subrange_bits(rs1_val, sub_atom(mult_atom(8, 4), 1), 0)), RISCV_PACKH => zero_extend(64, bitvector_concat(subrange_bits(rs2_val, 7, 0), subrange_bits(rs1_val, 7, 0))) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "packh",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_PACK => bitvector_concat(subrange_bits(rs2_val, sub_atom(mult_atom(8, 4), 1), 0), subrange_bits(rs1_val, sub_atom(mult_atom(8, 4), 1), 0)), RISCV_PACKH => zero_extend(64, bitvector_concat(subrange_bits(rs2_val, 7, 0), subrange_bits(rs1_val, 7, 0))) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "packw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkb"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zbkb.sail:109.27-109.28\"); let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : bits(32) = bitvector_concat(subrange_bits(rs2_val, 15, 0), subrange_bits(rs1_val, 15, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rem",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, to_bits(64, r)); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "remu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, to_bits(64, r)); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "remuw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, sign_extend(64, to_bits(32, r))); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "remw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, sign_extend(64, to_bits(32, r))); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rev8",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011010111000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = subrange_bits(rs1_val, sub_atom(sub_atom(64, i), 1), sub_atom(sub_atom(64, i), 8)); wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rol",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rolw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let shamt = subrange_bits(rX_bits(rs2), 4, 0) in { let result : bits(32) = match op { RISCV_ROLW => rotate_bits_left(rs1_val, shamt), RISCV_RORW => rotate_bits_right(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ror",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rori",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else rotate_bits_right(rs1_val, shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "roriw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(5)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "shamt",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : xlenbits = sign_extend(64, rotate_bits_right(rs1_val, shamt)) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rorw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let shamt = subrange_bits(rX_bits(rs2), 4, 0) in { let result : bits(32) = match op { RISCV_ROLW => rotate_bits_left(rs1_val, shamt), RISCV_RORW => rotate_bits_right(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sb",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sb.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sb.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sb.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.b.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.b.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.b.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.d.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.d.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.d.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.h.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.h.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.h.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.w",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.w.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.w.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.w.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sd",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sd.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sd.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sd.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sext.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SEXTB => sign_extend(64, subrange_bits(rs1_val, 7, 0)), RISCV_SEXTH => sign_extend(64, subrange_bits(rs1_val, 15, 0)), RISCV_ZEXTH => zero_extend(64, subrange_bits(rs1_val, 15, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sext.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SEXTB => sign_extend(64, subrange_bits(rs1_val, 7, 0)), RISCV_SEXTH => sign_extend(64, subrange_bits(rs1_val, 15, 0)), RISCV_ZEXTH => zero_extend(64, subrange_bits(rs1_val, 15, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sfence.vma",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rs1,rs2",
      "format": "R",
      "fields": [
        {
          "field": "0b0001001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let addr : option(xlenbits) = if eq_bits(rs1, 0b00000) then None() else Some(rX_bits(rs1)) in { let asid : option(xlenbits) = if eq_bits(rs2, 0b00000) then None() else Some(rX_bits(rs2)) in { match cur_privilege { User => { handle_illegal(); RETIRE_FAIL }, Supervisor => match (architecture(get_mstatus_SXL(mstatus)), _get_Mstatus_TVM(mstatus)) { (Some(_), 0b1) => { handle_illegal(); RETIRE_FAIL }, (Some(_), 0b0) => { flush_TLB(asid, addr); RETIRE_SUCCESS }, (_, _) => internal_error(\"model/riscv_insts_base.sail\", 866, \"unimplemented sfence architecture\") }, Machine => { flush_TLB(asid, addr); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh1add",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_SH1ADD => 0b01, RISCV_SH2ADD => 0b10, RISCV_SH3ADD => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(rs1_val, shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh1add.uw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh2add",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_SH1ADD => 0b01, RISCV_SH2ADD => 0b10, RISCV_SH3ADD => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(rs1_val, shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh2add.uw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh3add",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_SH1ADD => 0b01, RISCV_SH2ADD => 0b10, RISCV_SH3ADD => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(rs1_val, shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sh3add.uw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sig0",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 7), xor_vec(rotater(inb, 18), shiftr(inb, 3))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sig1",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 17), xor_vec(rotater(inb, 19), shiftr(inb, 10))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sum0",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 2), xor_vec(rotater(inb, 13), rotater(inb, 22))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sum1",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 6), xor_vec(rotater(inb, 11), rotater(inb, 25))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00110",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:452.27-452.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 1), xor_vec(rotater(input, 8), shiftr(input, 7))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01110",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), shiftl(rX_bits(rs2), 24))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0l",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01010",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), xor_vec(shiftl(rX_bits(rs2), 25), shiftl(rX_bits(rs2), 24)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00111",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:460.27-460.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 19), xor_vec(rotater(input, 61), shiftr(input, 6))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), shiftl(rX_bits(rs2), 13))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1l",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), xor_vec(shiftl(rX_bits(rs2), 26), shiftl(rX_bits(rs2), 13)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum0",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:468.27-468.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 28), xor_vec(rotater(input, 34), rotater(input, 39))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum0r",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 25), xor_vec(shiftl(rX_bits(rs1), 30), xor_vec(shiftr(rX_bits(rs1), 28), xor_vec(shiftr(rX_bits(rs2), 7), xor_vec(shiftr(rX_bits(rs2), 2), shiftl(rX_bits(rs2), 4)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum1",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:476.27-476.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 14), xor_vec(rotater(input, 18), rotater(input, 41))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum1r",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zknh"
      ],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 23), xor_vec(shiftr(rX_bits(rs1), 14), xor_vec(shiftr(rX_bits(rs1), 18), xor_vec(shiftr(rX_bits(rs2), 9), xor_vec(shiftl(rX_bits(rs2), 18), shiftl(rX_bits(rs2), 14)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sll",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "slli",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SLLI => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_left(rs1_val, shamt), RISCV_SRLI => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_right(rs1_val, shamt), RISCV_SRAI => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(shamt, 4, 0)) else shift_right_arith64(rs1_val, shamt) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "slli.uw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000010",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [
        "Zba"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "slliw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(5)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "shamt",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = match op { RISCV_SLLIW => shift_bits_left(rs1_val, shamt), RISCV_SRLIW => shift_bits_right(rs1_val, shamt), RISCV_SRAIW => shift_right_arith32(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sllw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "slt",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "slti",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_iop(op)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sltiu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_iop(op)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sltu",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm3p0",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zksh"
      ],
      "function": "{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 9), rotatel(r1, 17))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm3p1",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b01001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zksh"
      ],
      "function": "{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 15), rotatel(r1, 23))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm4ed",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "bs",
          "type": "bits(2)"
        }
      ],
      "syntax": "rd,rs1,rs2,bs",
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zksed"
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(x, 8), xor_vec(shiftl(x, 2), xor_vec(shiftl(x, 18), xor_vec(shiftl(and_vec(x, 0x0000003F), 26), shiftl(and_vec(x, 0x000000C0), 10)))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm4ks",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "bs",
          "type": "bits(2)"
        }
      ],
      "syntax": "rd,rs1,rs2,bs",
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b11010",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zksed"
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(and_vec(x, 0x00000007), 29), xor_vec(shiftl(and_vec(x, 0x000000FE), 7), xor_vec(shiftl(and_vec(x, 0x00000001), 23), shiftl(and_vec(x, 0x000000F8), 13))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sra",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "srai",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SLLI => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_left(rs1_val, shamt), RISCV_SRLI => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_right(rs1_val, shamt), RISCV_SRAI => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(shamt, 4, 0)) else shift_right_arith64(rs1_val, shamt) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sraiw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(5)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "shamt",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = match op { RISCV_SLLIW => shift_bits_left(rs1_val, shamt), RISCV_SRLIW => shift_bits_right(rs1_val, shamt), RISCV_SRAIW => shift_right_arith32(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sraw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sret",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0001000",
          "size": 7
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let sret_illegal : bool = match cur_privilege { User => true, Supervisor => or_bool(not(haveSupMode()), eq_bits(_get_Mstatus_TSR(mstatus), 0b1)), Machine => not(haveSupMode()) } in { if sret_illegal then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_xret_priv(Supervisor)) then { ext_fail_xret_priv(); RETIRE_FAIL } else { set_next_pc(exception_handler(cur_privilege, CTL_SRET(), PC)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "srl",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "srli",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(6)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SLLI => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_left(rs1_val, shamt), RISCV_SRLI => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_right(rs1_val, shamt), RISCV_SRAI => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(shamt, 4, 0)) else shift_right_arith64(rs1_val, shamt) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "srliw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "shamt",
          "type": "bits(5)"
        }
      ],
      "syntax": "rd,rs1,shamt",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "shamt",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = match op { RISCV_SLLIW => shift_bits_left(rs1_val, shamt), RISCV_SRLIW => shift_bits_right(rs1_val, shamt), RISCV_SRAIW => shift_right_arith32(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "srlw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sub",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "subw",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sw.aq",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sw.aq.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sw.rl",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rs2,imm(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 1
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "unzip",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000010001111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkb"
      ],
      "function": "{ assert(eq_int(64, 32), \"model/riscv_insts_zbkb.sail:148.27-148.28\"); exit () }",
      "description": "TBD"
    },
    {
      "mnemonic": "uret",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000000",
          "size": 7
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if or_bool(not(haveUsrMode()), not(sys_enable_next())) then handle_illegal() else if not(ext_check_xret_priv(User)) then ext_fail_xret_priv() else set_next_pc(exception_handler(cur_privilege, CTL_URET(), PC)); RETIRE_FAIL }",
      "description": "TBD"
    },
    {
      "mnemonic": "vaadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vaadd.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vaaddu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vaaddu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vadc.vim",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,simm,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vimsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { var vec_trues : vector('n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VIMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vadc.vvm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,vs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvmsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { var vec_trues : vector('n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VVMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VVMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vadc.vxm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,rs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxmsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { var vec_trues : vector('n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VXMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VXMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vadd.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vadd.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vand.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vand.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vand.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vasub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vasub.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vasubu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vasubu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vcompress.vm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if or_bool(neq_int(start_element, 0), or_bool(eq_bits(vs1, vd), or_bool(eq_bits(vs2, vd), illegal_vd_unmasked()))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var vd_idx : nat = 0 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lteq_int(i, end_element) then { if plain_vector_access(vs1_val, i) then { let p as 'p = vd_idx in { assert(lt_int(__id(p), __id(n)), \"model/riscv_insts_vext_arith.sail:1877.22-1877.23\"); result[__id(p)] = plain_vector_access(vs2_val, i); vd_idx = add_atom(vd_idx, 1) } } else () } else () }; if lt_int(vd_idx, num_elem) then { let tail_ag : agtype = get_vtype_vta() in { let p as 'p = vd_idx in { foreach (i from __id(p) to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } } } } else (); write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vdiv.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vdiv.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vdivu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vdivu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfadd.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfclass.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010011",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary1_vs1(vfunary1)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:782.17-782.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfcvt.f.x.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary0_vs1(vfunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfcvt.f.xu.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary0_vs1(vfunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfcvt.rtz.x.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary0_vs1(vfunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfcvt.rtz.xu.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary0_vs1(vfunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfcvt.x.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary0_vs1(vfunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfcvt.xu.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary0_vs1(vfunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfdiv.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfdiv.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfirst.m",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "rd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b10001",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_vd_unmasked(), not(assert_vstart(0))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val); var index : int = -1 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if eq_int(index, -1) then { if and_bool(plain_vector_access(mask, i), plain_vector_access(vs2_val, i)) then index = i else () } else () }; wX_bits(rd, to_bits(64, index)); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmacc.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmacc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmadd.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmax.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmax.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmerge.vfm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,rs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_fp_vd_masked(vd, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:1247.17-1247.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then rs1_val else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmin.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmin.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmsac.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmsac.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmsub.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmsub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmul.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmul.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmv.f.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,vs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if or_bool(illegal_fp_vd_unmasked(SEW, rm_3b), gt_int(SEW, 64)) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gt_int(num_elem, 0), neq_int(SEW, 8)), \"model/riscv_insts_vext_fp.sail:858.32-858.33\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vs2) in { match __id(m) { 16 => wF_H(rd, plain_vector_access(vs2_val, 0)), 32 => wF_S(rd, plain_vector_access(vs2_val, 0)), _ => wF_D(rd, plain_vector_access(vs2_val, 0)) }; vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmv.s.f",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gt_int(num_elem, 0), neq_int(SEW, 8)), \"model/riscv_insts_vext_fp.sail:1332.32-1332.33\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val); if plain_vector_access(mask, 0) then result[0] = rs1_val else (); let tail_ag : agtype = get_vtype_vta() in { foreach (i from 1 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } }; write_vreg(num_elem, SEW, 0, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfmv.v.f",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:1295.17-1295.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = rs1_val else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.f.f.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.f.x.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.f.xu.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.rod.f.f.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.rtz.x.f.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.rtz.xu.f.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.x.f.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfncvt.xu.f.w",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfnunary0_vs1(vfnunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmacc.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmacc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmadd.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmsac.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmsac.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmsub.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:996.17-996.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfnmsub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:145.17-145.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfrdiv.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfrec7.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010011",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary1_vs1(vfunary1)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:782.17-782.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfredmax.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rfvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfredmin.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rfvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfredosum.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rfvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfredusum.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rfvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfrsqrt7.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010011",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary1_vs1(vfunary1)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:782.17-782.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfrsub.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsgnj.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsgnj.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsgnjn.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsgnjn.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsgnjx.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsgnjx.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfslide1down.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfslide1up.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsqrt.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010011",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfunary1_vs1(vfunary1)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:782.17-782.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits('m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsub.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:906.17-906.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_fp.sail:940.57-940.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfsub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_fp.sail:70.17-70.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwadd.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1067.36-1067.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:217.36-217.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwadd.wf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1193.36-1193.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)), FWF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwadd.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:345.36-345.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))), FWV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwcvt.f.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfwunary0_vs1(vfwunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:521.35-521.36\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwcvt.f.x.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfwunary0_vs1(vfwunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:521.35-521.36\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwcvt.f.xu.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfwunary0_vs1(vfwunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:521.35-521.36\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwcvt.rtz.x.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfwunary0_vs1(vfwunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:521.35-521.36\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwcvt.rtz.xu.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfwunary0_vs1(vfwunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:521.35-521.36\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwcvt.x.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfwunary0_vs1(vfwunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:521.35-521.36\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwcvt.xu.f.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "encdec_vfwunary0_vs1(vfwunary0)",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:521.35-521.36\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits('o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwmacc.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1131.36-1131.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwmacc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:282.36-282.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwmsac.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1131.36-1131.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwmsac.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:282.36-282.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwmul.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1067.36-1067.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwmul.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:217.36-217.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwnmacc.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1131.36-1131.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwnmacc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:282.36-282.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwnmsac.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvfmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1131.36-1131.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwnmsac.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:282.36-282.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwredosum.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rfvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwredusum.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rfvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwsub.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1067.36-1067.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwsub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:217.36-217.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwsub.wf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwffunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:1193.36-1193.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)), FWF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vfwsub.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fwvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \"model/riscv_insts_vext_fp.sail:345.36-345.37\"); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))), FWV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vid.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vdvm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010100",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b10001",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = to_bits(SEW, i) else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "viota.m",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010100",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); var sum : int = 0 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = to_bits(SEW, sum); if plain_vector_access(vs2_val, i) then sum = add_atom(sum, 1) else () } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vle8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlm.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd_or_vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd_or_vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd_or_vs3",
          "size": 5
        },
        {
          "field": "encdec_lsop(op)",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW = 8 in { let EMUL_pow = 0 in { let vl_val = unsigned(vl) in { let evl : int = if eq_int(emod_int(vl_val, 8), 0) then quot_round_zero(vl_val, 8) else add_atom(quot_round_zero(vl_val, 8), 1) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gteq_int(evl, 0), \"model/riscv_insts_vext_mem.sail:929.17-929.18\"); process_vm(vd_or_vs3, rs1, num_elem, evl, op) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg2ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg2ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg2ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg2ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg3ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg3ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg3ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg3ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg4ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg4ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg4ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg4ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg5ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg5ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg5ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg5ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg6ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg6ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg6ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg6ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg7ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg7ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg7ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg7ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg8ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg8ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg8ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vloxseg8ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlre16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlre32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlre64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlre8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlse16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlse32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlse64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlse8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2e8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2re16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2re32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2re64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg2re8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3e8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3re16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3re32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3re64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg3re8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4e8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4re16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4re32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4re64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg4re8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5e8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5re16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5re32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5re64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg5re8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6e8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6re16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6re32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6re64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg6re8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7e8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7re16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7re32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7re64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg7re8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e16ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e32ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e64ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8e8ff.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8re16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8re32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8re64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlseg8re8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:738.26-738.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg2e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg2e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg2e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg2e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg3e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg3e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg3e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg3e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg4e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg4e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg4e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg4e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg5e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg5e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg5e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg5e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg6e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg6e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg6e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg6e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg7e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg7e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg7e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg7e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg8e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg8e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg8e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vlsseg8e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg2ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg2ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg2ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg2ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg3ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg3ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg3ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg3ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg4ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg4ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg4ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg4ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg5ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg5ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg5ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg5ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg6ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg6ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg6ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg6ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg7ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg7ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg7ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg7ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg8ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg8ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg8ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vluxseg8ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmacc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmacc.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadc.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,simm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vimcfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VIMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), sub_atom(pow2(SEW), 1)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadc.vim",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,simm,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vimfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VIM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvmcfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), sub_atom(pow2(SEW), 1)), VVMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadc.vvm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,vs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VVM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadc.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxmcfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), sub_atom(pow2(SEW), 1)), VXMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadc.vxm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,rs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VXM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmadd.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmand.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmandnot.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmax.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmax.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmaxu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmaxu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmerge.vim",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,simm,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then imm_val else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmerge.vvm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,vs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then plain_vector_access(vs1_val, i) else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmerge.vxm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,rs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then rs1_val else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfeq.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:840.17-840.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfeq.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:776.17-776.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfge.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:840.17-840.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfgt.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:840.17-840.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfle.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:840.17-840.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfle.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:776.17-776.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmflt.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:840.17-840.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmflt.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:776.17-776.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfne.vf",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvfmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:840.17-840.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmfne.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_fvvmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \"model/riscv_insts_vext_vm.sail:776.17-776.18\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmin.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmin.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vminu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vminu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmnand.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmnor.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmor.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmornot.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsbc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvmcfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), sub_atom(pow2(SEW), 1)), VVMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsbc.vvm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,vs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VVM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsbc.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxmcfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), sub_atom(pow2(SEW), 1)), VXMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsbc.vxm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,rs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VXM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsbf.m",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010100",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val); var found_elem : bool = false in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { if plain_vector_access(vs2_val, i) then found_elem = true else (); result[i] = if found_elem then false else true } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmseq.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vicmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmseq.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmseq.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsgt.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vicmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsgt.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsgtu.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vicmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsgtu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsif.m",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010100",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val); var found_elem : bool = false in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = if found_elem then false else true; if plain_vector_access(vs2_val, i) then found_elem = true else () } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsle.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vicmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsle.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsle.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsleu.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vicmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsleu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsleu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmslt.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmslt.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsltu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsltu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsne.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vicmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsne.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsne.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxcmpfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmsof.m",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010100",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val); var found_elem : bool = false in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { if and_bool(plain_vector_access(vs2_val, i), not(found_elem)) then { result[i] = true; found_elem = true } else { result[i] = false } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmul.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmul.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmulh.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmulh.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmulhsu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmulhsu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmulhu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmulhu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv.s.x",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gt_int(num_elem, 0), \"model/riscv_insts_vext_arith.sail:2301.21-2301.22\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, __id(m)) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val); if plain_vector_access(mask, 0) then result[0] = rs1_val else (); let tail_ag : agtype = get_vtype_vta() in { foreach (i from 1 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } }; write_vreg(num_elem, SEW, 0, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv.v.i",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        }
      ],
      "syntax": "vd,simm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = imm_val else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv.v.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = plain_vector_access(vs1_val, i) else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv.v.x",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let rs1_val : bits('m) = get_scalar(rs1, __id(m)) in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = rs1_val else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv.x.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,vs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gt_int(num_elem, 0), \"model/riscv_insts_vext_arith.sail:1830.21-1830.22\"); let n as 'n = num_elem in { let m as 'm = SEW in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vs2) in { wX_bits(rd, if lt_int(64, SEW) then slice(plain_vector_access(vs2_val, 0), 0, 64) else if gt_int(64, SEW) then sign_extend(64, plain_vector_access(vs2_val, 0)) else plain_vector_access(vs2_val, 0)); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv1r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv2r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv4r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmv8r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b100111",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmxnor.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vmxor.mm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd,vs2,vs1",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mmfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vs1_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector('n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnclip.wi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:1043.24-1043.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NI_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NI_VNCLIP => { let v_double : bits(('m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnclip.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:301.24-301.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NV_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NV_VNCLIP => { let v_double : bits(('m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnclip.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:653.24-653.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NX_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NX_VNCLIP => { let v_double : bits(('m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnclipu.wi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:1043.24-1043.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NI_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NI_VNCLIP => { let v_double : bits(('m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnclipu.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:301.24-301.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NV_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NV_VNCLIP => { let v_double : bits(('m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnclipu.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:653.24-653.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NX_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NX_VNCLIP => { let v_double : bits(('m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnmsac.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnmsac.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnmsub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnmsub.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxmafunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnsra.wi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nisfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:976.24-976.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NIS_VNSRL => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NIS_VNSRA => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let v_double : bits(('o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits('o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnsra.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nvsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:234.24-234.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NVS_VNSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NVS_VNSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let v_double : bits(('o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits('o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnsra.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nxsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:586.24-586.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NXS_VNSRL => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NXS_VNSRA => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let v_double : bits(('o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits('o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnsrl.wi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nisfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:976.24-976.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NIS_VNSRL => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NIS_VNSRA => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let v_double : bits(('o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits('o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnsrl.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nvsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:234.24-234.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NVS_VNSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NVS_VNSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let v_double : bits(('o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits('o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vnsrl.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_nxsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \"model/riscv_insts_vext_arith.sail:586.24-586.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NXS_VNSRL => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NXS_VNSRA => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let v_double : bits(('o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits('o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vor.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vor.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vor.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vpopc.m",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "rd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010000",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "0b10000",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_vd_unmasked(), not(assert_vstart(0))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector('n, bool) = read_vmask(num_elem, 0b0, vs2) in { var result : vector('n, bool) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val); var count : nat = 0 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if and_bool(plain_vector_access(mask, i), plain_vector_access(vs2_val, i)) then count = add_atom(count, 1) else () }; wX_bits(rd, to_bits(64, count)); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredand.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredmax.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredmaxu.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredmin.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredminu.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredor.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredsum.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vredxor.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrem.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrem.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vremu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vremu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrgather.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_visgfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : nat = unsigned(zero_extend(64, simm)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, imm_val) then plain_vector_access(vs2_val, sub_atom(i, imm_val)) else plain_vector_access(vd_val, i) }, VI_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:1118.58-1118.59\"); if lt_int(add_atom(i, imm_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, imm_val)) else zeros_implicit(__id(m)) } }, VI_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:1124.58-1124.59\"); if lt_int(imm_val, VLMAX) then plain_vector_access(vs2_val, imm_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrgather.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrgather.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxsgfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : nat = unsigned(rX_bits(rs1)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, rs1_val) then plain_vector_access(vs2_val, sub_atom(i, rs1_val)) else plain_vector_access(vd_val, i) }, VX_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:728.58-728.59\"); if lt_int(add_atom(i, rs1_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, rs1_val)) else zeros_implicit(__id(m)) } }, VX_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:734.58-734.59\"); if lt_int(rs1_val, VLMAX) then plain_vector_access(vs2_val, rs1_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrgatherei16.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrsub.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vrsub.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsadd.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsadd.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsaddu.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsaddu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsaddu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsbc.vvm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,vs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvmsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { var vec_trues : vector('n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VVMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VVMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsbc.vxm",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "v0",
          "type": "unknown"
        }
      ],
      "syntax": "vd,vs2,rs1,v0",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxmsfunct6(funct6)",
          "size": 6
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { var vec_trues : vector('n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector('n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VXMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VXMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vse16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vse32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vse64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vse8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsetivli",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "uimm",
          "type": "regidx"
        },
        {
          "name": "sew",
          "type": "bits(3)"
        },
        {
          "name": "lmul",
          "type": "bits(3)"
        },
        {
          "name": "ta",
          "type": "bits(1)"
        },
        {
          "name": "ma",
          "type": "bits(1)"
        }
      ],
      "syntax": "rd,uimm,sewlmultama",
      "format": "TBD",
      "fields": [
        {
          "field": "0b1100",
          "size": 4
        },
        {
          "field": "ma",
          "size": 1
        },
        {
          "field": "ta",
          "size": 1
        },
        {
          "field": "sew",
          "size": 3
        },
        {
          "field": "lmul",
          "size": 3
        },
        {
          "field": "uimm",
          "size": 5
        },
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let VLEN_pow = get_vlen_pow() in { let ELEN_pow = get_elen_pow() in { let LMUL_pow_ori = get_lmul_pow() in { let SEW_pow_ori = get_sew_pow() in { let ratio_pow_ori = sub_atom(SEW_pow_ori, LMUL_pow_ori) in { _set_Vtype_bits(ref vtype, bitvector_concat(0b0, bitvector_concat(zeros_implicit(sub_atom(64, 9)), bitvector_concat(ma, bitvector_concat(ta, bitvector_concat(sew, lmul)))))); let LMUL_pow_new = get_lmul_pow() in { let SEW_pow_new = get_sew_pow() in { if gt_int(SEW_pow_new, add_atom(LMUL_pow_new, ELEN_pow)) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64); print_reg(concat_str(\"CSR vtype <- \", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\"CSR vl <- \", string_of_bits(vl))); return RETIRE_SUCCESS } else (); let VLMAX = int_power(2, sub_atom(add_atom(VLEN_pow, LMUL_pow_new), SEW_pow_new)) in { let AVL = unsigned(uimm) in { vl = if lteq_int(AVL, VLMAX) then to_bits(64, AVL) else if lt_int(AVL, mult_atom(2, VLMAX)) then to_bits(64, quot_round_zero(add_atom(AVL, 1), 2)) else to_bits(64, VLMAX); wX_bits(rd, vl); print_reg(concat_str(\"CSR vtype <- \", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\"CSR vl <- \", string_of_bits(vl))); vstart = zeros_implicit(16); print_reg(concat_str(\"CSR vstart <- \", string_of_bits(vstart))); RETIRE_SUCCESS } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsetvli",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "sew",
          "type": "bits(3)"
        },
        {
          "name": "lmul",
          "type": "bits(3)"
        },
        {
          "name": "ta",
          "type": "bits(1)"
        },
        {
          "name": "ma",
          "type": "bits(1)"
        }
      ],
      "syntax": "rd,rs1,sewlmultama",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vsetop(op)",
          "size": 4
        },
        {
          "field": "ma",
          "size": 1
        },
        {
          "field": "ta",
          "size": 1
        },
        {
          "field": "sew",
          "size": 3
        },
        {
          "field": "lmul",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let VLEN_pow = get_vlen_pow() in { let ELEN_pow = get_elen_pow() in { let LMUL_pow_ori = get_lmul_pow() in { let SEW_pow_ori = get_sew_pow() in { let ratio_pow_ori = sub_atom(SEW_pow_ori, LMUL_pow_ori) in { match op { VSETVLI => { _set_Vtype_bits(ref vtype, bitvector_concat(0b0, bitvector_concat(zeros_implicit(sub_atom(64, 9)), bitvector_concat(ma, bitvector_concat(ta, bitvector_concat(sew, lmul)))))) }, VSETVL => { let rs2 : regidx = bitvector_concat(subrange_bits(sew, 1, 0), lmul) in { _set_Vtype_bits(ref vtype, rX_bits(rs2)) } } }; let LMUL_pow_new = get_lmul_pow() in { let SEW_pow_new = get_sew_pow() in { if gt_int(SEW_pow_new, add_atom(LMUL_pow_new, ELEN_pow)) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64); print_reg(concat_str(\"CSR vtype <- \", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\"CSR vl <- \", string_of_bits(vl))); return RETIRE_SUCCESS } else (); let VLMAX = int_power(2, sub_atom(add_atom(VLEN_pow, LMUL_pow_new), SEW_pow_new)) in { if neq_bits(rs1, 0b00000) then { let rs1_val = rX_bits(rs1) in { let AVL = unsigned(rs1_val) in { vl = if lteq_int(AVL, VLMAX) then to_bits(64, AVL) else if lt_int(AVL, mult_atom(2, VLMAX)) then to_bits(64, quot_round_zero(add_atom(AVL, 1), 2)) else to_bits(64, VLMAX); wX_bits(rd, vl) } } } else if neq_bits(rd, 0b00000) then { let AVL = unsigned(ones(64)) in { vl = to_bits(64, VLMAX); wX_bits(rd, vl) } } else { let AVL = unsigned(vl) in { let ratio_pow_new = sub_atom(SEW_pow_new, LMUL_pow_new) in { if neq_int(ratio_pow_new, ratio_pow_ori) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64) } else () } } }; print_reg(concat_str(\"CSR vtype <- \", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\"CSR vl <- \", string_of_bits(vl))); vstart = zeros_implicit(16); print_reg(concat_str(\"CSR vstart <- \", string_of_bits(vstart))); RETIRE_SUCCESS } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsetvli",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "sew",
          "type": "bits(3)"
        },
        {
          "name": "lmul",
          "type": "bits(3)"
        },
        {
          "name": "ta",
          "type": "bits(1)"
        },
        {
          "name": "ma",
          "type": "bits(1)"
        }
      ],
      "syntax": "rd,rs1,sewlmultama",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vsetop(op)",
          "size": 4
        },
        {
          "field": "ma",
          "size": 1
        },
        {
          "field": "ta",
          "size": 1
        },
        {
          "field": "sew",
          "size": 3
        },
        {
          "field": "lmul",
          "size": 3
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b111",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let VLEN_pow = get_vlen_pow() in { let ELEN_pow = get_elen_pow() in { let LMUL_pow_ori = get_lmul_pow() in { let SEW_pow_ori = get_sew_pow() in { let ratio_pow_ori = sub_atom(SEW_pow_ori, LMUL_pow_ori) in { match op { VSETVLI => { _set_Vtype_bits(ref vtype, bitvector_concat(0b0, bitvector_concat(zeros_implicit(sub_atom(64, 9)), bitvector_concat(ma, bitvector_concat(ta, bitvector_concat(sew, lmul)))))) }, VSETVL => { let rs2 : regidx = bitvector_concat(subrange_bits(sew, 1, 0), lmul) in { _set_Vtype_bits(ref vtype, rX_bits(rs2)) } } }; let LMUL_pow_new = get_lmul_pow() in { let SEW_pow_new = get_sew_pow() in { if gt_int(SEW_pow_new, add_atom(LMUL_pow_new, ELEN_pow)) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64); print_reg(concat_str(\"CSR vtype <- \", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\"CSR vl <- \", string_of_bits(vl))); return RETIRE_SUCCESS } else (); let VLMAX = int_power(2, sub_atom(add_atom(VLEN_pow, LMUL_pow_new), SEW_pow_new)) in { if neq_bits(rs1, 0b00000) then { let rs1_val = rX_bits(rs1) in { let AVL = unsigned(rs1_val) in { vl = if lteq_int(AVL, VLMAX) then to_bits(64, AVL) else if lt_int(AVL, mult_atom(2, VLMAX)) then to_bits(64, quot_round_zero(add_atom(AVL, 1), 2)) else to_bits(64, VLMAX); wX_bits(rd, vl) } } } else if neq_bits(rd, 0b00000) then { let AVL = unsigned(ones(64)) in { vl = to_bits(64, VLMAX); wX_bits(rd, vl) } } else { let AVL = unsigned(vl) in { let ratio_pow_new = sub_atom(SEW_pow_new, LMUL_pow_new) in { if neq_int(ratio_pow_new, ratio_pow_ori) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64) } else () } } }; print_reg(concat_str(\"CSR vtype <- \", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\"CSR vl <- \", string_of_bits(vl))); vstart = zeros_implicit(16); print_reg(concat_str(\"CSR vstart <- \", string_of_bits(vstart))); RETIRE_SUCCESS } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsext.vf2",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vext2_vs1(funct6)",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_half = quot_round_zero(SEW, 2) in { let LMUL_pow_half = sub_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half), not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_half in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_half), \"model/riscv_insts_vext_arith.sail:1679.23-1679.24\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT2_ZVF2 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT2_SVF2 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsext.vf4",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vext4_vs1(funct6)",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_quart = quot_round_zero(SEW, 4) in { let LMUL_pow_quart = sub_atom(LMUL_pow, 2) in { if or_bool(illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart), not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_quart in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_quart), \"model/riscv_insts_vext_arith.sail:1737.24-1737.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT4_ZVF4 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT4_SVF4 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsext.vf8",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vext8_vs1(funct6)",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_eighth = quot_round_zero(SEW, 8) in { let LMUL_pow_eighth = sub_atom(LMUL_pow, 3) in { if or_bool(illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth), not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_eighth in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_eighth), \"model/riscv_insts_vext_arith.sail:1795.25-1795.26\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT8_ZVF8 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT8_SVF8 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vslide1down.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vslide1up.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_mvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \"model/riscv_insts_vext_arith.sail:1974.57-1974.58\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vslidedown.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_visgfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : nat = unsigned(zero_extend(64, simm)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, imm_val) then plain_vector_access(vs2_val, sub_atom(i, imm_val)) else plain_vector_access(vd_val, i) }, VI_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:1118.58-1118.59\"); if lt_int(add_atom(i, imm_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, imm_val)) else zeros_implicit(__id(m)) } }, VI_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:1124.58-1124.59\"); if lt_int(imm_val, VLMAX) then plain_vector_access(vs2_val, imm_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vslidedown.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxsgfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : nat = unsigned(rX_bits(rs1)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, rs1_val) then plain_vector_access(vs2_val, sub_atom(i, rs1_val)) else plain_vector_access(vd_val, i) }, VX_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:728.58-728.59\"); if lt_int(add_atom(i, rs1_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, rs1_val)) else zeros_implicit(__id(m)) } }, VX_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:734.58-734.59\"); if lt_int(rs1_val, VLMAX) then plain_vector_access(vs2_val, rs1_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vslideup.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_visgfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : nat = unsigned(zero_extend(64, simm)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, imm_val) then plain_vector_access(vs2_val, sub_atom(i, imm_val)) else plain_vector_access(vd_val, i) }, VI_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:1118.58-1118.59\"); if lt_int(add_atom(i, imm_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, imm_val)) else zeros_implicit(__id(m)) } }, VI_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:1124.58-1124.59\"); if lt_int(imm_val, VLMAX) then plain_vector_access(vs2_val, imm_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vslideup.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxsgfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : nat = unsigned(rX_bits(rs1)) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, rs1_val) then plain_vector_access(vs2_val, sub_atom(i, rs1_val)) else plain_vector_access(vd_val, i) }, VX_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:728.58-728.59\"); if lt_int(add_atom(i, rs1_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, rs1_val)) else zeros_implicit(__id(m)) } }, VX_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \"model/riscv_insts_vext_arith.sail:734.58-734.59\"); if lt_int(rs1_val, VLMAX) then plain_vector_access(vs2_val, rs1_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsll.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsll.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsll.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsm.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vd_or_vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vd_or_vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd_or_vs3",
          "size": 5
        },
        {
          "field": "encdec_lsop(op)",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW = 8 in { let EMUL_pow = 0 in { let vl_val = unsigned(vl) in { let evl : int = if eq_int(emod_int(vl_val, 8), 0) then quot_round_zero(vl_val, 8) else add_atom(quot_round_zero(vl_val, 8), 1) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gteq_int(evl, 0), \"model/riscv_insts_vext_mem.sail:929.17-929.18\"); process_vm(vd_or_vs3, rs1, num_elem, evl, op) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsmul.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsmul.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg2ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg2ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg2ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg2ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg3ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg3ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg3ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg3ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg4ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg4ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg4ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg4ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg5ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg5ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg5ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg5ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg6ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg6ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg6ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg6ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg7ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg7ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg7ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg7ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg8ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg8ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg8ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsoxseg8ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsr.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsra.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsra.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsra.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsrl.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsrl.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsrl.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsse16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsse32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsse64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsse8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg2e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg2e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg2e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg2e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg2r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg3e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg3e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg3e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg3e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg3r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg4e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg4e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg4e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg4e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg4r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg5e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg5e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg5e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg5e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg5r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg6e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg6e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg6e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg6e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg6r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg7e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg7e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg7e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg7e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg7r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg8e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg8e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg8e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg8e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1)vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsseg8r.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "vs3,(rs1)",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \"model/riscv_insts_vext_mem.sail:838.26-838.27\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssra.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssra.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssra.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssrl.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssrl.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssrl.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg2e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg2e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg2e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg2e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg3e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg3e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg3e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg3e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg4e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg4e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg4e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg4e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg5e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg5e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg5e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg5e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg6e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg6e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg6e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg6e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg7e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg7e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg7e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg7e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg8e16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg8e32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg8e64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssseg8e8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),rs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssub.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssubu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vssubu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsub.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg2ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg2ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg2ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg2ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg3ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg3ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg3ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg3ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg4ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg4ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg4ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg4ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg5ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg5ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg5ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg5ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg6ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg6ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg6ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg6ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg7ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg7ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg7ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg7ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg8ei16.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg8ei32.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg8ei64.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vsuxseg8ei8.v",
      "name": "TBD",
      "operands": [
        {
          "name": "vs3",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vs3,(rs1),vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "nf",
          "size": 3
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_vlewidth(width)",
          "size": 3
        },
        {
          "field": "vs3",
          "size": 5
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwadd.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwadd.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwadd.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwadd.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwaddu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwaddu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwaddu.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwaddu.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmacc.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVV_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmacc.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wmvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmaccsu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVV_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmaccsu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wmvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmaccu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wmvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVV_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmaccu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wmvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmaccus.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,rs1,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wmvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmul.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmul.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmulsu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmulsu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmulu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwmulu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwredsum.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rivvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW_widen) in { if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('o) = read_single_element(SEW_widen, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let elem : bits('o) = match funct6 { IVV_VWREDSUMU => to_bits(SEW_widen, unsigned(plain_vector_access(vs2_val, i))), IVV_VWREDSUM => to_bits(SEW_widen, signed(plain_vector_access(vs2_val, i))) } in { sum = add_bits(sum, elem) } } else () }; write_single_element(SEW_widen, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwredsumu.vs",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_rivvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW_widen) in { if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as 'n = num_elem_vs in { let d as 'd = num_elem_vd in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector('d, bits('o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector('n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits('o) = read_single_element(SEW_widen, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let elem : bits('o) = match funct6 { IVV_VWREDSUMU => to_bits(SEW_widen, unsigned(plain_vector_access(vs2_val, i))), IVV_VWREDSUM => to_bits(SEW_widen, signed(plain_vector_access(vs2_val, i))) } in { sum = add_bits(sum, elem) } } else () }; write_single_element(SEW_widen, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsub.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsub.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsub.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsub.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsubu.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsubu.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsubu.wv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vwsubu.wx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_wxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b110",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_widen in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector('n, bits('o)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vxor.vi",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "simm",
          "type": "bits(5)"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,simmvm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vifunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "simm",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits('m) = sign_extend(__id(m), simm) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vxor.vv",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,vs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vvfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:150.48-150.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \"model/riscv_insts_vext_arith.sail:159.48-159.49\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vxor.vx",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2,rs1vm",
      "format": "TBD",
      "fields": [
        {
          "field": "encdec_vxfunct6(funct6)",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits('m) = get_scalar(rs1, SEW) in { let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits(('m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vzext.vf2",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vext2_vs1(funct6)",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_half = quot_round_zero(SEW, 2) in { let LMUL_pow_half = sub_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half), not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_half in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_half), \"model/riscv_insts_vext_arith.sail:1679.23-1679.24\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT2_ZVF2 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT2_SVF2 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vzext.vf4",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vext4_vs1(funct6)",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_quart = quot_round_zero(SEW, 4) in { let LMUL_pow_quart = sub_atom(LMUL_pow, 2) in { if or_bool(illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart), not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_quart in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_quart), \"model/riscv_insts_vext_arith.sail:1737.24-1737.25\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT4_ZVF4 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT4_SVF4 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "vzext.vf8",
      "name": "TBD",
      "operands": [
        {
          "name": "vd",
          "type": "regidx"
        },
        {
          "name": "vs2",
          "type": "regidx"
        },
        {
          "name": "vm",
          "type": "bits(1)"
        }
      ],
      "syntax": "vd,vs2vm",
      "format": "TBD",
      "fields": [
        {
          "field": "0b010010",
          "size": 6
        },
        {
          "field": "vm",
          "size": 1
        },
        {
          "field": "vs2",
          "size": 5
        },
        {
          "field": "vext8_vs1(funct6)",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "vd",
          "size": 5
        },
        {
          "field": "0b1010111",
          "size": 7
        }
      ],
      "extensions": [
        "V"
      ],
      "function": "{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_eighth = quot_round_zero(SEW, 8) in { let LMUL_pow_eighth = sub_atom(LMUL_pow, 3) in { if or_bool(illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth), not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as 'n = num_elem in { let m as 'm = SEW in { let o as 'o = SEW_eighth in { let vm_val : vector('n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2) in { var result : vector('n, bits('m)) = undefined in { var mask : vector('n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_eighth), \"model/riscv_insts_vext_arith.sail:1795.25-1795.26\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT8_ZVF8 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT8_SVF8 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "wfi",
      "name": "TBD",
      "operands": [],
      "syntax": "",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000100000101",
          "size": 12
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "match cur_privilege { Machine => { platform_wfi(); RETIRE_SUCCESS }, Supervisor => if eq_bits(_get_Mstatus_TW(mstatus), 0b1) then { handle_illegal(); RETIRE_FAIL } else { platform_wfi(); RETIRE_SUCCESS }, User => { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xnor",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb",
        "Zbkb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xor",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xori",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "imm",
          "type": "bits(12)"
        }
      ],
      "syntax": "rd,rs1,imm",
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_iop(op)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xperm4",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkx"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 4) by 4 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 3), i)) in { result[add_atom(i, 3) .. i] = if lt_int(mult_atom(4, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(4, index), 3), mult_atom(4, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(4, __id(index)), 3), mult_atom(4, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xperm8",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1,rs2",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkx"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 7), i)) in { result[add_atom(i, 7) .. i] = if lt_int(mult_atom(8, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(8, index), 7), mult_atom(8, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(8, __id(index)), 7), mult_atom(8, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "zext.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbb"
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SEXTB => sign_extend(64, subrange_bits(rs1_val, 7, 0)), RISCV_SEXTH => sign_extend(64, subrange_bits(rs1_val, 15, 0)), RISCV_ZEXTH => zero_extend(64, subrange_bits(rs1_val, 15, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "zip",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        }
      ],
      "syntax": "rd,rs1",
      "format": "TBD",
      "fields": [
        {
          "field": "0b000010001111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zbkb"
      ],
      "function": "{ assert(eq_int(64, 32), \"model/riscv_insts_zbkb.sail:127.27-127.28\"); exit () }",
      "description": "TBD"
    }
  ],
  "formats": [
    "I",
    "R",
    "TBD"
  ],
  "extensions": [
    "C",
    "D",
    "F",
    "V",
    "Zba",
    "Zbb",
    "Zbc",
    "Zbkb",
    "Zbkc",
    "Zbkx",
    "Zbs",
    "Zfa",
    "Zfh",
    "Zicond",
    "Zknd",
    "Zkne",
    "Zknh",
    "Zksed",
    "Zksh"
  ]
}
