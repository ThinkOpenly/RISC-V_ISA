{
    "instructions": [
        {
            "description": "AND",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "and",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "and.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "28"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) &amp; (RB)"
            ],
            "body": [
                "The contents of register RS are ANDed with the con",
                "tents of register RB and the result is placed into register ",
                "RA.",
                "Some forms of and Rx, Rx, Rx provide special func",
                "tions; see Section10.3 of Book III."
            ]
        },
        {
            "description": "AND Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "andi.",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "28"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) &amp; (<sup>48</sup>0 || UI)"
            ],
            "body": [
                "The contents of register RS are ANDed with 480||UI ",
                "and the result is placed into register RA."
            ]
        },
        {
            "description": "AND Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "andis.",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "29"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) &amp; (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "The contents of register RS are ANDed with ",
                "320||UI||160 and the result is placed into register ",
                "RA."
            ]
        },
        {
            "description": "AND with Complement",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "andc",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "andc.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "60"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) &amp; ~(RB)"
            ],
            "body": [
                "The contents of register RS are ANDed with the comple",
                "ment of the contents of register RB and the result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "Add",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "add",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "add.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "266"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "The sum (RA) + (RB) is placed into register RT."
            ]
        },
        {
            "description": "Add Carrying",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addc",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addc.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addco",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addco.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "The sum (RA) + (RB) is placed into register RT."
            ]
        },
        {
            "description": "Add Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "adde",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "adde.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addeo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addeo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "138"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + (RB) + CA"
            ],
            "body": [
                "The sum (RA) + (RB) + CA is placed into register RT."
            ]
        },
        {
            "description": "Add Extended using alternate carry bit",
            "form": "Z23-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addex",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "CY"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "CY",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "170"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if CY=0 then RT := (RA) + (RB) + OV"
            ],
            "body": [
                "For CY=0, the sum (RA) + (RB) + OV is placed into regis",
                "ter RT.",
                "For CY=0, OV is set to 1 if there is a carry out of bit 0 of ",
                "the sum in 64-bit mode or there is a carry out of bit 32 ",
                "of the sum in 32-bit mode, and set to 0 otherwise. OV32 ",
                "is set to 1 if there is a carry out of bit 32 bit of the sum.",
                "CY=1, CY=2, and CY=3 are reserved.",
                "  "
            ]
        },
        {
            "description": "Add Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addi",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "14"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201caddi\u201d  then",
                "   RT := (RA|0) + EXTS64(SI)",
                "if \u201cpaddi\u201d &amp; R=0 then",
                "   RT := (RA|0) + EXTS64(si0||si1)",
                "if \u201cpaddi\u201d &amp; R=1 then",
                "   RT := CIA + EXTS64(si0||si1)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For addi, let the sum of the contents of register RA, or ",
                "the value 0 if RA=0, and the value SI, sign-extended to ",
                "64 bits, is placed into register RT.",
                "For paddi with R=0, the sum of the contents of register ",
                "RA, or the value 0 if RA=0, and the value si0||si1, ",
                "sign-extended to 64 bits, is placed into register RT.",
                "For paddi with R=1, the sum of the address of the ",
                "instruction and the value si0||si1, sign-extended to 64 ",
                "bits, is placed into register RT.",
                "For paddi, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Examples of extended mnemonics for Add Immediate:",
                "Examples of extended mnemonics for Prefixed Add ",
                "Immediate:",
                "  "
            ]
        },
        {
            "description": "Prefixed Add Immediate",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "paddi",
                    "operands": [
                        "RT",
                        "RA",
                        "SI",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "si0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "14"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "si1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201caddi\u201d  then",
                "   RT := (RA|0) + EXTS64(SI)",
                "if \u201cpaddi\u201d &amp; R=0 then",
                "   RT := (RA|0) + EXTS64(si0||si1)",
                "if \u201cpaddi\u201d &amp; R=1 then",
                "   RT := CIA + EXTS64(si0||si1)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For addi, let the sum of the contents of register RA, or ",
                "the value 0 if RA=0, and the value SI, sign-extended to ",
                "64 bits, is placed into register RT.",
                "For paddi with R=0, the sum of the contents of register ",
                "RA, or the value 0 if RA=0, and the value si0||si1, ",
                "sign-extended to 64 bits, is placed into register RT.",
                "For paddi with R=1, the sum of the address of the ",
                "instruction and the value si0||si1, sign-extended to 64 ",
                "bits, is placed into register RT.",
                "For paddi, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Examples of extended mnemonics for Add Immediate:",
                "Examples of extended mnemonics for Prefixed Add ",
                "Immediate:",
                "  "
            ]
        },
        {
            "description": "Add Immediate Carrying",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addic",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "12"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "The sum (RA) + SI is placed into register RT.",
                "Example of extended mnemonics for Add Immediate ",
                "Carrying:"
            ]
        },
        {
            "description": "Add Immediate Carrying and Record",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addic.",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "13"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "The sum (RA) + SI is placed into register RT.",
                "Example of extended mnemonics for Add Immediate ",
                "Carrying and Record:"
            ]
        },
        {
            "description": "Add Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addis",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "15"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "if RA = 0 then RT := EXTS(SI || <sup>16</sup>0)",
                "else           RT := (RA) + EXTS(SI || <sup>16</sup>0)"
            ],
            "body": [
                "The sum (RA|0) + (SI||0x0000) is placed into regis",
                "ter RT.",
                "Examples of extended mnemonics for Add Immediate ",
                "Shifted:"
            ]
        },
        {
            "description": "Add PC Immediate Shifted",
            "form": "DX-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addpcis",
                    "operands": [
                        "RT",
                        "D"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "5"
                },
                {
                    "name": "d0",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "d2",
                    "size": "1"
                }
            ],
            "code": [
                "D := d0||d1||d2",
                "RT := NIA + EXTS(D || <sup>16</sup>0)"
            ],
            "body": [
                "The sum of NIA + (D||0x0000) is placed into register ",
                "RT. ",
                "Examples of extended mnemonics for Add PC Immedi",
                "ate Shifted:"
            ]
        },
        {
            "description": "Add and Generate Sixes",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addg6s",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "74"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 15",
                "   dc<sub>i</sub> := carry_out(RA<sub>4xi:63</sub> + RB<sub>4xi:63</sub>)",
                "c := <sup>4</sup>(dc<sub>0</sub>) || <sup>4</sup>(dc<sub>1</sub>) || ... || <sup>4</sup>(dc<sub>15</sub>)",
                "RT := (~c) &amp; 0x6666_6666_6666_6666"
            ],
            "body": [
                "The contents of register RA are added to the contents of ",
                "register RB. Sixteen carry bits are produced, one for ",
                "each carry out of decimal position n (bit position 4xn).",
                "A doubleword is composed from the 16 carry bits, and ",
                "placed into RT. The doubleword consists of a decimal ",
                "six (0b0110) in every decimal digit position for which the ",
                "corresponding carry bit is 0, and a zero (0b0000) in ",
                "every position for which the corresponding carry bit is ",
                "1.",
                "  ",
                "",
                ""
            ]
        },
        {
            "description": "Add to Minus One Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addme",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addme.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addmeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addmeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "234"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + CA - 1"
            ],
            "body": [
                "The sum (RA) + CA + 641 is placed into register RT."
            ]
        },
        {
            "description": "Add to Zero Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "addze",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addze.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addzeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addzeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "202"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + CA"
            ],
            "body": [
                "The sum (RA) + CA is placed into register RT."
            ]
        },
        {
            "description": "Bit Permute Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bpermd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "252"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 7",
                "   index := (RS)<sub>8*i:8*i+7</sub>",
                "   If index &lt; 64",
                "      then perm<sub>i</sub> := (RB)<sub>index</sub>",
                "      else perm<sub>i</sub> := 0",
                "RA := <sup>56</sup>0 || perm<sub>0:7</sub>"
            ],
            "body": [
                "Eight permuted bits are produced. For each permuted ",
                "bit i where i ranges from 0 to 7 and for each byte i of ",
                "RS, do the following.",
                "The permuted bits are placed in the least-significant ",
                "byte of RA, and the remaining bits are filled with 0s.",
                "  "
            ]
        },
        {
            "description": "Branch",
            "form": "I-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "b",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "ba",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bl",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bla",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "18"
                },
                {
                    "name": "LI",
                    "size": "24"
                },
                {
                    "name": "AA",
                    "size": "1"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if AA then NIA :=<sub>iea</sub> EXTS(LI || 0b00)",
                "else       NIA :=<sub>iea</sub> CIA + EXTS(LI || 0b00)",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "target_addr specifies the branch target address.",
                "If AA=0 then the branch target address is the sum of ",
                "LI||0b00 sign-extended and the address of this ",
                "instruction, with the high-order 32 bits of the branch tar",
                "get address set to 0 in 32-bit mode.",
                "If AA=1 then the branch target address is the value ",
                "LI||0b00 sign-extended, with the high-order 32 bits of ",
                "the branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register."
            ]
        },
        {
            "description": "Branch Conditional",
            "form": "B-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bc",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bca",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bcl",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bcla",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "16"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "BD",
                    "size": "14"
                },
                {
                    "name": "AA",
                    "size": "1"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if (64-bit mode)",
                "   then M := 0",
                "   else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>)",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok &amp; cond_ok then",
                "   if AA then NIA :=<sub>iea</sub> EXTS(BD || 0b00)",
                "   else       NIA :=<sub>iea</sub> CIA + EXTS(BD || 0b00)",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. target_addr specifies the branch target ",
                "address.",
                "If AA=0 then the branch target address is the sum of ",
                "BD||0b00 sign-extended and the address of this ",
                "instruction, with the high-order 32 bits of the branch tar",
                "get address set to 0 in 32-bit mode.",
                "If AA=1 then the branch target address is the value ",
                "BD||0b00 sign-extended, with the high-order 32 bits of ",
                "the branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "Examples of extended mnemonics for Branch Condi",
                "tional:"
            ]
        },
        {
            "description": "Branch Conditional to Branch Target Address Register",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bctar",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "mnemonic": "bctarl",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "BH",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "560"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if (64-bit mode)",
                "   then M := 0",
                "   else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok &amp; cond_ok then NIA :=<sub>iea</sub> TAR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. The BH field is used as described in ",
                "Figure44. The branch target address is ",
                "TAR<sub>0:61</sub>||0b00, with the high-order 32 bits of the ",
                "branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "  ",
                ""
            ]
        },
        {
            "description": "Branch Conditional to Count Register",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcctr",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bcctrl",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "BH",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "528"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if cond_ok then NIA :=<sub>iea</sub> CTR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. The BH field is used as described in ",
                "Figure44. The branch target address is ",
                "CTR<sub>0:61</sub>||0b00, with the high-order 32 bits of the ",
                "branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "If the \u201cdecrement and test CTR\u201d option is specified ",
                "(BO<sub>2</sub>=0), the instruction form is invalid.",
                "Examples of extended mnemonics for Branch Condi",
                "tional to Count Register."
            ]
        },
        {
            "description": "Branch Conditional to Link Register",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bclr",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bclrl",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "BH",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "16"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if (64-bit mode)",
                "   then M := 0",
                "   else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok &amp; cond_ok then NIA :=<sub>iea</sub> LR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. The BH field is used as described in ",
                "Figure44. The branch target address is LR<sub>0:61</sub>||0b00, ",
                "with the high-order 32 bits of the branch target address ",
                "set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "Examples of extended mnemonics for Branch Condi",
                "tional to Link Register:",
                "  "
            ]
        },
        {
            "description": "Byte-Reverse Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "brd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "187"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> ||",
                "RA := (RS)<sub>40:47</sub> || (RS)<sub>32:39 </sub>||",
                "RA := (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> ||",
                "RA := (RS)<sub>8:15 </sub> || (RS)<sub>0:7</sub>"
            ],
            "body": [
                "The contents of register RS are placed into register RA in ",
                "byte-reversed order."
            ]
        },
        {
            "description": "Byte-Reverse Halfword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "brh",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "219"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS)<sub>8:15 </sub> || (RS)<sub>0:7  </sub> ||",
                "RA := (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> ||",
                "RA := (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub> ||",
                "RA := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>"
            ],
            "body": [
                "The contents of bits 0:15 of register RS are placed into ",
                "bits 0:15 of register RA in byte-reversed order.",
                "The contents of bits 16:31 of register RS are placed into ",
                "bits 16:31 of register RA in byte-reversed order.",
                "The contents of bits 32:47 of register RS are placed into ",
                "bits 32:47 of register RA in byte-reversed order.",
                "The contents of bits 48:63 of register RS are placed into ",
                "bits 48:63 of register RA in byte-reversed order."
            ]
        },
        {
            "description": "Byte-Reverse Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "brw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "155"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> ||",
                "RA := (RS)<sub>8:15 </sub> || (RS)<sub>0:7  </sub> ||",
                "RA := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> ||",
                "RA := (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub>"
            ],
            "body": [
                "The contents of bits 0:31 of register RS are placed into ",
                "bits 0:31 of register RA in byte-reversed order.",
                "The contents of bits 32:63 of register RS are placed into ",
                "bits 32:63 of register RA in byte-reversed order."
            ]
        },
        {
            "description": "Centrifuge Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cfuged",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "220"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "ptr0 := 0",
                "ptr1 := 0",
                "do i = 0 to 63",
                "   if((RB)<sub>i</sub>=0) then do",
                "      result<sub>ptr0</sub> := (RS)<sub>i</sub>",
                "      ptr0 := ptr0 + 1",
                "   end",
                "   if((RB)<sub>63-i</sub>==1) then do",
                "      result<sub>63-ptr1</sub> := (RS)<sub>63-i</sub>",
                "      ptr1 := ptr1 + 1",
                "   end",
                "end",
                "RA := result"
            ],
            "body": [
                "The bits in GPR[RS] whose corresponding bits in the ",
                "mask in GPR[RB] equal 1 are placed in the rightmost ",
                "bits in GPR[RA] maintaining their relative original order.  ",
                "The other bits in GPR[RS] are placed in the leftmost bits ",
                "in GPR[RA] maintaining their relative original order."
            ]
        },
        {
            "description": "Clear BHRB",
            "form": "X-form",
            "category": "Branch History Rolling Buffer",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "clrbhrb",
                    "operands": [
                        ""
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "430"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "for n = 0 to (number_of_BHRBEs implemented - 1)",
                "  BHRB(n) := 0"
            ],
            "body": [
                "All BHRB entries are set to 0s."
            ]
        },
        {
            "description": "Compare",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cmp",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)<sub>32:63</sub>)",
                "              b := EXTS((RB)<sub>32:63</sub>)",
                "         else a := (RA)",
                "              b := (RB)",
                "if      a &lt; b then c := 0b100",
                "else if a &gt; b then c := 0b010",
                "else               c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> if L=0) are com",
                "pared with the contents of register RB ((RB)<sub>32:63</sub> if L=0), ",
                "treating the operands as signed integers. The result of ",
                "the comparison is placed into CR field BF",
                ".",
                "Examples of extended mnemonics for Compare:"
            ]
        },
        {
            "description": "Compare Bytes",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cmpb",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "508"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "do n = 0 to 7 ",
                "   if RS<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> = (RB)<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> then ",
                "      RA<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> := 81",
                "   else ",
                "      RA<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> := 80"
            ],
            "body": [
                "Each byte of the contents of register RS is compared to ",
                "each corresponding byte of the contents in register RB. ",
                "If they are equal, the corresponding byte in RA is set to ",
                "0xFF. Otherwise the corresponding byte in RA is set to ",
                "0x00."
            ]
        },
        {
            "description": "Compare Equal Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cmpeqb",
                    "operands": [
                        "BF",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "224"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "src1 := GPR[RA].bit[56:63]",
                "",
                "match := (src1 = (RB)<sub>00:07</sub>) |",
                "match := (src1 = (RB)<sub>08:15</sub>) |",
                "match := (src1 = (RB)<sub>16:23</sub>) |",
                "match := (src1 = (RB)<sub>24:31</sub>) |",
                "match := (src1 = (RB)<sub>32:39</sub>) |",
                "match := (src1 = (RB)<sub>40:47</sub>) |",
                "match := (src1 = (RB)<sub>48:55</sub>) |",
                "match := (src1 = (RB)<sub>56:63</sub>)",
                "",
                "CR<sub>4\u00d7BF+32:4\u00d7BF+35</sub> := 0b0 || match || 0b00"
            ],
            "body": [
                "CR field BF is set to indicate if the contents of bits 56:63 ",
                "of register RA are equal to the contents of any of the 8 ",
                "bytes in register RB.",
                "Results are undefined in 32-bit mode.",
                ""
            ]
        },
        {
            "description": "Compare Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cmpi",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "11"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)<sub>32:63</sub>)",
                "         else a := (RA)",
                "if      a &lt; EXTS(SI) then c := 0b100",
                "else if a &gt; EXTS(SI) then c := 0b010",
                "else                      c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> sign-extended to ",
                "64 bits if L=0) are compared with the sign-extended ",
                "value of the SI field, treating the operands as signed ",
                "integers. The result of the comparison is placed into CR ",
                "field BF.",
                "Examples of extended mnemonics for Compare Imme",
                "diate:"
            ]
        },
        {
            "description": "Compare Logical",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cmpl",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "32"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then a := <sup>32</sup>0 || (RA)<sub>32:63</sub>",
                "              b := <sup>32</sup>0 || (RB)<sub>32:63</sub>",
                "         else a := (RA)",
                "              b := (RB)",
                "if      a &lt;<sup>u</sup> b then c := 0b100",
                "else if a &gt;<sup>u</sup> b then c := 0b010",
                "else                c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> if L=0) are com",
                "pared with the contents of register RB ((RB)<sub>32:63</sub> if L=0), ",
                "treating the operands as unsigned integers. The result ",
                "of the comparison is placed into CR field BF",
                ".",
                "Examples of extended mnemonics for Compare Logi",
                "cal:"
            ]
        },
        {
            "description": "Compare Logical Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cmpli",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "UI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "10"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "if L = 0 then a := <sup>32</sup>0 || (RA)<sub>32:63</sub>",
                "         else a := (RA)",
                "if      a &lt;<sup>u</sup> (<sup>48</sup>0 || UI) then c := 0b100",
                "else if a &gt;<sup>u</sup> (<sup>48</sup>0 || UI) then c := 0b010",
                "else                         c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> zero-extended to ",
                "64 bits if L=0) are compared with 480||UI, treating the ",
                "operands as unsigned integers. The result of the com",
                "parison is placed into CR field BF",
                ".",
                "Examples of extended mnemonics for Compare Logi",
                "cal Immediate:"
            ]
        },
        {
            "description": "Compare Ranged Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cmprb",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "192"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "src1    := EXTZ((RA)<sub>56:63</sub>)",
                "",
                "src21hi := EXTZ((RB)<sub>32:39</sub>)",
                "src21lo := EXTZ((RB)<sub>40:47</sub>)",
                "src22hi := EXTZ((RB)<sub>48:55</sub>)",
                "src22lo := EXTZ((RB)<sub>56:63</sub>)",
                "",
                "if L=0 then",
                "   in_range :=  (src22lo &lt;= src1) &amp; (src1 &lt;= src22hi)",
                "else",
                "   in_range := ((src21lo &lt;= src1) &amp; (src1 &lt;= src21hi)) |",
                "   in_range := ((src22lo &lt;= src1) &amp; (src1 &lt;= src22hi))",
                "",
                "CR<sub>4\u00d7BF+32:4\u00d7BF+35</sub> := 0b0 || in_range || 0b00"
            ],
            "body": [
                "Let src1 be the unsigned integer value in bits 56:63 of ",
                "register RA.",
                "Let src21hi be the unsigned integer value in bits 32:39 ",
                "of register RB.",
                "Let src21lo be the unsigned integer value in bits 40:47 ",
                "of register RB.",
                "Let src22hi be the unsigned integer value in bits 48:55 ",
                "of register RB.",
                "Let src22lo be the unsigned integer value in bits 56:63 ",
                "of register RB.",
                "Let x be considered \u201cin range\u201d of y:z if the value x is ",
                "greater than or equal to the value y and the value x is ",
                "less than or equal to the value z.",
                "When L=0, the value in_range is set to 1 if src1 is in ",
                "range of src22lo:src22hi. Otherwise, the value ",
                "in_range is set to 0.",
                "When L=1, the value in_range is set to 1 if either src1 ",
                "is in range of src21lo:src21hi, or src1 is in range of ",
                "src22lo:src22hi. Otherwise, the value in_range is set ",
                "to 0.",
                "CR field BF is set to the value 0b0 concatenated with ",
                "in_range concatenated with 0b00. ",
                ""
            ]
        },
        {
            "description": "Condition Register AND",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "crand",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "257"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> &amp; CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ANDed with the bit in the Condition Register specified ",
                "by BB+32, and the result is placed into the bit in the ",
                "Condition Register specified by BT+32."
            ]
        },
        {
            "description": "Condition Register AND with Complement",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "crandc",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "129"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> &amp; ~CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ANDed with the complement of the bit in the Condition ",
                "Register specified by BB+32, and the result is placed ",
                "into the bit in the Condition Register specified by ",
                "BT+32."
            ]
        },
        {
            "description": "Condition Register Equivalent",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "creqv",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "289"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> == CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "XORed with the bit in the Condition Register specified ",
                "by BB+32, and the complemented result is placed into ",
                "the bit in the Condition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter Equivalent:"
            ]
        },
        {
            "description": "Condition Register NAND",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "crnand",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "225"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := ~(CR<sub>BA+32</sub> &amp; CR<sub>BB+32</sub>)"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ANDed with the bit in the Condition Register specified ",
                "by BB+32, and the complemented result is placed into ",
                "the bit in the Condition Register specified by BT+32."
            ]
        },
        {
            "description": "Condition Register NOR",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "crnor",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "33"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := ~(CR<sub>BA+32</sub> | CR<sub>BB+32</sub>)"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ORed with the bit in the Condition Register specified by ",
                "BB+32, and the complemented result is placed into the ",
                "bit in the Condition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter NOR:"
            ]
        },
        {
            "description": "Condition Register OR",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cror",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "449"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> | CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ORed with the bit in the Condition Register specified by ",
                "BB+32, and the result is placed into the bit in the Con",
                "dition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter OR:"
            ]
        },
        {
            "description": "Condition Register OR with Complement",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "crorc",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "417"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> | ~CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ORed with the complement of the bit in the Condition ",
                "Register specified by BB+32, and the result is placed ",
                "into the bit in the Condition Register specified by ",
                "BT+32."
            ]
        },
        {
            "description": "Condition Register XOR",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "crxor",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "193"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> ^ CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "XORed with the bit in the Condition Register specified ",
                "by BB+32, and the result is placed into the bit in the ",
                "Condition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter XOR:"
            ]
        },
        {
            "description": "Convert Binary Coded Decimal To Declets",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cbcdtd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "314"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 1",
                "   n := i x 32",
                "RA<sub>n+0:n+11  </sub>:= 0 ",
                "RA<sub>n+12:n+21 </sub>:= BCD_TO_DPD((RS)<sub>n+8:n+19</sub>) ",
                "RA<sub>n+22:n+31 </sub>:= BCD_TO_DPD((RS)<sub>n+20:n+31</sub>)"
            ],
            "body": [
                "The low-order 24 bits of each word of register RS con",
                "tain six, 4-bit BCD fields which are converted to two ",
                "declets; each set of two declets is placed into the ",
                "low-order 20 bits of the corresponding word in RA. The ",
                "high-order 12 bits in each word of RA are set to 0.",
                "If a 4-bit BCD field has a value greater than 9 the ",
                "results are undefined."
            ]
        },
        {
            "description": "Convert Declets To Binary Coded Decimal",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cdtbcd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "282"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 1",
                "   n := i x 32",
                "RA<sub>n+0:n+7  </sub> := 0 ",
                "RA<sub>n+8:n+19  </sub>:= DPD_TO_BCD((RS)<sub>n+12:n+21</sub>)",
                "RA<sub>n+20:n+31 </sub>:= DPD_TO_BCD((RS)<sub>n+22:n+31</sub>)"
            ],
            "body": [
                "The low-order 20 bits of each word of register RS con",
                "tain two declets which are converted to six, 4-bit BCD ",
                "fields; each set of six, 4-bit BCD fields is placed into the ",
                "low-order 24 bits of the corresponding word in RA. The ",
                "high-order 8 bits in each word of RA are set to 0."
            ]
        },
        {
            "description": "Copy",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "copy",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "774"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "copy_buffer := memory(EA,128)||MEM<sub>metadata</sub>(EA,128)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). ",
                "The 128 bytes in storage, and associated metadata,  ",
                "addressed by EA is loaded into the copy buffer.",
                "If the EA is not a multiple of 128, the system alignment ",
                "error handler is invoked.",
                "If the specified block is in storage that is Caching Inhib",
                "ited, the system data storage error handler is invoked",
                "When successful, this instruction is treated as a Load ",
                "(see Section4.3, \u201cCache Management Instructions\u201d), ",
                "except that the data transfer ordering is described in ",
                "Section1.7.1.1, \u201cStorage Ordering of Copy/Paste-Initi",
                "ated Data Transfers\u201d."
            ]
        },
        {
            "description": "Copy-Paste Abort",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "cpabort",
                    "operands": [
                        ""
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "838"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "clear the state of the Copy-Paste Facility"
            ],
            "body": [
                "The cpabort instruction causes a data transfer to fail if ",
                "one is in progress.",
                "Any pending errors in the Copy-Paste Facility are ",
                "cleared and the state is reset to prepare for a new ",
                "copy.",
                " ",
                " ",
                "",
                "The Atomic Memory Operation (AMO) facility may be ",
                "used to optimize performance when many software ",
                "threads are manipulating shared control structures con",
                "currently.  In such situations, accessing the shared data ",
                "frequently involves transfering the data from one pro",
                "cessor\u2019s cache to another.  The latency of such trans",
                "fers can become the limiting factor in the performance ",
                "of some environments.  Rather than moving the data to ",
                "the work, AMOs move the work to the data.  The men",
                "tal model is of an agent consisting of an execution unit ",
                "and a work queue near memory that receives atomic ",
                "update requests from all the processors in the system.",
                "Despite that AMOs are performed at memory, their ",
                "function is only defined for storage that is not Caching ",
                "Inhibited.  This is done so that software can transpar",
                "ently access the same data using normal loads and ",
                "stores.  But furthermore, AMOs generally behave as ",
                "typical explicit storage accesses performed by the ",
                "thread, with respect to storage access ordering.  The ",
                "few complications are described below.      Since the ",
                "performance advantage of AMOs derives from avoiding ",
                "time of flight through cache hierarchies, software ",
                "should avoid frequent mixing of normal loads and ",
                "stores and AMOs to the same storage locations.  ",
                "AMOs are also restricted to storage that is not Guarded ",
                "and storage that is not Write Through Required to limit ",
                "implementation complexity.",
                "The facility specifies a set of atomic update operations ",
                "that a processor may send, accompanied by operands ",
                "from GPRs, to the memory to be performed.  The oper",
                "ations are expressed using the Load Atomic (LAT) and ",
                "Store Atomic (STAT) instructions.  Each of these ",
                "instructions performs an atomic update operation (load ",
                "followed by some manipulation and a store) on some ",
                "location in storage.  As a result, these instructions are ",
                "considered to be both fixed-point Load instructions and ",
                "fixed-point Store instructions, and any reference else",
                "where in the architecture to fixed-point Load or ",
                "fixed-point Store instructions apply to these instructions ",
                "as well, unless otherwise stated or obvious from con",
                "text.  For example, in order to perform an AMO, it is ",
                "necessary to have both read and write access to the ",
                "storage location.  Another example is that the DAWR ",
                "will detect a match if either Data Read or Data Write is ",
                "selected.  Yet another example is that a Trace interrupt ",
                "will indicate both a Load and a Store instruction have ",
                "been executed.  Barrier action will be based on whether ",
                "the barrier would give a load or a store the stronger ",
                "ordering.  The difference between the Load Atomic ",
                "instructions and the Store Atomic instructions is simply ",
                "that the Load Atomic instructions return a result to a ",
                "GPR, while the Store Atomic instructions do not.  In the ",
                "RTL in the following subsections, the \u201clat\u201d and \u201cstat\u201d ",
                "functions represent the manipulations performed by the ",
                "memory agent.  The parameters shown are the maxi",
                "mum storage footprint, the maximum list of registers, ",
                "and the function code that are provided to the agent.  If ",
                "the specified registers wrap (e.g. RT=R31 and ",
                "RT+1=R0), the wrapping is permitted.  Such an instruc",
                "tion is not an invalid form.  Destructive encodings are ",
                "also permitted (i.e. a LAT specified with RT=RA).",
                "Except in this section, references to \u201catomic update\u201d in ",
                "Books I-III imply use of the Load And Reserve and ",
                "Store Conditional instructions unless otherwise stated ",
                "or obvious from context.",
                "  ",
                " ",
                " "
            ]
        },
        {
            "description": "Count Leading Zeros Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cntlzd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "cntlzd.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "58"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := 0",
                "do while n &lt; 64",
                "  if (RS)<sub>n</sub> = 1 then leave",
                "  n := n + 1",
                "RA := n"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 0 of register RS is placed into register RA. This ",
                "number ranges from 0 to 64, inclusive.",
                "If Rc=1, CR Field 0 is set to reflect the result."
            ]
        },
        {
            "description": "Count Leading Zeros Doubleword under bit Mask",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cntlzdm",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "59"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "count = 0",
                "do i = 0 to 63",
                "   if((RB)<sub>i</sub>=1) then do",
                "      if((RS)<sub>i</sub>=1) then break",
                "      count := count + 1",
                "   end",
                "end",
                "RA := EXTZ64(count)"
            ],
            "body": [
                "Let n be the number of bits in register RB having the ",
                "value 1.",
                "Extract and pack together the contents of the bits in ",
                "register RS corresponding to a mask specified in ",
                "register RB, creating an n-bit value. ",
                "Count the number of contiguous leftmost 0 bits in the ",
                "n-bit extracted value and place the result into register ",
                "RA."
            ]
        },
        {
            "description": "Count Leading Zeros Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cntlzw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "cntlzw.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "26"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := 32",
                "",
                "do while n &lt; 64",
                "   if (RS)<sub>n</sub> = 1 then leave",
                "   n := n + 1",
                "",
                "RA := n - 32"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 32 of register RS is placed into register RA. This ",
                "number ranges from 0 to 32, inclusive.",
                "If Rc is equal to 1, CR field 0 is set to reflect the result.",
                "  "
            ]
        },
        {
            "description": "Count Trailing Zeros Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cnttzd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "cnttzd.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "570"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n  := 0",
                "do while n &lt; 64",
                "   if (RS)<sub>63-n</sub> = 0b1 then leave ",
                "   n  := n + 1",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 63 of register RS is placed into register RA. This ",
                "number ranges from 0 to 64, inclusive.",
                "If Rc is equal to 1, CR field 0 is set to reflect the result."
            ]
        },
        {
            "description": "Count Trailing Zeros Doubleword under bit Mask",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cnttzdm",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "571"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "count := 0",
                "do i = 0 to 63",
                "   if((RB)<sub>63-i</sub>=1) then do",
                "      if((RS)<sub>63-i</sub>=1) then break",
                "      count := count + 1",
                "   end",
                "end",
                "RA := EXTZ64(count)"
            ],
            "body": [
                "Let n be the number of bits in register RB having the ",
                "value 1.",
                "Extract and pack together the contents of bits in ",
                "register RS corresponding to a mask specified in ",
                "register RB, creating an n-bit value. ",
                "Count the number of contiguous rightmost 0 bits in the ",
                "n-bit extracted value and place the result into register ",
                "RA."
            ]
        },
        {
            "description": "Count Trailing Zeros Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "cnttzw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "cnttzw.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "538"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := 0",
                "",
                "do while n &lt; 32",
                "   if (RS)<sub>63-n</sub> = 0b1 then leave ",
                "   n  := n + 1",
                "",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 63 of the rightmost word of register RS is placed ",
                "into register RA. This number ranges from 0 to 32, ",
                "inclusive.",
                "If Rc is equal to 1, CR field 0 is set to reflect the result."
            ]
        },
        {
            "description": "DFP Add",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "2"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Add Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "daddq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "2"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRA[p] is added to the DFP oper",
                "and in FRB[p].  ",
                "The result is rounded to the target-format precision ",
                "under control of  DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the smaller exponent of the two ",
                "source operands. ",
                "Figure80 summarizes the actions for Add.  Figure80 ",
                "does not include the setting of FPRF. FPRF is always set ",
                "to the class and sign of the result, except for an ",
                "enabled invalid-operation exception, in which case the ",
                "field remains unchanged.",
                "dadd[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Compare Ordered",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dcmpo",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "130"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Compare Ordered Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dcmpoq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "FRBp"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "130"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRA[p] is compared to the DFP ",
                "operand in FRB[p].  The result of the compare is placed ",
                "into CR field BF and the FPCC.",
                "dcmpo[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        {
            "description": "DFP Compare Unordered",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dcmpu",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "642"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Compare Unordered Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dcmpuq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "FRBp"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "642"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRA[p] is compared to the DFP ",
                "operand in FRB[p].  The result of the compare is placed ",
                "into CR field BF and the FPCC.",
                "dcmpu[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        {
            "description": "DFP Convert From Fixed",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dcffix",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "802"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The 64-bit signed binary integer in FRB is converted ",
                "and rounded to a DFP Long value and placed into FRT.  ",
                "The sign of the result is the same as the sign of the ",
                "source operand.  The ideal exponent is zero.",
                "If the source operand is a zero, then a plus zero with a ",
                "zero exponent is returned.",
                "FPRF is set to the class and sign of the result.",
                "dcffix[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert From Fixed Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dcffixq",
                    "operands": [
                        "FRTp",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "802"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The 64-bit signed binary integer in FRB is converted ",
                "and rounded to a DFP Extended value and placed into ",
                "FRTp. The sign of the result is the same as the sign of ",
                "the source operand. The ideal exponent is zero.",
                "If the source operand is a zero, then a plus zero with a ",
                "zero exponent is returned.",
                "FPRF is set to the class and sign of the result.",
                "dcffixq[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert From Fixed Quadword Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dcffixqq",
                    "operands": [
                        "FRTp",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "994"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The 128-bit signed binary integer in VRB is converted ",
                "and rounded to a DFP Extended value and placed into ",
                "FRTp. The sign of the result is the same as the sign of ",
                "the source operand. The ideal exponent is zero.",
                "If the source operand is a zero, then a plus zero with a ",
                "zero exponent is returned.",
                "FPRF is set to the class and sign of the result.",
                "dcffixqq is treated as a Floating-Point and a Vector ",
                "instruction in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To DFP Extended",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dctqpq",
                    "operands": [
                        "FRTp",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "258"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP long operand in the FRB is converted to DFP ",
                "extended format and placed into FRTp. The sign of the ",
                "result is the same as the sign of the operand in FRB. ",
                "The ideal exponent is the exponent of the operand in ",
                "FRB.",
                "If the operand in FRB is an SNaN, an invalid-operation ",
                "exception is recognized. If the exception is disabled, ",
                "the SNaN is converted to the corresponding QNaN in ",
                "DFP extended format.",
                "dctqpq[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To DFP Long",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dctdp",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "258"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP short operand in bits 32:63 of FRB is ",
                "converted to DFP long format and the converted result ",
                "is placed into FRT. The sign of the result is the same as ",
                "the sign of the source operand. The ideal exponent is ",
                "the exponent of the source operand.",
                "If the operand in FRB is an SNaN, it is converted to an ",
                "SNaN in DFP long format and does not cause an ",
                "invalid-operation exception.",
                "dctdp[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To Fixed",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dctfix",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "290"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Convert To Fixed Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dctfixq",
                    "operands": [
                        "FRT",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "290"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRB[p] is rounded to an integer ",
                "value and is placed into FRT in the 64-bit signed binary ",
                "integer format.  The sign of the result is the same as ",
                "the sign of the source operand, except when the ",
                "source operand is a NaN or a zero.",
                "Figure96 summarizes the actions for Convert To ",
                "Fixed.",
                "dctfix[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To Fixed Quadword Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dctfixqq",
                    "operands": [
                        "VRT",
                        "FRBp"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "994"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRBp is rounded to an integer ",
                "value and is placed into VRT in the 128-bit signed ",
                "binary integer format. The sign of the result is the ",
                "same as the sign of the source operand, except when ",
                "the source operand is a NaN or a zero.",
                "Figure 96 summarizes the actions for Convert To ",
                "Fixed.",
                "dctfixqq is treated as a Floating-Point and a Vector ",
                "instruction in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Decode DPD To BCD",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ddedpd",
                    "operands": [
                        "SP",
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "SP",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "322"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Decode DPD To BCD Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ddedpdq",
                    "operands": [
                        "SP",
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "SP",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "322"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "A portion of the significand of the DFP operand in ",
                "FRB[p] is converted to a signed or unsigned BCD ",
                "number depending on the SP field. For infinity and ",
                "NaN, the significand is considered to be the contents ",
                "in the trailing significand field padded on the left by a ",
                "zero digit.",
                "ddedpd[q][.] are treated as Floating-Point instructions ",
                "in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Divide",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ddiv",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "546"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Divide Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ddivq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "546"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRA[p] is divided by the DFP ",
                "operand in FRB[p].  ",
                "The result is rounded to the target-format precision ",
                "under control of the DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the difference of subtracting the ",
                "exponent of the divisor from the exponent of the ",
                "dividend.",
                "Figure82 summarizes the actions for Divide.  ",
                "Figure82 does not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except ",
                "for an enabled invalid-operation and enabled ",
                "zero-divide exceptions, in which cases the field ",
                "remains unchanged.",
                "ddiv[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Encode BCD To DPD",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "denbcd",
                    "operands": [
                        "S",
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "S",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "834"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Encode BCD To DPD Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "denbcdq",
                    "operands": [
                        "S",
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "S",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "834"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The signed or unsigned BCD operand, depending on ",
                "the S field, in FRB[p] is converted to a DFP number. ",
                "The ideal exponent is zero.",
                "If an invalid BCD digit or sign code is detected in the ",
                "source operand, an invalid-operation exception (VXCVI) ",
                "occurs.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exception when VE=1.",
                "denbcd[q][.] are treated as Floating-Point instructions ",
                "in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Extract Biased Exponent",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dxex",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "354"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Extract Biased Exponent Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dxexq",
                    "operands": [
                        "FRT",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "354"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The biased exponent of the operand in FRB[p] is ",
                "extracted and placed into FRT in the 64-bit signed ",
                "binary integer format.  When the operand in FRB is an ",
                "infinity, QNaN, or SNaN, a special code is returned. ",
                "dxex[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Insert Biased Exponent",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "diex",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "866"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Insert Biased Exponent Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "diexq",
                    "operands": [
                        "FRTp",
                        "FRA",
                        "FRBp"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "866"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let a be the value of the 64-bit signed binary integer in ",
                "FRA.",
                "",
                "When 0 \u00a3 a \u00a3 MBE, a is the biased target exponent ",
                "that is combined with the sign bit and the significand ",
                "value of the DFP operand in FRB[p] to form the DFP ",
                "result in FRT[p]. The ideal exponent is the specified ",
                "target exponent.",
                "When a specifies a special code (a &lt; 0 or a &gt; MBE), an ",
                "infinity, QNaN, or SNaN is formed in FRT[p] with the ",
                "trailing significand field containing the value from the ",
                "trailing significand field of the source operand in ",
                "FRB[p], and with an N-bit combination field set as ",
                "follows.",
                "diex[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Multiply",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dmul",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "34"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Multiply Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dmulq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "34"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRA[p] is multiplied by the DFP ",
                "operand in FRB[p].  ",
                "The result is rounded to the target-format precision ",
                "under control of DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the sum of the two exponents of ",
                "the source operands.",
                "Figure81 summarizes the actions for Multiply.  ",
                "Figure81 does not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except for ",
                "an enabled invalid-operation exception, in which case ",
                "the field remains unchanged.",
                "dmul[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Quantize",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dqua",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "3"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Quantize Immediate",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dquai",
                    "operands": [
                        "TE",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "TE",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "67"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Quantize Immediate Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dquaiq",
                    "operands": [
                        "TE",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "TE",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "67"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRB[p] is converted and rounded ",
                "to the form with the exponent specified by TE based on ",
                "the rounding mode specified in the RMC field. TE is a ",
                "5-bit signed binary integer.  The result of that form is ",
                "placed in FRT[p].  The sign of the result is the same as ",
                "the sign of the operand in FRB[p].  The ideal exponent ",
                "is the exponent specified by TE.",
                "When the value of the operand in FRB[p] is greater ",
                "than (10p-1) % 10TE, where p is the format precision, ",
                "an invalid operation exception is recognized.",
                "When the delivered result differs in value from the ",
                "operand in FRB[p], an inexact exception is recognized.  ",
                "No underflow exception is recognized by this ",
                "operation, regardless of the value of the operand in ",
                "FRB[p].",
                "FPRF is always set to the class and sign of the result, ",
                "except for an enabled invalid-operation exception, in ",
                "which case the field remains unchanged.",
                "dquai[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Quantize Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dquaq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "3"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in register FRB[p] is converted and ",
                "rounded to the form with the same exponent as that of ",
                "the DFP operand in FRA[p] based on the rounding ",
                "mode specified by RMC. The result of that form is placed ",
                "in FRT[p].  The sign of the result is the same as the ",
                "sign of the operand in FRB[p]. The ideal exponent is ",
                "the exponent specified in FRA[p].",
                "When the value of the operand in FRB[p] is greater ",
                "than (10p-1) x 10Ea, where p is the format precision ",
                "and Ea is the exponent of the operand in FRA[p], an ",
                "invalid operation exception is recognized.",
                "When the delivered result differs in value from the ",
                "operand in FRB[p], an inexact exception is recognized.  ",
                "No underflow exception is recognized by this ",
                "operation, regardless of the value of the operand in ",
                "FRB[p].",
                "Figure89 and Figure90 summarize the actions.  The ",
                "tables do not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except ",
                "for an enabled invalid-operation exception, in which ",
                "case the field remains unchanged.",
                "dqua[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Reround",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drrnd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "35"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Reround Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drrndq",
                    "operands": [
                        "FRTp",
                        "FRA",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "35"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let k be the contents of bits 58:63 of FRA that specifies ",
                "the reference significance.",
                "When the DFP operand in FRB[p] is a finite number, ",
                "and if the reference significance is zero, or if the ",
                "reference significance is nonzero and the number of ",
                "significant digits of the source operand is less than or ",
                "equal to the reference significance, then the value and ",
                "the form of the source operand is placed in FRT[p].  If ",
                "the reference significance is nonzero and the number ",
                "of significant digits of the source operand is greater ",
                "than the reference significance, then the source ",
                "operand is converted and rounded to the number of ",
                "significant digits specified in the reference significance ",
                "based on the rounding mode specified in the RMC ",
                "field.  The result of the form with the specified number ",
                "of significant digits is placed in FRT[p].  The sign of the ",
                "result is the same as the sign of the operand in FRB[p].",
                "For this instruction, the number of significant digits of ",
                "the value 0 is considered to be zero.  The ideal ",
                "exponent is the greater value of the exponent of the ",
                "operand in FRB[p] and the referenced exponent.  The ",
                "referenced exponent is the resultant exponent if the ",
                "operand in FRB[p] would have been converted and ",
                "rounded to the number of significant digits specified in ",
                "the reference significance based on the rounding ",
                "mode specified by RMC.",
                "If the exponent of the rounded result of the form that ",
                "has the specified number of significant digits would be ",
                "greater than X<sub>max</sub><sub>,</sub> an invalid operation exception (VXCVI) ",
                "occurs.  When the invalid-operation exception occurs, ",
                "and if the exception is disabled, a default QNaN is ",
                "returned.  When an invalid-operation exception occurs, ",
                "no inexact exception is recognized.",
                "In the absence of an invalid-operation exception, if the ",
                "result differs in value from the operand in FRB[p], an ",
                "inexact exception is recognized.",
                "This operation causes neither an overflow nor an ",
                "underflow exception.",
                "Figure92 summarizes the actions for Reround.  The ",
                "table does not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except ",
                "for an enabled invalid-operation exception, in which ",
                "case the field remains unchanged.",
                "drrnd[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Round To DFP Long",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drdpq",
                    "operands": [
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "770"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP extended operand in FRBp is converted and ",
                "rounded to DFP long format. The result concatenated ",
                "with 64 0s is placed in FRTp. The sign of the result is ",
                "the same as the sign of the source operand. The ideal ",
                "exponent is the exponent of the operand in FRBp.",
                "If the operand in FRBp is an SNaN, an invalid-operation ",
                "exception is recognized. If the exception is disabled, ",
                "the SNaN is converted to the corresponding QNaN in ",
                "DFP long format.",
                "Normally, the result is in the format and length of the ",
                "target.  However, when an overflow or underflow ",
                "exception occurs and if the exception is enabled, the ",
                "operation is completed by producing a wrapped ",
                "rounded result in the same format and length as the ",
                "source but rounded to the target-format precision.",
                "drdpq[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                "The DFP data-type conversion instructions are used to ",
                "convert data type between DFP and fixed.",
                "The data-type conversion instructions consist of Con",
                "vert From Fixed and Convert To Fixed."
            ]
        },
        {
            "description": "DFP Round To DFP Short",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drsp",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "770"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP long operand in FRB is converted and ",
                "rounded to DFP short format. The DFP short value is ",
                "extended on the left with zeros to form a 64-bit entity ",
                "and placed into FRT. The sign of the result is the same ",
                "as the sign of the source operand. The ideal exponent ",
                "is the exponent of the source operand.",
                "If the operand in FRB is an SNaN, it is converted to an ",
                "SNaN in DFP short format and does not cause an ",
                "invalid-operation exception.",
                "Normally, the result is in the format and length of the ",
                "target.  However, when an overflow or underflow ",
                "exception occurs and if the exception is enabled, the ",
                "operation is completed by producing a wrapped ",
                "rounded result in the same format and length as the ",
                "source but rounded to the target-format precision. ",
                "drsp[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Round To FP Integer With Inexact",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drintx",
                    "operands": [
                        "R",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "99"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Round To FP Integer With Inexact Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drintxq",
                    "operands": [
                        "R",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "99"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRB[p] is rounded to a ",
                "floating-point integer and placed into FRT[p].  The sign ",
                "of the result is the same as the sign of the operand in ",
                "FRB[p].  The ideal exponent is the larger value of zero ",
                "and the exponent of the operand in FRB[p].",
                "The rounding mode used is specified by RMC.  When ",
                "the RMC-encoding-selection (R) bit is zero, RMC field ",
                "contains the primary encoding; when the bit is one, the ",
                "field contains the secondary encoding.",
                "In addition to coercion of the converted value to fit the ",
                "target format, the special rounding used by Round To ",
                "FP Integer also coerces the target exponent to the ",
                "ideal exponent. ",
                "When the operand in FRB[p] is a finite number and the ",
                "exponent is less than zero, the operand is rounded to ",
                "the result with an exponent of zero.  When the ",
                "exponent is greater than or equal to zero, the result is ",
                "set to the numerical value and the form of the operand ",
                "in FRB[p]. ",
                "When the result differs in value from the operand in ",
                "FRB[p], an inexact exception is recognized.  No ",
                "underflow exception is recognized by this operation, ",
                "regardless of the value of the operand in FRB[p]. ",
                "Figure93 summarizes the actions for Round To FP ",
                "Integer With Inexact.  The table does not include the ",
                "setting of FPRF.  FPRF is always set to the class and sign ",
                "of the result, except for an enabled invalid-operation, in ",
                "which case the field remains unchanged. ",
                "drintx[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Round To FP Integer Without Inexact",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drintn",
                    "operands": [
                        "R",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "227"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Round To FP Integer Without Inexact Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "drintnq",
                    "operands": [
                        "R",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "227"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "This operation is the same as the Round To FP Integer ",
                "With Inexact operation, except that this operation does ",
                "not recognize an inexact exception.",
                "Figure94 summarizes the actions for Round To FP ",
                "Integer Without Inexact.  The table does not include ",
                "the setting of FPRF.  FPRF is always set to the class and ",
                "sign of the result, except for an enabled ",
                "invalid-operation, in which case the field remains ",
                "unchanged.",
                "drintn[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "DFP Shift Significand Left Immediate",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dscli",
                    "operands": [
                        "FRT",
                        "FRA",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "66"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Shift Significand Left Immediate Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dscliq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "66"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The significand of the DFP operand in FRA[p] is shifted ",
                "left SH digits. For a NaN or infinity, all significand digits ",
                "are in the trailing significand field. SH is a 6-bit ",
                "unsigned binary integer. Digits shifted out of the ",
                "leftmost digit are lost. Zeros are supplied to the ",
                "vacated positions on the right. The result is placed into ",
                "FRT[p]. The sign of the result is the same as the sign ",
                "of the source operand in FRA[p].",
                "If the source operand in FRA[p] is a finite number, the ",
                "exponent of the result is the same as the exponent of ",
                "the source operand. ",
                "For an Infinity, QNaN or SNaN result, the target ",
                "format\u2019s N-bit combination field is set as follows.",
                "dscli[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Shift Significand Right Immediate",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dscri",
                    "operands": [
                        "FRT",
                        "FRA",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "98"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Shift Significand Right Immediate Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dscriq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "98"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The significand of the DFP operand in FRA[p] is shifted ",
                "right SH digits. For a NaN or infinity, all significand ",
                "digits are in the trailing significand field. SH is a 6-bit ",
                "unsigned binary integer. Digits shifted out of the units ",
                "digit are lost. Zeros are supplied to the vacated ",
                "positions on the left. The result is placed into FRT[p]. ",
                "The sign of the result is the same as the sign of the ",
                "source operand in FRA[p].",
                "If the source operand in FRA[p] is a finite number, the ",
                "exponent of the result is the same as the exponent of ",
                "the source operand. ",
                "For an Infinity, QNaN or SNaN result, the target ",
                "format\u2019s N-bit combination field is set as follows.",
                "dscri[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Subtract",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "514"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Subtract Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dsubq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "514"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The DFP operand in FRB[p] is subtracted from the DFP ",
                "operand in FRA[p].",
                "The result is rounded to the target-format precision ",
                "under control of DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the smaller exponent of the two ",
                "source operands. ",
                "The execution of Subtract is identical to that of Add, ",
                "except that the operand in FRB participates in the opera",
                "tion with its sign bit inverted.  See Figure80. The table ",
                "does not include the setting of FPRF. FPRF is always set ",
                "to the class and sign of the result, except for an ",
                "enabled invalid-operation exception, in which case the ",
                "field remains unchanged.",
                "dsub[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "DFP Test Data Class",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstdc",
                    "operands": [
                        "BF",
                        "FRA",
                        "DCM"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "DCM",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "194"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Test Data Class Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstdcq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "DCM"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "DCM",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "194"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the DCM (Data Class Mask) field specify one or ",
                "more of the 6 possible data classes, where each bit ",
                "corresponds to a specific data class.",
                "CR field BF and FPCC are set to indicate the sign of the ",
                "DFP operand in FRA[p] and whether the data class of ",
                "the DFP operand in FRA[p] matches any of the data ",
                "classes specified by DCM.",
                "dtstdc[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Test Data Group",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstdg",
                    "operands": [
                        "BF",
                        "FRA",
                        "DGM"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "DGM",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "226"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Test Data Group Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstdgq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "DGM"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "DGM",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "226"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the DGM (Data Group Mask) field specify one or ",
                "more of the 6 possible data groups, where each bit ",
                "corresponds to a specific data group.",
                "The term extreme exponent means either the ",
                "maximum exponent, X<sub>max</sub>, or the minimum exponent, ",
                "X<sub>min</sub>. ",
                "CR field BF and FPCC are set to indicate the sign of the ",
                "DFP operand in FRA[p] and whether the data group of ",
                "the DFP operand in FRA[p] matches any of the data ",
                "groups specified by DGM.",
                "dtstdg[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Test Exponent",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstex",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "162"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Test Exponent Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstexq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "FRBp"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "162"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The exponent value (Ea) of the DFP operand in FRA[p] ",
                "is compared to the exponent value (Eb) of the DFP ",
                "operand in FRB[p].  The result of the compare is placed ",
                "into CR field BF and the FPCC<sub>.</sub>",
                "The codes in the CR field BF and FPCC are defined for ",
                "the DFP Test Exponent operations as follows. "
            ]
        },
        {
            "description": "DFP Test Significance",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstsf",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "674"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Test Significance Immediate",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstsfi",
                    "operands": [
                        "BF",
                        "UIM",
                        "FRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "6"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "675"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "DFP Test Significance Immediate Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstsfiq",
                    "operands": [
                        "BF",
                        "UIM",
                        "FRBp"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "6"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "675"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the value UIM specify the reference significance.",
                "For dtstsfi, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRB].",
                "For dtstsfiq, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRBp:FRBp+1].",
                "For this instruction, the number of significant digits of ",
                "the value 0 is considered to be zero.",
                "NSDb is compared to UIM. The result of the compare is ",
                "placed into CR field BF and the FPCC as follows. ",
                "dtstsfi[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "DFP Test Significance Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "dtstsfq",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRBp"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "674"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let k be the contents of bits 58:63 of FPR[FRA] that ",
                "specifies the reference significance.",
                "For dtstsf, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRB].",
                "For dtstsfq, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRBp:FRBp+1].",
                "For this instruction, the number of significant digits of ",
                "the value 0 is considered to be zero.",
                "NSDb is compared to k. The result of the compare is ",
                "placed into CR field BF and the FPCC as follows. ",
                "dtstsf[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "Data Cache Block Flush",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "dcbf",
                    "operands": [
                        "RA",
                        "RB",
                        "L"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "L",
                    "size": "3"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "86"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "For the L operand, the values 2, 5, and 7 are reserved. ",
                "The results of executing a dcbf instruction with L=2, 5, ",
                "or 7 are boundedly undefined.",
                "The function of this instruction is independent of ",
                "whether the block containing the byte addressed by EA ",
                "is in storage that is Write Through Required or Caching ",
                "Inhibited. ",
                "This instruction is treated as a Load (see Section 4.3), ",
                "except that reference and change recording need not ",
                "be done.",
                "Extended mnemonics are provided for the Data Cache ",
                "Block Flush instruction so that it can be coded with the ",
                "L value as part of the mnemonic rather than as a ",
                "numeric operand. These are shown as examples with ",
                "the instruction. See Appendix A.\u201cAssembler Extended ",
                "Mnemonics\u201d on page1121. The extended mnemonics ",
                "are shown below.",
                "Except in the dcbf instruction description in this sec",
                "tion, references to \u201cdcbf\u201d in Books I-III imply L=0 ",
                "unless otherwise stated or obvious from context; ",
                "\u201cdcbfl\u201d is used for L=1, \u201cdcbflp\u201d is used for L=3, \u201cdcb",
                "fps\u201d is used for L=4, and \u201cdcbstps\u201d is used for L=6.  ",
                "  ",
                " ",
                "The Data Stream Touch (dst), Data Stream Touch for ",
                "Store (dstst), and Data Stream Stop (dss) instructions ",
                "(primary opcode 31, extended opcodes 342, 374, and ",
                "822 respectively), which were proposed for addition to ",
                "the Power ISA and were implemented by some pro",
                "cessors, must be treated as no-ops (rather than as ille",
                "gal instructions).",
                "",
                "",
                "",
                "The treatment of these instructions is independent of ",
                "whether other Vector instructions are available (i.e., is ",
                "independent of the contents of MSR<sub>VEC</sub> (see Book III).",
                " "
            ]
        },
        {
            "description": "Data Cache Block Store",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "dcbst",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "54"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "If the block containing the byte addressed by EA is in ",
                "storage that is Memory Coherence Required and a ",
                "block containing the byte addressed by EA is in the ",
                "data cache of any processor and any locations in the ",
                "block are considered to be modified there, those loca",
                "tions are written to main storage, additional locations in ",
                "the block may be written to main storage, and the block ",
                "ceases to be considered to be modified in that data ",
                "cache.",
                "If the block containing the byte addressed by EA is in ",
                "storage that is not Memory Coherence Required and ",
                "the block is in the data cache of this processor and any ",
                "locations in the block are considered to be modified ",
                "there, those locations are written to main storage, addi",
                "tional locations in the block may be written to main stor",
                "age, and the block ceases to be considered to be ",
                "modified in that data cache.",
                "The function of this instruction is independent of ",
                "whether the block containing the byte addressed by EA ",
                "is in storage that is Write Through Required or Caching ",
                "Inhibited.",
                "This instruction is treated as a Load (see Section 4.3), ",
                "except that reference and change recording need not ",
                "be done.",
                "  ",
                ""
            ]
        },
        {
            "description": "Data Cache Block Touch",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "dcbt",
                    "operands": [
                        "RA",
                        "RB",
                        "TH"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "TH",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "278"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The dcbt instruction provides a hint that describes a ",
                "block or data stream to which the program may perform ",
                "a Load access. The instruction is also used to indicate ",
                "imminent access or end of access to described load ",
                "and store data streams. A hint that the program will ",
                "probably soon load from a given storage location is ",
                "ignored if the location is Caching Inhibited or Guarded.",
                "The only operation that is \u201ccaused\u201d by the dcbt instruc",
                "tion is the providing of the hint. The actions (if any) ",
                "taken by the processor in response to the hint are not ",
                "considered to be \u201ccaused by\u201d or \u201cassociated with\u201d the ",
                "dcbt instruction (e.g., dcbt is considered not to cause ",
                "any data accesses). No means are provided by which ",
                "software can synchronize these actions with the execu",
                "tion of the instruction stream. For example, these ",
                "actions are not ordered by memory barriers.",
                "The dcbt instruction may complete before the opera",
                "tion it causes has been performed.",
                "The nature of the hint depends, in part, on the value of ",
                "the TH field, as specified at the beginning of this sec",
                "tion. If TH\u00b90b01010 and TH\u00b90b01011, this instruction ",
                "is treated as a Load (see Section 4.3), except that the ",
                "system data storage error handler is not invoked, and ",
                "reference and change recording need not be done.",
                "Special Registers Altered:",
                "Extended mnemonics are provided for the Data Cache ",
                "Block Touch instruction so that it can be coded with the ",
                "TH value as the last operand for all categories, and so ",
                "that the transient hint can be specified without coding ",
                "the TH field explicitly. ",
                "  ",
                " "
            ]
        },
        {
            "description": "Data Cache Block Touch for Store",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "dcbtst",
                    "operands": [
                        "RA",
                        "RB",
                        "TH"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "TH",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "246"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The dcbtst instruction provides a hint that describes a ",
                "block or data stream to which the program may perform ",
                "a Store access, or indicates the expected use thereof. ",
                "A hint that the program will soon store to a given stor",
                "age location is ignored if the location is Caching Inhib",
                "ited or Guarded.",
                "The only operation that is \u201ccaused by\u201d the dcbtst ",
                "instruction is the providing of the hint. The actions (if ",
                "any) taken by the processor in response to the hint are ",
                "not considered to be \u201ccaused by\u201d or \u201cassociated with\u201d ",
                "the dcbtst instruction (e.g., dcbtst is considered not to ",
                "cause any data accesses). No means are provided by ",
                "which software can synchronize these actions with the ",
                "execution of the instruction stream. For example, these ",
                "actions are not ordered by memory barriers.",
                "The dcbtst instruction may complete before the opera",
                "tion it causes has been performed.",
                "The nature of the hint depends, in part, on the value of ",
                "the TH field, as specified at the beginning of this sec",
                "tion. If TH\u00b90b01010 and TH\u00b90b01011, this instruction ",
                "is treated as a Store (see Section 4.3), except that the ",
                "system data storage error handler is not invoked, refer",
                "ence recording need not be done, and change record",
                "ing is not done.",
                "Extended mnemonics are provided for the Data Cache ",
                "Block Touch for Store instruction so that it can be ",
                "coded with the TH value as the last operand for all cat",
                "egories, and so that the transient hint can be specified ",
                "without coding the TH field explicitly.",
                " ",
                " ",
                " ",
                "  ",
                ""
            ]
        },
        {
            "description": "Data Cache Block set to Zero",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "dcbz",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "1014"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := block size (bytes)",
                "m := log<sub>2</sub>(n)",
                "ea := EA<sub>0:63-m</sub> || <sup>m</sup>0",
                "MEM(ea, n) := <sup>n</sup>0x00",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "All bytes in the block containing the byte addressed by ",
                "EA are set to zero.",
                "This instruction is treated as a Store (see Section 4.3).",
                " ",
                "  ",
                ""
            ]
        },
        {
            "description": "Decimal Add Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdadd.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := bcd_ADD(VSR[VRA+32],VSR[VRB+32],PS)",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := ox_flag | inv_flag"
            ],
            "body": [
                "Let src1 be the decimal integer value in VSR[VRA+32].",
                "src1 is added to src2.",
                "If the unbounded result is equal to zero, do the ",
                "following.",
                "If the unbounded result is greater than zero, do the ",
                "following.",
                "If the unbounded result is less than zero, do the ",
                "following.",
                "The low-order 31 digits of the magnitude of the result ",
                "are placed in bits 0:123 of VSR[VRT+32]. ",
                "The sign code is placed in bits 124:127 of VSR[VRT+32].",
                "If either src1 or src2 is an invalid encoding of a 31-digit ",
                "signed decimal value, the result is undefined and CR ",
                "field 6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert From National",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdcfn.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "7"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "385"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src_sign := (VSR[VRB+32].hword[7] = 0x002D)",
                "eq_flag  := 1",
                "/* check for valid sign */",
                "inv_flag := (VSR[VRB+32].hword[7] != 0x002B) &amp;",
                "          (VSR[VRB+32].hword[7] != 0x002D)",
                "",
                "do i = 0 to 6",
                "   eq_flag  := eq_flag  &amp; (VSR[VRB+32].hword[i] = 0x0030)",
                "   /* check for valid digit */",
                "   inv_flag := inv_flag | (VSR[VRB+32].hword[i] &lt; 0x0030)",
                "                      | (VSR[VRB+32].hword[i] &gt; 0x0039)",
                "end",
                "",
                "lt_flag := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "do i = 0 to 23",
                "   result.nibble[i] := 0x0",
                "end",
                "do i = 0 to 6",
                "   result.nibble[i+24] := VSR[VRB+32].hword[i].nibble[3]",
                "end",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag"
            ],
            "body": [
                "Let src be the national decimal value in VSR[VRB+32]. ",
                "src is placed in VSR[VRT+32] in packed decimal format.",
                "A valid encoding of a national decimal value requires ",
                "the following.",
                "National decimal values having a sign code of 0x002B ",
                "are interpreted as positive values.",
                "National decimal values having a sign code of 0x002D ",
                "are interpreted as negative values.",
                "For each integer value i from 0 to 23, do the following.",
                "For each integer value i from 0 to 6, do the following.",
                "For PS=0, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xC for positive values ",
                "and to 0xD for negative values.",
                "For PS=1, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xF for positive values ",
                "and to 0xD for negative values.",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a national decimal ",
                "value, the contents of VSR[VRT+32] are undefined and ",
                "CR field 6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert From Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdcfsq.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "385"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "ox_flag := (EXTS(VSR[VRB+32]) &gt;  1031-1) |",
                "         (EXTS(VSR[VRB+32]) &lt; -1031-1)",
                "lt_flag := (EXTS(VSR[VRB+32]) &lt;  0)",
                "gt_flag := (EXTS(VSR[VRB+32]) &gt;  0)",
                "eq_flag := (EXTS(VSR[VRB+32]) =  0)",
                "",
                "if ox_flag=0 then",
                "   result := bcd_CONVERT_FROM_SI128(EXTS(VSR[VRB+32]),PS)",
                "else",
                "   result := 0xUUUU_UUUU_UUUU_UUUU_UUUU_UUUU_UUUU_UUUU",
                "",
                "VSR[VRT+32] := ox_flag ? undefined : result",
                "",
                "CR.bit[56] := lt_flag",
                "CR.bit[57] := gt_flag",
                "CR.bit[58] := eq_flag",
                "CR.bit[59] := ox_flag"
            ],
            "body": [
                "Let src be the signed integer value in VSR[VRB+32]. ",
                "src is placed into VSR[VRT+32] in signed packed ",
                "decimal format.",
                "For PS=0, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xC for values greater ",
                "than or equal to 0 and to 0xD for values less than 0.",
                "For PS=1, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xF for values greater ",
                "than or equal to 0 and to 0xD for values less than 0.",
                "If the signed integer value in VSR[VRB+32] is greater ",
                "than 1031-1 or less than -1031-1, the value is too large ",
                "to be represented in packed decimal format, and the ",
                "contents of VSR[VRT+32] are undefined.",
                "CR field 6 is set to reflect src compared to zero and ",
                "whether or not src is too large in magnitude to be ",
                "represented in packed decimal format."
            ]
        },
        {
            "description": "Decimal Convert From Zoned",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdcfz.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "6"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "385"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "/* check for valid sign */",
                "inv_flag := ((VSR[VRB+32].byte[15].nibble[0] &lt; 0xA) &amp; (PS=1)) |",
                "           (VSR[VRB+32].byte[15].nibble[1] &gt; 0x9)",
                "",
                "/* check for valid digits */",
                "MIN := (PS=0) ? 0x30 : 0xF0",
                "MAX := (PS=0) ? 0x39 : 0xF9",
                "do i = 0 to 14",
                "   inv_flag := inv_flag | (VSR[VRB+32].byte[i] &lt; MIN)",
                "                      | (VSR[VRB+32].byte[i] &gt; MAX)",
                "end",
                "",
                "if PS=0 then",
                "   src_sign :=  VSR[VRB+32].nibble[30].bit[1]",
                "else",
                "   src_sign := (VSR[VRB+32].nibble[30] = 0b1011) |",
                "             (VSR[VRB+32].nibble[30] = 0b1101)",
                "",
                "eq_flag  := 1",
                "",
                "do i = 0 to 14",
                "   result.nibble[i] := 0x0",
                "end",
                "do i = 0 to 15",
                "   result.nibble[i+15] := VSR[VRB+32].byte[i].nibble[1]",
                "   eq_flag := eq_flag &amp; (VSR[VRB+32].byte[i].nibble[1]=0x0)",
                "end",
                "",
                "lt_flag := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "result.nibble[31] := (src_sign=0) ? 0xC : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag"
            ],
            "body": [
                "Let src be the zoned decimal value in VSR[VRB+32]. ",
                "src is placed in VSR[VRT+32] in packed decimal format.",
                "When PS=0, do the following.",
                "When PS=1, do the following.",
                "Positive packed decimal results are returned with a ",
                "sign code of 0xC.",
                "Negative packed decimal results are returned with a ",
                "sign code of 0xD.",
                "For each integer value i from 0 to 14,",
                "For each integer value i from 0 to 15,",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a zoned decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert To National",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdctn.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "385"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "ox_flag := 0",
                "do i = 0 to 23",
                "   ox_flag := ox_flag | (VSR[VRB+32].nibble[i] != 0x0)",
                "end",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "src.sign := (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "do i = 0 to 6",
                "   result.hword[i].nibble[0:2] := 0x003",
                "   result.hword[i].nibble[3]   := VSR[VRB+32].nibble[i+24]",
                "end",
                "",
                "result.hword[7] := (src_sign=1) ? 0x002D : 0x002B",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "src is placed into VSR[VRT+32] in national decimal ",
                "format.",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "Values greater in magnitude than 107-1 are too large ",
                "to be represented in national decimal format.",
                "For each integer value i from 0 to 6, do the following.",
                "The contents of halfword element 7 (i.e., sign code) of ",
                "VSR[VRT+32] are set to 0x002B for positive values and to ",
                "0x002D for negative values.",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not src is too large to be ",
                "represented in national decimal format.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert To Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdctsq.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "385"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "src_sign    := (VSR[VRB+32].nibble[31] = 0xB) |",
                "             (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag     := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag     := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag     := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "result      := si128_CONVERT_FROM_BCD(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "src is placed into VSR[VRT+32] in signed integer format.",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert To Zoned",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdctz.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "385"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "ox_flag := 0",
                "do i = 0 to 15",
                "   ox_flag := ox_flag | (VSR[VRB+32].nibble[i] != 0x0)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "do i = 0 to 14",
                "   result.byte[i].nibble[0] := (PS=0) ? 0x3 : 0xF",
                "   result.byte[i].nibble[1] := VSR[VRB+32].nibble[i+15]",
                "end",
                "if src.sign=0 then",
                "   result.byte[15].nibble[0] := (PS=0) ? 0x3 : 0xC",
                "else",
                "   result.byte[15].nibble[0] := (PS=0) ? 0x7 : 0xD",
                "",
                "result.byte[15].nibble[1] := VSR[VRB+32].nibble[30]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "src is placed into  VSR[VRT+32] in zoned decimal ",
                "format.",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "Values greater in magnitude than 1016-1 are too large ",
                "to be represented in zoned decimal format.",
                "For PS=0, do the following.",
                "For PS=1, do the following.",
                "For each integer value i from 0 to 15, do the following.",
                "The result is placed into VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not src is too large to be ",
                "represented in zoned decimal format.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Copy Sign",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdcpsgn.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "833"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRA+32].nibble[31] &lt; 0xA) |",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRA+32].nibble[i] &gt; 0x9)",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRA+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag  := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "result.nibble[0:30] := VSR[VRA+32].nibble[0:30]",
                "result.nibble[31]   := VSR[VRB+32].nibble[31]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "The decimal value in VSR[VRA+32] is placed into ",
                "VSR[VRT+32] with the sign code of the decimal value in ",
                "VSR[VRB+32].",
                "CR field 6 is set to reflect the result compared to zero.",
                "If either the decimal value in VSR[VRA+32] or the ",
                "decimal value in VSR[VRB+32] is an invalid encoding, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Set Sign",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdsetsgn.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "31"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "385"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag  := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "result.nibble[0:30] := VSR[VRB+32].nibble[0:30]",
                "result.nibble[31]   := (src_sign=0) ? ((PS=0) ? 0xC:0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "If src is negative, src is placed into VSR[VRT+32] with ",
                "the sign code set to 0xD.",
                "If src is positive and PS=0, src is placed into ",
                "VSR[VRT+32] with the sign code set to 0xC.",
                "If src is positive and PS=1, src is placed into ",
                "VSR[VRT+32] with the sign code set to 0xF.",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Shift",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcds.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "193"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag  := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "if n &gt; 0 then do     // shift left",
                "   shcnt               := (n&lt;32) ? n : 31",
                "   src.nibble[0:30]    := VSR[VRB+32].nibble[0:30]",
                "   src.nibble[31:61]   := 0",
                "   result.nibble[0:30] := src.data.nibble[shcnt:shcnt+30]",
                "   ox_flag := (shcnt &gt; 0) &amp; (src.nibble[0:shcnt-1] != 0)",
                "end",
                "else do              // shift right",
                "   shcnt               := ((~n+1)&lt;32) ? (~n+1) : 31",
                "   src.nibble[0:30]    := 0",
                "   src.nibble[31:61]   := VSR[VRB+32].nibble[0:30]",
                "   result.nibble[0:30] := src.nibble[31-shcnt:61-shcnt]",
                "   ox_flag := 0b0",
                "end",
                "",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let n be the signed integer value in byte element 7 of ",
                "VSR[VRA+32].",
                "Let src be the signed packed decimal value in ",
                "VSR[VRB+32].",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal source operands with sign codes of ",
                "0xA, 0xC, 0xE, or 0xF are interpreted as positive values.",
                "Packed decimal source operands with sign codes of ",
                "0xB or 0xD are interpreted as negative values.",
                "If n is greater than zero, src is shifted left n digits. ",
                "Zeros are supplied to vacated digits on the right. If any ",
                "non-zero digits are shifted out, an overflow occurs.",
                "If n is less than zero, src is shifted right -n digits. Zeros ",
                "are supplied to vacated digits on the left.",
                "If the packed decimal value in VSR[VRB+32] is negative, ",
                "the sign code of the result is set to 0b1101.",
                "If the packed decimal value in VSR[VRB+32] is positive, ",
                "the sign code of the result is set to 0b1100 if PS=0 and is ",
                "set to 0b1111 if PS=1.",
                "The shifted result is placed into VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were shifted ",
                "out when the shift count is positive (i.e., left shift ",
                "operation).",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Shift & Round",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdsr.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "449"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) &amp; (src_sign=1)",
                "gt_flag  := (eq_flag=0) &amp; (src_sign=0)",
                "",
                "if n &gt; 0 then do     // shift left",
                "   shcnt := Clamp(n, 0, 31)",
                "   src.nibble[0:30]    := VSR[VRB+32].nibble[0:30]",
                "   src.nibble[31:61]   := 0",
                "   result.nibble[0:30] := src.nibble[shcnt:shcnt+30]",
                "   ox_flag := (shcnt &gt; 0) &amp; (src.nibble[0:shcnt-1] != 0)",
                "   g_flag  := 0",
                "end",
                "else do              // shift right",
                "   shcnt := Clamp(~n + 1, 0, 31)",
                "   src.nibble[0:30]    := 0",
                "   src.nibble[31:61]   := VSR[VRB+32].nibble[0:30]",
                "   result.nibble[0:30] := src.nibble[31-shcnt:61-shcnt]",
                "   ox_flag := 0",
                "   g_flag  := (shcnt &gt; 0) &amp; ",
                "              (EXTZ(src.nibble[62-shcnt]) &gt;= 5)",
                "end",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "result := (g_flag=0) ? result : bcd_INCREMENT(result)",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let n be the signed integer value in byte element 7 of ",
                "VSR[VRA+32].",
                "Let src be the signed packed decimal value in ",
                "VSR[VRB+32].",
                "A valid encoding of a signed packed decimal source ",
                "operand requires the following.",
                "Packed decimal source operands with sign codes of ",
                "0xA, 0xC, 0xE, or 0xF are interpreted as positive values.",
                "Packed decimal source operands with sign codes of ",
                "0xB or 0xD are interpreted as negative values.",
                "If n is greater than zero, src is shifted left n digits. ",
                "Zeros are supplied to vacated digits on the right. If any ",
                "non-zero digits are shifted out, an overflow occurs.",
                "If n is less than zero, src is shifted right -n digits. Zeros ",
                "are supplied to vacated digits on the left. If the value of ",
                "the last nibble shifted out on the right was greater than ",
                "or equal to 5, the magnitude of the result is ",
                "incremented by 1.",
                "If src is negative, the sign code of the result is set to ",
                "0b1101.",
                "If src is positive, the sign code of the result is set to ",
                "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
                "The shifted and rounded result is placed into ",
                "VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were shifted ",
                "out when the shift count is positive (i.e., left shift ",
                "operation).",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Subtract Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdsub.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "65"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := bcd_SUBTRACT(VSR[VRA+32],VSR[VRB+32],PS)",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := ox_flag | inv_flag"
            ],
            "body": [
                "Let src1 be the decimal integer value in VSR[VRA+32].",
                "src1 is subtracted by src2.",
                "If the unbounded result is equal to zero, do the ",
                "following.",
                "If the unbounded result is greater than zero, do the ",
                "following.",
                "If the unbounded result is less than zero, do the ",
                "following.",
                "The low-order 31 digits of the magnitude of the result ",
                "are placed in bits 0:123 of VSR[VRT+32]. ",
                "The sign code is placed in bits 124:127 of VSR[VRT+32].",
                "If either src1 or src2 is an invalid encoding of a 31-digit ",
                "signed decimal value, the result is undefined and CR ",
                "field 6 is set to 0b0001.",
                "  ",
                "  ",
                "  "
            ]
        },
        {
            "description": "Decimal Truncate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdtrunc.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "257"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] &lt; 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "length  := VSR[VRA+32].bit[48:63]",
                "",
                "ox_flag := 0",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  :=  src_sign &amp; ~eq_flag",
                "gt_flag  := ~src_sign &amp; ~eq_flag",
                "",
                "if length &lt; 31 then do",
                "   do i = 0 to 30-length",
                "      if VSR[VRB+32].nibble[i]!=0b0000 then ox_flag := 1",
                "      result.nibble[i] := 0b0000",
                "   end",
                "   if length &gt; 0 then do",
                "      do i = 31-length to 30",
                "         result.nibble[i] := VSR[VRB+32].nibble[i]",
                "      end",
                "   end",
                "end",
                "else result.nibble[0:30] := VSR[VRB+32].nibble[0:30]",
                "",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let length be the integer value in bits 48:63 of ",
                "VSR[VRA+32].",
                "Let src be the signed decimal value in VSR[VRB+32].",
                "A valid encoding of a packed decimal source operand ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "If src is negative, the sign code of the result is set to ",
                "0b1101.",
                "If src is positive, the sign code of the result is set to ",
                "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
                "src is copied into VSR[VRT+32] with the leftmost ",
                "31-length digits each set to 0b0000. If any of the ",
                "leftmost 31-length digits of the signed decimal value in ",
                "VSR[VRB+32] are non-zero, an overflow occurs.",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were ",
                "truncated.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Unsigned Shift",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdus.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "129"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := 0",
                "do i = 0 to 31",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:31] = 0)",
                "gt_flag  := (eq_flag=0)",
                "",
                "if n &gt; 0 then do     // shift left",
                "   shcnt := (n&lt;33) ? n : 32",
                "   src.nibble[0:31] := VSR[VRB+32]",
                "   src.nibble[32:63] := 0",
                "   result := src.nibble[shcnt:shcnt+31]",
                "   ox_flag := (shcnt &gt; 0) &amp; (src.nibble[0:shcnt-1] != 0)",
                "end",
                "else do              // shift right",
                "   shcnt := ((~n+1)&lt;33) ? (~n+1) : 32",
                "   src.nibble[0:31]  := 0",
                "   src.nibble[32:63] := VSR[VRB+32]",
                "   result := src.nibble[32-shcnt:63-shcnt]",
                "   ox_flag := 0",
                "end",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := 0b0",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let n be the signed integer value in byte element 7 of ",
                "VSR[VRA+32].",
                "Let src be the unsigned packed decimal value in ",
                "VSR[VRB+32].",
                "A valid encoding of an unsigned packed decimal value ",
                "requires the contents of each nibble 0-31 must be a ",
                "value in the range 0x0 to 0x9.",
                "If n is greater than zero, src is shifted left n digits. ",
                "Zeros are supplied to vacated digits on the right. If any ",
                "non-zero digits are shifted out, an overflow occurs.",
                "If n is less than zero, src is shifted right -n digits. Zeros ",
                "are supplied to vacated digits on the left.",
                "The shifted result is placed into VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were shifted ",
                "out when the shift count is positive (i.e., left shift ",
                "operation).",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Unsigned Truncate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "bcdutrunc.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "321"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := 0",
                "do i = 0 to 31",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] &gt; 0x9)",
                "end",
                "",
                "length := VSR[VRA+32].bit[48:63]",
                "",
                "ox_flag := 0",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:31]  = 0)",
                "gt_flag  := (VSR[VRB+32].nibble[0:31] != 0)",
                "",
                "if length &lt; 32 then do",
                "   do i = 0 to 31-length",
                "      if VSR[VRB+32].nibble[i]!=0b0000 then ox_flag := 1",
                "      result.nibble[i] := 0b0000",
                "   end",
                "   if length &gt; 0 then do",
                "      do i = 32-length to 31",
                "         result.nibble[i] := VSR[VRB+32].nibble[i]",
                "      end",
                "   end",
                "end",
                "else result := VSR[VRB+32]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := 0b0",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let length be the integer value in bits 48:63 of ",
                "VSR[VRA+32].",
                "Let src be the unsigned decimal value in VSR[VRB+32].",
                "A valid encoding of a packed decimal source operand ",
                "requires the contents of each nibble 0-31 must be a ",
                "value in the range 0x0 to 0x9.",
                "src is copied into VSR[VRT+32] with the leftmost ",
                "32-length digits each set to 0b0000. If any of the ",
                "leftmost 32-length digits of the signed decimal value in ",
                "VSR[VRB+32] are non-zero, an overflow occurs.",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were ",
                "truncated.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Deliver A Random Number",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "darn",
                    "operands": [
                        "RT",
                        "L"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "L",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "755"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT := random(L)",
                " ",
                " "
            ],
            "body": [
                "A random number is placed into register RT in a format ",
                "selected by L as shown in the following table.  The ",
                "value 0xFFFFFFFF_FFFFFFFF indicates an error condition.  ",
                "For L=0, the random number range is 0:0xFFFFFFFF.  For ",
                "L=1 and L=2, the random number range is ",
                "0:0xFFFFFFFF_FFFFFFFE.",
                " ",
                "",
                "",
                "",
                " ",
                ""
            ]
        },
        {
            "description": "Divide Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divd.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "489"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend \u00b8 divisor",
                "   0x8000_0000_0000_0000 \u00b8 -1",
                "      &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit quotient is placed into register RT. The ",
                "remainder is not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 \u00a3 r &lt; |divisor| if the dividend is nonnegative, ",
                "and -|divisor| &lt; r \u00a3 0 if the dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1.",
                "  "
            ]
        },
        {
            "description": "Divide Doubleword Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divde",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divde.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "425"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:127</sub> := (RA) || <sup>64</sup>0",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend \u00b8 divisor",
                "    &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 128-bit dividend is (RA) || 640. The 64-bit divisor is ",
                "(RB). If the quotient can be represented in 64 bits, it is ",
                "placed into register RT. The remainder is not supplied as ",
                "a result. ",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 \u00a3 r &lt; |divisor| if the dividend is nonnega",
                "tive, and -|divisor| &lt; r \u00a3 0 if the dividend is negative.",
                "If the quotient cannot be represented in 64 bits, or if an ",
                "attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field ",
                "0. In these cases, if OE=1 then OV and ",
                "OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Doubleword Extended Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divdeu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeuo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeuo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "393"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:127</sub> := (RA) || <sup>64</sup>0",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend \u00b8 divisor",
                "    &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 128-bit dividend is (RA) || 640. The 64-bit divisor is ",
                "(RB). If the quotient can be represented in 64 bits, it is ",
                "placed into register RT. The remainder is not supplied as ",
                "a result. ",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero. The quotient is the unique unsigned integer ",
                "that satisfies",
                "where 0 \u00a3 r &lt; divisor.",
                "If (RA) \u00b3 (RB), or if an attempt is made to perform the ",
                "division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In these cases, if OE=1 then OV and OV32 ",
                "are set to 1.",
                "  "
            ]
        },
        {
            "description": "Divide Doubleword Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divdu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divduo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divduo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "457"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend \u00b8 divisor",
                "    &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit quotient is placed into register RT. The ",
                "remainder is not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero. The quotient is the unique unsigned integer ",
                "that satisfies",
                "where 0 \u00a3 r &lt; divisor.",
                "If an attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In this case, if OE=1 then OV and OV32 ",
                "are set to 1."
            ]
        },
        {
            "description": "Divide Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divw.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "491"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend \u00b8 divisor",
                "RT<sub>0:31</sub> := undefined",
                "   0x8000_0000 \u00b8 -1",
                "   &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit quotient is placed into RT<sub>32:63</sub>. The ",
                "contents of RT<sub>0:31</sub> are undefined. The remainder is not ",
                "supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 \u00a3 r &lt; |divisor| if the dividend is nonnega",
                "tive, and -|divisor| &lt; r \u00a3 0 if the dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined as are ",
                "(ifRc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then OV ",
                "and OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Word Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divwe",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divwe.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "427"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)<sub>32:63</sub> || <sup>32</sup>0",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend \u00b8 divisor",
                "RT<sub>0:31</sub> := undefined",
                "    &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 64-bit dividend is (RA)<sub>32:63 </sub><sub>|| </sub><sub>32</sub><sub>0</sub>. The 32-bit divi",
                "sor is (RB)<sub>32:63</sub>. If the quotient can be represented in 32 ",
                "bits, it is placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> are ",
                "undefined. The remainder is not supplied as a result. ",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 \u00a3 r &lt; |divisor| if the dividend is nonnega",
                "tive, and -|divisor| &lt; r \u00a3 0 if the dividend is negative.",
                "If the quotient cannot be represented in 32 bits, or if an ",
                "attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field ",
                "0. In these cases, if OE=1 then OV and ",
                "OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Word Extended Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divweu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweuo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweuo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "395"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)<sub>32:63</sub> || <sup>32</sup>0",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend \u00b8 divisor",
                "RT<sub>0:31</sub> := undefined",
                "    &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 64-bit dividend is (RA)<sub>32:63 </sub><sub>|| </sub><sub>32</sub><sub>0</sub>. The 32-bit divi",
                "sor is (RB)<sub>32:63</sub>. If the quotient can be represented in 32 ",
                "bits, it is placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> are ",
                "undefined. The remainder is not supplied as a result. ",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero. The quotient is the unique unsigned inte",
                "ger that satisfies",
                "where 0 \u00a3 r &lt; divisor.",
                "If (RA) \u00b3 (RB), or if an attempt is made to perform the ",
                "division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In these cases, if OE=1 then OV and OV32 ",
                "are set to 1.",
                "Unsigned long division of a 64-bit dividend contained in ",
                "two 32-bit registers by a 32-bit divisor can be computed ",
                "as follows. The algorithm is shown first, followed by ",
                "Assembler code that implements the algorithm. The ",
                "dividend is Dh || Dl, the divisor is Dv, and the quotient ",
                "and remainder are Q and R respectively, where these ",
                "variables and all intermediate variables represent ",
                "unsigned 32-bit integers. It is assumed that Dv &gt; Dh, ",
                "and that assigning a value to an intermediate variable ",
                "assigns the low-order 32 bits of the value and ignores ",
                "any higher-order bits of the value. (In both the algorithm ",
                "and the Assembler code, \u201cr1\u201d and \u201cr2\u201d refer to \u201cremain",
                "der 1\u201d and \u201cremainder 2\u201d, rather than to GPRs 1 and 2.)",
                "Algorithm:",
                "Assembler Code:",
                "Notes:"
            ]
        },
        {
            "description": "Divide Word Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "divwu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwuo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwuo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "459"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend \u00b8 divisor",
                "RT<sub>0:31</sub> := undefined",
                "    &lt;anything&gt; \u00b8 0"
            ],
            "body": [
                "The 32 bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit quotient is placed into RT<sub>32:63</sub>. The ",
                "contents of RT<sub>0:31</sub> are undefined. The remainder is not ",
                "supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero. The quotient is the unique unsigned integer ",
                "that satisfies",
                "where 0 \u00a3 r &lt; divisor.",
                "If an attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In this case, if OE=1 then OV and OV32 ",
                "are set to 1."
            ]
        },
        {
            "description": "Enforce In-order Execution of I/O",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "eieio",
                    "operands": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "854"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The eieio instruction creates a memory barrier (see ",
                "Section1.7.1, \u201cStorage Access Ordering\u201d), which pro",
                "vides an ordering function for the storage accesses ",
                "caused by Load, Store, and dcbz instructions executed ",
                "by the processor executing the eieio instruction. These ",
                "storage accesses are divided into the two sets listed ",
                "below. The storage access caused by a dcbz instruc",
                "tion is ordered as a store.",
                "The operations caused by the stream variants of the ",
                "dcbt and dcbtst instructions (i.e., the providing of ",
                "hints) are ordered by eieio as a third set of operations, ",
                "the operations caused by tlbie and tlbsync instructions ",
                "(see Book III) are ordered by eieio as a fourth set of ",
                "operations, and the operations caused by slbieg or ",
                "slbiag and slbsync instructions (see Book III) are ",
                "ordered by eieio as a fifth set of operations. ",
                "Each of the five sets of storage accesses or operations ",
                "is ordered independently of the other four sets. The ",
                "ordering done by eieios memory barrier for the second ",
                "set is cumulative; the ordering done by eieios memory ",
                "barrier for the other four sets is not cumulative.",
                "The eieio instruction may complete before storage ",
                "accesses associated with instructions preceding the ",
                "eieio instruction have been performed. The eieio ",
                "instruction may complete before operations caused by ",
                "dcbt and dcbtst instructions preceding the eieio ",
                "instruction have been performed",
                "  ",
                "  ",
                "  "
            ]
        },
        {
            "description": "Equivalent ",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "eqv",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "eqv.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "284"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) == (RB)"
            ],
            "body": [
                "The contents of register RS are XORed with the con",
                "tents of register RB and the complemented result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "Extend Sign Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "extsb",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "extsb.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "954"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "s := (RS)<sub>56</sub>",
                "RA<sub>56:63</sub> := (RS)<sub>56:63</sub>",
                "RA<sub>0:55</sub> := <sup>56</sup>s"
            ],
            "body": [
                "(RS)<sub>56:63</sub> are placed into RA<sub>56:63</sub>. RA<sub>0:55</sub> are filled with a ",
                "copy of (RS)<sub>56</sub>."
            ]
        },
        {
            "description": "Extend Sign Halfword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "extsh",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "extsh.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "922"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "s := (RS)<sub>48</sub>",
                "RA<sub>48:63</sub> := (RS)<sub>48:63</sub>",
                "RA<sub>0:47</sub> := <sup>48</sup>s"
            ],
            "body": [
                "(RS)<sub>48:63</sub> are placed into RA<sub>48:63</sub>. RA<sub>0:47</sub> are filled with a ",
                "copy of (RS)<sub>48</sub>."
            ]
        },
        {
            "description": "Extend Sign Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "extsw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "extsw.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "986"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "s := (RS)<sub>32</sub>",
                "RA<sub>32:63</sub> := (RS)<sub>32:63</sub>",
                "RA<sub>0:31</sub> := <sup>32</sup>s"
            ],
            "body": [
                "(RS)<sub>32:63</sub> are placed into RA<sub>32:63</sub>. RA<sub>0:31</sub> are filled with a ",
                "copy of (RS)<sub>32</sub>."
            ]
        },
        {
            "description": "Extend Sign Word and Shift Left Immediate",
            "form": "XS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "extswsli",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "extswsli.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "445"
                },
                {
                    "name": "sh",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n  := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r  := ROTL64(EXTS64(RS<sub>32:63</sub>), n)",
                "m  := MASK(0, 63-n)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of the low order 32 bits of RS are ",
                "sign-extended to 64 bits and then shifted left SH bits. ",
                "Bits shifted out of bit 0 are lost. Zeros are supplied to ",
                "vacated bits on the right. The result is placed in ",
                "register RA."
            ]
        },
        {
            "description": "Floating Absolute Value",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fabs",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fabs.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "264"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of register FRB with bit 0 set to zero are ",
                "placed into register FRT."
            ]
        },
        {
            "description": "Floating Add",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fadd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "21"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Add Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fadds",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fadds.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "21"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRA is added to ",
                "the floating-point operand in register FRB.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Floating-point addition is based on exponent compari",
                "son and addition of the two significands. The expo",
                "nents of the two operands are compared, and the ",
                "significand accompanying the smaller exponent is ",
                "shifted right, with its exponent increased by one for ",
                "each bit shifted, until the two exponents are equal. The ",
                "two significands are then added or subtracted as ",
                "appropriate, depending on the signs of the operands, to ",
                "form an intermediate sum. All 53 bits of the significand ",
                "as well as all three guard bits (G, R, and X) enter into the ",
                "computation.",
                "If a carry occurs, the sum\u2019s significand is shifted right ",
                "one bit position and the exponent is increased by one.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Compare Ordered",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fcmpo",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "32"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if (FRA) is a NaN or",
                "   (FRB) is a NaN then c := 0b0001",
                "else if (FRA) &lt; (FRB) then c := 0b1000",
                "else if (FRA) &gt; (FRB) then c := 0b0100",
                "else                       c := 0b0010",
                "FPCC := c",
                "CR<sub>4</sub>*<sub>BF:4</sub>*<sub>BF+3</sub> := c",
                "if (FRA) is an SNaN or",
                "   (FRB) is an SNaN then",
                "     VXSNAN := 1",
                "     if VE = 0 then VXVC := 1",
                "else if (FRA) is a QNaN or",
                "   (FRB) is a QNaN then VXVC := 1"
            ],
            "body": [
                "The floating-point operand in register FRA is compared ",
                "to the floating-point operand in register FRB. The result ",
                "of the compare is placed into CR field BF and the FPCC.",
                "If either of the operands is a NaN, either quiet or signal",
                "ing, then CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling NaN, ",
                "then VXSNAN is set and, if Invalid Operation is disabled ",
                "(VE=0), VXVC is set. If neither operand is a Signaling NaN ",
                "but at least one operand is a Quiet NaN, then VXVC is ",
                "set."
            ]
        },
        {
            "description": "Floating Compare Unordered",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fcmpu",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if (FRA) is a NaN or",
                "   (FRB) is a NaN then c := 0b0001",
                "else if (FRA) &lt; (FRB) then c := 0b1000",
                "else if (FRA) &gt; (FRB) then c := 0b0100",
                "else                       c := 0b0010",
                "FPCC := c",
                "CR<sub>4</sub>*<sub>BF:4</sub>*<sub>BF+3</sub> := c",
                "if (FRA) is an SNaN or",
                "   (FRB) is an SNaN then",
                "     VXSNAN := 1"
            ],
            "body": [
                "The floating-point operand in register FRA is compared ",
                "to the floating-point operand in register FRB. The result ",
                "of the compare is placed into CR field BF and the FPCC.",
                "If either of the operands is a NaN, either quiet or signal",
                "ing, then CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling NaN, ",
                "then VXSNAN is set."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Signed Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctid",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fctid.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "814"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x8000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 263-1, then the ",
                "result is 0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 263, then ",
                "the result is 0x8000_0000_0000_0000 and VXCVI is set to ",
                "1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Signed Word format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctiw",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P2"
                },
                {
                    "mnemonic": "fctiw.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P2"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "14"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x8000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 231-1, then the ",
                "result is 0x7FFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than -231, then ",
                "the result is 0x8000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Unsigned Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctidu",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctidu.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "942"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x0000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 264-1, then the ",
                "result is 0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0, then the ",
                "result is 0x0000_0000_0000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Unsigned Word format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctiwu",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctiwu.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "142"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x0000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 232-1, then the ",
                "result is 0xFFFF_FFFF and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0,  then the ",
                "result is 0x0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Signed Doubleword to Double-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fcfid",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fcfid.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "846"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The 64-bit signed fixed-point operand in register FRB is ",
                "converted to an infinitely precise floating-point integer. ",
                "The result of the conversion is rounded to double-preci",
                "sion, using the rounding mode specified by RN, and ",
                "placed into register FRT.",
                "The conversion is described fully in SectionA.3, \u201cFloat",
                "ing-Point Convert from Integer Model\u201d.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " "
            ]
        },
        {
            "description": "Floating Convert with round Signed Doubleword to Single-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fcfids",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fcfids.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "846"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The 64-bit signed fixed-point operand in register FRB is ",
                "converted to an infinitely precise floating-point integer. ",
                "The result of the conversion is rounded to single-preci",
                "sion, using the rounding mode specified by RN, and ",
                "placed into register FRT.",
                "The conversion is described fully in SectionA.3, \u201cFloat",
                "ing-Point Convert from Integer Model\u201d.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " "
            ]
        },
        {
            "description": "Floating Convert with round Unsigned Doubleword to Double-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fcfidu",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fcfidu.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "974"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The 64-bit unsigned fixed-point operand in register FRB ",
                "is converted to an infinitely precise floating-point inte",
                "ger. The result of the conversion is rounded to dou",
                "ble-precision, using the rounding mode specified by RN, ",
                "and placed into register FRT.",
                "The conversion is described fully in SectionA.3, \u201cFloat",
                "ing-Point Convert from Integer Model\u201d.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " "
            ]
        },
        {
            "description": "Floating Convert with round Unsigned Doubleword to Single-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fcfidus",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fcfidus.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "974"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The 64-bit unsigned fixed-point operand in register FRB ",
                "is converted to an infinitely precise floating-point inte",
                "ger. The result of the conversion is rounded to sin",
                "gle-precision, using the rounding mode specified by RN, ",
                "and placed into register FRT.",
                "The conversion is described fully in SectionA.3, \u201cFloat",
                "ing-Point Convert from Integer Model\u201d.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " ",
                "The Floating Round to Integer instructions provide ",
                "direct support for rounding functions found in high level ",
                "languages. For example, frin, friz, frip, and frim imple",
                "ment C++ round(), trunc(), ceil(), and floor(), respec",
                "tively. Note that frin does not implement the IEEE ",
                "Round to Nearest function, which is often further ",
                "described as \u201cties to even.\u201d The rounding performed by ",
                "these instructions is described fully in SectionA.4, ",
                "\u201cFloating-Point Round to Integer Model\u201d on page1018. ",
                "  ",
                "  ",
                "  "
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Signed Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctidz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fctidz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "815"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x8000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 263-1, then the ",
                "result is 0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 263, then ",
                "the result is 0x8000_0000_0000_0000 and VXCVI is set to ",
                "1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Signed Word fomat",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctiwz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P2"
                },
                {
                    "mnemonic": "fctiwz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P2"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "15"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x8000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 231-1, then the ",
                "result is 0x7FFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than -231, then ",
                "the result is 0x8000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Unsigned Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctiduz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctiduz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "943"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x0000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 264-1, then the ",
                "result is 0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0, then the ",
                "result is 0x0000_0000_0000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Unsigned Word format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fctiwuz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctiwuz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "143"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x0000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 232-1, then the ",
                "result is 0xFFFF_FFFF and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0.0,  then ",
                "the result is 0x0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, \u201cFloat",
                "ing-Point Convert to Integer Model\u201d on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Copy Sign",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fcpsgn",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "mnemonic": "fcpsgn.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of register FRB with bit 0 set to the value of ",
                "bit 0 of register FRA are placed into register FRT."
            ]
        },
        {
            "description": "Floating Divide",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fdiv",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fdiv.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "18"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Divide Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fdivs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fdivs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "18"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRA is divided by ",
                "the floating-point operand in register FRB. The remain",
                "der is not supplied as a result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Floating-point division is based on exponent subtrac",
                "tion and division of the significands.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1 and Zero ",
                "Divide Exceptions when ZE=1."
            ]
        },
        {
            "description": "Floating Merge Even Word",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmrgew",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "966"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.FP=0 then FP_Unavailable()",
                "FPR[FRT].word[0] := FPR[FRA].word[0]",
                "FPR[FRT].word[1] := FPR[FRB].word[0]"
            ],
            "body": [
                "The contents of word element 0 of FPR[FRA] are placed ",
                "into word element 0 of FPR[FRT].",
                "The contents of word element 0 of FPR[FRB] are placed ",
                "into word element 1 of FPR[FRT].",
                "fmrgew is treated as a Floating-Point instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Floating Merge Odd Word",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmrgow",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "838"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.FP=0 then FP_Unavailable()",
                "FPR[FRT].word[0] := FPR[FRA].word[1]",
                "FPR[FRT].word[1] := FPR[FRB].word[1]"
            ],
            "body": [
                "The contents of word element 1 of FPR[FRA] are placed ",
                "into word element 0 of FPR[FRT].",
                "The contents of word element 1 of FPR[FRB] are placed ",
                "into word element 1 of FPR[FRT].",
                "fmrgow is treated as a Floating-Point instruction in ",
                "terms of resource availability.",
                "  "
            ]
        },
        {
            "description": "Floating Move Register",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmr",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmr.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "72"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of register FRB are placed into register FRT."
            ]
        },
        {
            "description": "Floating Multiply",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmul",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmul.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "25"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Multiply Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmuls",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fmuls.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "25"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Floating-point multiplication is based on exponent addi",
                "tion and multiplication of the significands.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Multiply-Add",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmadd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "29"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Multiply-Add Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmadds",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fmadds.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "29"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is added to this inter",
                "mediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Multiply-Subtract",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmsub.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "28"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Multiply-Subtract Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fmsubs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fmsubs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "28"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is subtracted from this ",
                "intermediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Negate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fneg",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fneg.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "40"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of register FRB with bit 0 inverted are ",
                "placed into register FRT."
            ]
        },
        {
            "description": "Floating Negative Absolute Value",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fnabs",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fnabs.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "136"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of register FRB with bit 0 set to one are ",
                "placed into register FRT."
            ]
        },
        {
            "description": "Floating Negative Multiply-Add",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fnmadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fnmadd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "31"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Negative Multiply-Add Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fnmadds",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fnmadds.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "31"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is added to this inter",
                "mediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN, then negated ",
                "and placed into register FRT.",
                "This instruction produces the same result as would be ",
                "obtained by using the Floating Multiply-Add instruction ",
                "and then negating the result, with the following excep",
                "tions.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Negative Multiply-Subtract",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fnmsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fnmsub.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "30"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Negative Multiply-Subtract Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fnmsubs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fnmsubs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "30"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is subtracted from this ",
                "intermediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN, then negated ",
                "and placed into register FRT.",
                "This instruction produces the same result as would be ",
                "obtained by using the Floating Multiply-Subtract ",
                "instruction and then negating the result, with the follow",
                "ing exceptions.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Reciprocal Estimate",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fre",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "fre.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "24"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Reciprocal Estimate Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fres",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fres.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "24"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "An estimate of the reciprocal of the floating-point ",
                "operand in register FRB is placed into register FRT. ",
                "Unless the reciprocal would be a zero, an infinity, the ",
                "result of a trap-disabled Overflow exception, or a ",
                "QNaN, the estimate is correct to a precision of one ",
                "part in 256 of the reciprocal of (FRB), i.e.,",
                "where x is the initial value in FRB. ",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1 and Zero ",
                "Divide Exceptions when ZE=1.",
                "The results of executing this instruction may vary ",
                "between implementations, and between different exe",
                "cutions on the same implementation.",
                "  "
            ]
        },
        {
            "description": "Floating Reciprocal Square Root Estimate",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "frsqrte",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "frsqrte.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "26"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Reciprocal Square Root Estimate Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "frsqrtes",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frsqrtes.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "26"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "A estimate of the reciprocal of the square root of the ",
                "floating-point operand in register FRB is placed into reg",
                "ister FRT. The estimate placed into register FRT is correct ",
                "to a precision of one part in 32 of the reciprocal of the ",
                "square root of (FRB), i.e.,",
                "where x is the initial value in FRB. ",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1 and Zero ",
                "Divide Exceptions when ZE=1.",
                "The results of executing this instruction may vary ",
                "between implementations, and between different exe",
                "cutions on the same implementation.",
                "  "
            ]
        },
        {
            "description": "Floating Round to Integer Minus",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "frim",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frim.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "488"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value using the rounding mode round ",
                "toward -infinity, and the result is placed into register FRT. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Round to Integer Nearest",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "frin",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frin.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "392"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value as follows, with the result placed into ",
                "register FRT. If the sign of the operand is positive, ",
                "(FRB)+0.5 is truncated to an integral value, otherwise ",
                "(FRB)-0.5 is truncated to an integral value. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1. "
            ]
        },
        {
            "description": "Floating Round to Integer Plus",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "frip",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frip.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "456"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value using the rounding mode round ",
                "toward +infinity, and the result is placed into register ",
                "FRT. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Round to Integer Toward Zero",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "friz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "friz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "424"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value using the rounding mode round ",
                "toward zero, and the result is placed into register FRT. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE = 1."
            ]
        },
        {
            "description": "Floating Round to Single-Precision",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "frsp",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "frsp.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "12"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "single-precision, using the rounding mode specified by ",
                "RN, and placed into register FRT.",
                "The rounding is described fully in SectionA.1, \u201cFloat",
                "ing-Point Round to Single-Precision Model\u201d on ",
                "page1009.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Select",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fsel",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fsel.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "23"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "if (FRA) \u00b3 0.0 then FRT := (FRC)",
                "else FRT := (FRB)"
            ],
            "body": [
                "The floating-point operand in register FRA is compared ",
                "to the value zero. If the operand is greater than or equal ",
                "to zero, register FRT is set to the contents of register ",
                "FRC. If the operand is less than zero or is a NaN, regis",
                "ter FRT is set to the contents of register FRB. The com",
                "parison ignores the sign of zero (i.e., regards +0 as ",
                "equal to -0).",
                "fsel Usage Notes ",
                "This section gives examples of how the Floating Select instruction can be used to implement certain simple forms of ",
                "if-then-else constructions, without branching.",
                "The examples show program fragments in an imaginary, C-like, high-level programming language, and the corre",
                "sponding program fragment using fsel and other Power ISA instructions. In the examples, a, b, x, y, and z are ",
                "floating-point variables, which are assumed to be in FPRs fa, fb, fx, fy, and fz. FPR fs is assumed to be available for ",
                "scratch space.",
                "Warning: Care must be taken in using fsel if IEEE compatibility is required, or if the values being tested can be NaNs ",
                "or infinities; see Section.",
                "Comparison to Zero",
                "Simple if-then-else Constructions",
                "Notes:",
                "The following Notes apply to the preceding examples ",
                "and to the corresponding cases using the other three ",
                "arithmetic relations (&lt;, \u00a3, and \u00b9). They should also be ",
                "considered when any other use of fsel is contemplated.",
                "In these Notes, the \u201coptimized program\u201d is the Power ",
                "ISA program shown, and the \u201cunoptimized pro",
                "gram\u201d (not shown) is the corresponding Power ISA ",
                "program that uses fcmpu and Branch Conditional ",
                "instructions instead of fsel.",
                ""
            ]
        },
        {
            "description": "Floating Square Root",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fsqrt",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P2"
                },
                {
                    "mnemonic": "fsqrt.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P2"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "22"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Square Root Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fsqrts",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fsqrts.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "22"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The square root of the floating-point operand in register ",
                "FRB is placed into register FRT.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "FPSCR<sub>FPRF</sub> is set to the class and sign of the result, ",
                "except for Invalid Operation Exceptions when ",
                "FPSCR<sub>VE</sub><sub>=1</sub>."
            ]
        },
        {
            "description": "Floating Subtract",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fsub.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "20"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Floating Subtract Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "fsubs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fsubs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "20"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The floating-point operand in register FRB is subtracted ",
                "from the floating-point operand in register FRA.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "The execution of the Floating Subtract instruction is ",
                "identical to that of Floating Add, except that the con",
                "tents of FRB participate in the operation with the sign bit ",
                "(bit 0) inverted.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Test for software Divide ",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ftdiv",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "128"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let e_a be the unbiased exponent of the double-preci",
                "sion floating-point operand in register FRA.",
                "Let e_b be the unbiased exponent of the double-preci",
                "sion floating-point operand in register FRB.",
                "fe_flag is set to 1 if any of the following conditions ",
                "occurs.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 if either of the following conditions ",
                "occurs.",
                "Otherwise fg_flag is set to 0.",
                "If the implementation guarantees a relative error of ",
                "fre[s][.] of less than or equal to 2-14, then fl_flag is set ",
                "to 1. Otherwise fl_flag is set to 0.",
                "CR field BF is set to the value ",
                "fl_flag||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "Floating Test for software Square Root",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ftsqrt",
                    "operands": [
                        "BF",
                        "FRB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "160"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let e_b be the unbiased exponent of the double-preci",
                "sion floating-point operand in register FRB.",
                "fe_flag is set to 1 if either of the following conditions ",
                "occurs.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 if the following condition occurs.",
                "Otherwise fg_flag is set to 0.",
                "If the implementation guarantees a relative error of ",
                "frsqrte[s][.] of less than or equal to 2-14, then fl_flag is ",
                "set to 1. Otherwise fl_flag is set to 0.",
                "CR field BF is set to the value ",
                "fl_flag||fg_flag||fe_flag||0b0.",
                " ",
                "",
                "These instructions combine a multiply and an add oper",
                "ation without an intermediate rounding operation. The ",
                "fraction part of the intermediate product is 106 bits wide ",
                "(L bit, FRACTION), and all 106 bits take part in the add/",
                "subtract portion of the instruction.",
                "Status bits are set as follows."
            ]
        },
        {
            "description": "Hypervisor Return From Interrupt Doubleword",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "hrfid",
                    "operands": [],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "274"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "",
                "",
                "",
                "",
                "MSR<sub>48</sub> := HSRR1<sub>48</sub> | HSRR1<sub>49</sub>",
                "MSR<sub>58</sub> := (CTR<sub>58</sub> | CTR<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~CTR<sub>49</sub><sub>))</sub>",
                "MSR<sub>59</sub> := (CTR<sub>59</sub> | CTR<sub>49)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~CTR<sub>49</sub><sub>))</sub>",
                "",
                "NIA :=<sub>iea</sub> HSRR0<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "",
                "",
                "",
                "",
                "",
                " The result of ",
                "ORing bits 48 and 49 of HSRR1 is placed into MSR<sub>48</sub>. ",
                "The result of ANDing bit 41 of the MSR with bit 3 of ",
                "HSRR1 and with the complement of bit 49 of HSRR1 is ",
                "complemented and then ANDed with the result of ",
                "ORing bits 58 and 49 of HSRR1 and placed into ",
                "MSR<sub>58</sub>. The result of ANDing bit 41 of the MSR with bit ",
                "3 of HSRR1 and with the complement of bit 49 of ",
                "HSRR1 is complemented and then ANDed with the ",
                "result of ORing bits 59 and 49 of HSRR1 and placed ",
                "into MSR<sub>59</sub>. ",
                "",
                ".",
                "If the new MSR value does not enable any pending ",
                "exceptions, then the next instruction is fetched, under ",
                "control of the new MSR value, from the address ",
                "HSRR0<sub>0:61</sub> || 0b00 (when SF=1 in the new MSR value) ",
                "or <sup>32</sup>0 || HSRR0<sub>32:61</sub> || 0b00 (when SF=0 in the new ",
                "MSR value). If the new MSR value enables one or ",
                "more pending exceptions, the interrupt associated with ",
                "the highest priority pending exception is generated; in ",
                "this case the value placed into SRR0, HSRR0, or ",
                "USRR0 by the interrupt processing mechanism (see ",
                "Section 7.4.3) is the address of the instruction that ",
                "would have been executed next had the interrupt not ",
                "occurred.",
                "This instruction is hypervisor privileged and context ",
                "synchronizing.",
                "Special Registers Altered:",
                " "
            ]
        },
        {
            "description": "Instruction Cache Block Invalidate",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "icbi",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "982"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "If the block containing the byte addressed by EA is in ",
                "storage that is Memory Coherence Required and a ",
                "block containing the byte addressed by EA is in the ",
                "instruction cache of any processors, the block is invali",
                "dated in those instruction caches.",
                "If the block containing the byte addressed by EA is in ",
                "storage that is not Memory Coherence Required and ",
                "the block is in the instruction cache of this processor, ",
                "the block is invalidated in that instruction cache.",
                "The function of this instruction is independent of ",
                "whether the block containing the byte addressed by EA ",
                "is in storage that is Write Through Required or Caching ",
                "Inhibited.",
                "This instruction is treated as a Load (see Section 4.3), ",
                "except that reference and change recording need not ",
                "be done.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Instruction Cache Block Touch",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "icbt",
                    "operands": [
                        "CT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "CT",
                    "size": "4"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "22"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The icbt instruction provides a hint that the program ",
                "will probably soon execute code from the block contain",
                "ing the byte addressed by EA, and that the block con",
                "taining the byte addressed by EA is to be loaded into ",
                "the cache specified by the CT field. (See Section4.3 of ",
                "Book II.) If the CT field is set to a value not supported ",
                "by the implementation, no operation is performed.",
                "The hint is ignored if the block is Caching Inhibited.",
                "This instruction treated as a Load (see Section 4.3), ",
                "except that the system data storage error handler is not ",
                "invoked, and reference and change recording need not ",
                "be done.",
                "  "
            ]
        },
        {
            "description": "Instruction Synchronize",
            "form": "XL-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "isync",
                    "operands": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "150"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Executing an isync instruction ensures that all instruc",
                "tions preceding the isync instruction have completed ",
                "before the isync instruction completes, and that no ",
                "subsequent instructions are initiated until after the ",
                "isync instruction completes. It also ensures that all ",
                "instruction cache block invalidations caused by icbi ",
                "instructions preceding the isync instruction have been ",
                "performed with respect to the processor executing the ",
                "isync instruction, and then causes any prefetched ",
                "instructions to be discarded.",
                "Except as described in the preceding sentence, the ",
                "isync instruction may complete before storage ",
                "accesses associated with instructions preceding the ",
                "isync instruction have been performed.",
                "This instruction is context synchronizing (see Book III)."
            ]
        },
        {
            "description": "Integer Select",
            "form": "A-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "isel",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "BC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "BC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "15"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then a := 0 else a := (RA)",
                "if CR<sub>BC+32</sub>=1 then",
                "   RT := a",
                "else ",
                "   RT := (RB)"
            ],
            "body": [
                "If the contents of bit BC+32 of the Condition Register are ",
                "equal to 1, then the contents of register RA (or 0) are ",
                "placed into register RT. Otherwise, the contents of regis",
                "ter RB are placed into register RT.",
                "Examples of extended mnemonics for Integer Select:"
            ]
        },
        {
            "description": "Load Byte And Reserve Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "lbarx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "52"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 1",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The byte in storage addressed by EA ",
                "is loaded into RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "This instruction creates a reservation for use by a ",
                "stbcx. or waitrsv instruction. A real address computed ",
                "from the EA as described in Section 1.7.2.1 is associ",
                "ated with the reservation, and replaces any address ",
                "previously associated with the reservation. A length of ",
                "1 byte is associated with the reservation, and replaces ",
                "any length previously associated with the reservation.",
                "The value of EH provides a hint as to whether the pro",
                "gram will perform a subsequent store to the byte in ",
                "storage addressed by EA before some other processor ",
                "attempts to modify it.",
                ""
            ]
        },
        {
            "description": "Load Byte and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lbz",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "34"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clbz\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplbz\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplbz\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 1))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lbz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plbz with R=0, let EA be the sum of the contents of ",
                "register RA, or the value 0 if RA=0, and the value d0||d1, ",
                "sign-extended to 64 bits.",
                "For plbz with R=1, let EA be the sum of the address of ",
                "the instruction and the value d0||d1, sign-extended to 64 ",
                "bits.",
                "The byte in storage addressed by EA is loaded into ",
                "RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "",
                "For plbz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Byte and Zero:"
            ]
        },
        {
            "description": "Prefixed Load Byte and Zero",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plbz",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "34"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clbz\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplbz\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplbz\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 1))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lbz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plbz with R=0, let EA be the sum of the contents of ",
                "register RA, or the value 0 if RA=0, and the value d0||d1, ",
                "sign-extended to 64 bits.",
                "For plbz with R=1, let EA be the sum of the address of ",
                "the instruction and the value d0||d1, sign-extended to 64 ",
                "bits.",
                "The byte in storage addressed by EA is loaded into ",
                "RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "",
                "For plbz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Byte and Zero:"
            ]
        },
        {
            "description": "Load Byte and Zero Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "lbzcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "853"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The byte in storage addressed by EA ",
                "is loaded into RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged."
            ]
        },
        {
            "description": "Load Byte and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lbzx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "87"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The byte in storage addressed by EA ",
                "is loaded into RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0."
            ]
        },
        {
            "description": "Load Byte and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lbzu",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "35"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "The byte in storage addressed by EA is loaded into ",
                "RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Byte and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lbzux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "119"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The byte in storage addressed by EA is ",
                "loaded into RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Doubleword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ld",
                    "operands": [
                        "RT",
                        "DS(RA)"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "58"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                }
            ],
            "code": [
                "if \u201cld\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpld\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpld\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For ld, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pld with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pld with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into RT.",
                "",
                "For pld, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Doubleword:"
            ]
        },
        {
            "description": "Prefixed Load Doubleword",
            "form": "8LS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pld",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "57"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cld\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpld\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpld\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For ld, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pld with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pld with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into RT.",
                "",
                "For pld, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Doubleword:"
            ]
        },
        {
            "description": "Load Doubleword And Reserve Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "ldarx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "84"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 8",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The doubleword in storage addressed ",
                "by EA is loaded into RT.",
                "This instruction creates a reservation for use by a ",
                "stdcx. or waitrsv  instruction. A real address computed ",
                "from the EA as described in Section 1.7.2.1 is associ",
                "ated with the reservation, and replaces any address ",
                "previously associated with the reservation. A length of ",
                "8 bytes is associated with the reservation, and replaces ",
                "any length previously associated with the reservation.",
                "The value of EH provides a hint as to whether the pro",
                "gram will perform a subsequent store to the double",
                "word in storage addressed by EA before some other ",
                "processor attempts to modify it.",
                "EA must be a multiple of 8. If it is not, either the system ",
                "alignment error handler is invoked or the results are ",
                "boundedly undefined.",
                ""
            ]
        },
        {
            "description": "Load Doubleword Atomic",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "ldat",
                    "operands": [
                        "RT",
                        "RA",
                        "FC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "614"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "(RT,mem(EA,8)):= lat(mem(EA-8,24), RT+1, RT+2, FC)"
            ],
            "body": [
                "Let the effective address (EA) be (RA).  RT and the ",
                "doubleword of storage at EA are updated as specified ",
                "by load atomic function code FC.  Input operands are ",
                "function code specific, and may include RT+1, RT+2, ",
                "and  mem(EA-8,24)",
                "Figure3 contains the valid function codes.  An attempt ",
                "to execute ldat specifying an invalid function code will ",
                "cause the system data storage error handler to be ",
                "invoked.",
                "EA must be a multiple of 8, and the portion of ",
                "mem(EA-8,24) accessed by the instruction must be ",
                "contained within an aligned 32-byte block of storage.  If ",
                "either of these requirements is not satisfied, the system ",
                "alignment error handler is invoked."
            ]
        },
        {
            "description": "Load Doubleword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ldbrx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "532"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 8)",
                "RT :=  load_data<sub>56:63</sub> || load_data<sub>48:55</sub>",
                "|| load_data<sub>40:47</sub> || load_data<sub>32:39</sub>",
                "|| load_data<sub>24:31</sub> || load_data<sub>16:23</sub>",
                "|| load_data<sub>8:15</sub>  || load_data<sub>0:7</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "Bits 0:7 of the doubleword in storage addressed by EA ",
                "are loaded into RT<sub>56:63</sub>. ",
                "Bits 8:15 of the doubleword in storage addressed by EA ",
                "are loaded into RT<sub>48:55</sub>. ",
                "Bits 16:23 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>40:47</sub>. ",
                "Bits 24:31 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>32:39</sub>. ",
                "Bits 32:39 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>24:31</sub>. ",
                "Bits 40:47 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>16:23</sub>. ",
                "Bits 48:55 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>8:15</sub>. ",
                "Bits 56:63 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>0:7</sub>."
            ]
        },
        {
            "description": "Load Doubleword Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "ldcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "885"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The doubleword in storage addressed ",
                "by EA is loaded into RT.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged."
            ]
        },
        {
            "description": "Load Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ldx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "21"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The doubleword in storage ",
                "addressed by EA is loaded into RT."
            ]
        },
        {
            "description": "Load Doubleword with Update",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ldu",
                    "operands": [
                        "RT",
                        "DS(RA)"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "58"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(DS||0b00)</sub>. The doubleword in storage ",
                "addressed by EA is loaded into RT.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Doubleword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ldux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "53"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The doubleword in storage addressed ",
                "by EA is loaded into RT.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfd",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "50"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clfd\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplfd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplfd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "",
                "For plfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Prefixed Load Floating-Point Double",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plfd",
                    "operands": [
                        "FRT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "50"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clfd\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplfd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplfd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "",
                "For plfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Load Floating-Point Double Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfdx",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "599"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT."
            ]
        },
        {
            "description": "Load Floating-Point Double Pair",
            "form": "DS-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfdp",
                    "operands": [
                        "FRTp",
                        "DS(RA)"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "57"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b :=(RA)",
                "EA := b + EXTS(DS||0b00)",
                "FRTp<sub>even</sub> := MEM(EA,8)",
                "FRTp<sub>odd </sub> := MEM(EA+8, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(DS||0b00)</sub>. ",
                "The doubleword in storage addressed by EA is placed ",
                "into the even-numbered register of FRTp. ",
                "The doubleword in storage addressed by EA+8 is placed ",
                "into the odd-numbered register of FRTp. ",
                "If FRTp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double Pair Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfdpx",
                    "operands": [
                        "FRTp",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "791"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRTp<sub>even</sub> := MEM(EA,8)",
                "FRTp<sub>odd </sub> := MEM(EA+8, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "The doubleword in storage addressed by EA is placed ",
                "into the even-numbered register of FRTp. ",
                "The doubleword in storage addressed by EA+8 is placed ",
                "into the odd-numbered register of FRTp. ",
                "If FRTp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfdu",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "51"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "FRT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfdux",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "631"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "FRT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Single",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfs",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "48"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clfs\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplfs\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplfs\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is interpreted as ",
                "a floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "",
                "For plfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Prefixed Load Floating-Point Single",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plfs",
                    "operands": [
                        "FRT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "48"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clfs\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplfs\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplfs\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is interpreted as ",
                "a floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "",
                "For plfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Load Floating-Point Single Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfsx",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "535"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is interpreted as a ",
                "floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT."
            ]
        },
        {
            "description": "Load Floating-Point Single with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfsu",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "49"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "FRT := DOUBLE(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The word in storage addressed by EA is interpreted as a ",
                "floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Single with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfsux",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "567"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "FRT := DOUBLE(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is interpreted as a ",
                "floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point as Integer Word & Zero Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfiwzx",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "887"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := 320 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is loaded into ",
                "FRT<sub>32:63</sub>. FRT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Load Floating-Point as Integer Word Algebraic Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lfiwax",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "855"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is loaded into ",
                "FRT<sub>32:63</sub>. FRT<sub>0:31</sub> are filled with a copy of bit 0 of the ",
                "loaded word."
            ]
        },
        {
            "description": "Load Halfword Algebraic",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lha",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "42"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clha\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplha\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplha\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lha, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plha with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plha with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of bit 0 of the loaded ",
                "halfword.",
                "",
                "For plha, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword Alge",
                "braic:"
            ]
        },
        {
            "description": "Prefixed Load Halfword Algebraic",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plha",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "42"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clha\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplha\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplha\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lha, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plha with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plha with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of bit 0 of the loaded ",
                "halfword.",
                "",
                "For plha, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword Alge",
                "braic:"
            ]
        },
        {
            "description": "Load Halfword Algebraic Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhax",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "343"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The halfword in storage addressed ",
                "by EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy ",
                "of bit 0 of the loaded halfword."
            ]
        },
        {
            "description": "Load Halfword Algebraic with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhau",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "43"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA) +<sub>D</sub>. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of bit 0 of the loaded ",
                "halfword.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword Algebraic with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhaux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "375"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The halfword in storage addressed by ",
                "EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of ",
                "bit 0 of the loaded halfword.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword And Reserve Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "lharx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "116"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 2",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The halfword in storage addressed by ",
                "EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "This instruction creates a reservation for use by a ",
                "sthcx. or waitrsv  instruction. A real address computed ",
                "from the EA as described in Section 1.7.2.1 is associ",
                "ated with the reservation, and replaces any address ",
                "previously associated with the reservation. A length of ",
                "2 bytes is associated with the reservation, and replaces ",
                "any length previously associated with the reservation.",
                "The value of EH provides a hint as to whether the pro",
                "gram will perform a subsequent store to the halfword in ",
                "storage addressed by EA before some other processor ",
                "attempts to modify it.",
                "EA must be a multiple of 2. If it is not, either the system ",
                "alignment error handler is invoked or the results are ",
                "boundedly undefined.",
                ""
            ]
        },
        {
            "description": "Load Halfword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhbrx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "790"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 2)",
                "RT := <sup>48</sup>0 || load_data<sub>8:15</sub> || load_data<sub>0:7</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "Bits 0:7 of the halfword in storage addressed by EA are ",
                "loaded into RT<sub>56:63</sub>. ",
                "Bits 8:15 of the halfword in storage addressed by EA are ",
                "loaded into RT<sub>48:55</sub>. ",
                "RT<sub>0:47</sub> are set to 0."
            ]
        },
        {
            "description": "Load Halfword and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhz",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "40"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clhz\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplhz\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplhz\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lhz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plhz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plhz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "",
                "For plhz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword and ",
                "Zero:"
            ]
        },
        {
            "description": "Prefixed Load Halfword and Zero",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plhz",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "40"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clhz\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplhz\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplhz\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lhz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plhz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plhz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "",
                "For plhz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword and ",
                "Zero:"
            ]
        },
        {
            "description": "Load Halfword and Zero Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "lhzcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "821"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The halfword in storage addressed by ",
                "EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged."
            ]
        },
        {
            "description": "Load Halfword and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhzx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "279"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The halfword in storage addressed ",
                "by EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0."
            ]
        },
        {
            "description": "Load Halfword and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhzu",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "41"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lhzux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "311"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The halfword in storage addressed by ",
                "EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Multiple Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lmw",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "46"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RT",
                "do while r &lt;= 31",
                "   GPR(r) := <sup>32</sup>0 || MEM(EA, 4)",
                "   r := r + 1",
                "   EA := EA + 4"
            ],
            "body": [
                "Let n = (32-RT). Let the effective address (EA) be the ",
                "sum (RA|0)+<sub>D</sub>.",
                "n consecutive words starting at EA are loaded into the ",
                "low-order 32 bits of GPRs RT through 31. The ",
                "high-order 32 bits of these GPRs are set to zero.",
                "If RA is in the range of registers to be loaded, including ",
                "the case in which RA=0, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Load Quadword And Reserve Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "lqarx",
                    "operands": [
                        "RTp",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RTp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "276"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 16",
                "RESERVE_ADDR := real_addr(EA)",
                "RTp := MEM(EA, 16)",
                "",
                "",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The quadword in storage addressed by ",
                "EA is loaded into RTp.",
                "This instruction creates a reservation for use by a ",
                "stqcx. or waitrsv  instruction. A real address computed ",
                "from the EA as described in Section 1.7.2.1 is associ",
                "ated with the reservation, and replaces any address ",
                "previously associated with the reservation. A length of ",
                "16 bytes is associated with the reservation, and ",
                "replaces any length previously associated with the res",
                "ervation.",
                "The value of EH provides a hint as to whether the pro",
                "gram will perform a subsequent store to the double",
                "word in storage addressed by EA before some other ",
                "processor attempts to modify it.",
                "",
                "",
                "",
                "EA must be a multiple of 16. If it is not, either the sys",
                "tem alignment error handler is invoked or",
                " the results are boundedly undefined.",
                "If RTp is odd, RTp=RA, or RTp=RB the instruction form ",
                "is invalid. If RTp=RA or RTp=RB, an attempt to execute ",
                "this instruction will invoke the system illegal instruction ",
                "error handler. (The RTp=RA case includes the case of ",
                "RTp=RA=0.)",
                ""
            ]
        },
        {
            "description": "Load String Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lswi",
                    "operands": [
                        "RT",
                        "RA",
                        "NB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "NB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "597"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RT - 1",
                "i := 32",
                "do while n &gt; 0",
                "   if i = 32 then",
                "      r := r + 1 (mod 32)",
                "      GPR(r) := 0",
                "   GPR(r)<sub>i:i+7</sub> := MEM(EA, 1)",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n = NB if ",
                "NB\u00b90, n = 32 if NB=0; n is the number of bytes to load. Let ",
                "nr=CEIL(n/4); nr is the number of registers to receive ",
                "data.",
                "n consecutive bytes starting at EA are loaded into GPRs ",
                "RT through RT+nr-1. Data are loaded into the low-order ",
                "four bytes of each GPR; the high-order four bytes are ",
                "set to 0.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If the low-order four bytes of register RT+nr-1 ",
                "are only partially filled, the unfilled low-order byte(s) of ",
                "that register are set to 0.",
                "If RA is in the range of registers to be loaded, including ",
                "the case in which RA=0, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Load String Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lswx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "533"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER<sub>57:63</sub>",
                "r := RT - 1",
                "i := 32",
                "RT := undefined",
                "do while n &gt; 0",
                "   if i = 32 then",
                "      r := r + 1 (mod 32)",
                "      GPR(r) := 0",
                "   GPR(r)<sub>i:i+7</sub> := MEM(EA, 1)",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. Let n=XER<sub>57:63</sub>; n is the number of ",
                "bytes to load. Let nr=CEIL(n/4); nr is the number of reg",
                "isters to receive data.",
                "If n&gt;0, n consecutive bytes starting at EA are loaded ",
                "into GPRs RT through RT+nr-1. Data are loaded into the ",
                "low-order four bytes of each GPR; the high-order four ",
                "bytes are set to 0.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If the low-order four bytes of register RT+nr-1 ",
                "are only partially filled, the unfilled low-order byte(s) of ",
                "that register are set to 0.",
                "If n=0, the contents of register RT are undefined.",
                "If RA or RB is in the range of registers to be loaded, ",
                "including the case in which RA=0, the instruction is ",
                "treated as if the instruction form were invalid. If RT=RA or ",
                "RT=RB, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode and n&gt;0, the sys",
                "tem alignment error handler is invoked."
            ]
        },
        {
            "description": "Load VSX Scalar Doubleword",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxsd",
                    "operands": [
                        "VRT",
                        "DS(RA)"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "57"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201clxsd\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cplxsd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplxsd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[VRT+32].dword[0] ~ MEM(EA,8)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxsd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxsd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, let ",
                "load_data be the contents of the doubleword in storage ",
                "at address EA such that;",
                "load_data is placed into doubleword element 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxsd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Prefixed Load VSX Scalar Doubleword",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plxsd",
                    "operands": [
                        "VRT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "42"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201clxsd\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cplxsd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplxsd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[VRT+32].dword[0] ~ MEM(EA,8)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxsd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxsd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, let ",
                "load_data be the contents of the doubleword in storage ",
                "at address EA such that;",
                "load_data is placed into doubleword element 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxsd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Load VSX Scalar Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxsdx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "588"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "VSR[32\u00d7TX+T].dword[0] ~ MEM(EA,8)",
                "VSR[32\u00d7TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "load_data is placed into doubleword element 0 of ",
                "VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar Single-Precision",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxssp",
                    "operands": [
                        "VRT",
                        "DS(RA)"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "57"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \u201clxssp\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cplxssp\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplxssp\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "load_data ~ MEM(EA,4)",
                "result ~ bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] ~ bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For plxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data, interpreted as a single-precision ",
                "floating-point value, is placed into doubleword element ",
                "0 of VSR[VRT+32] in double-precision format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Single:"
            ]
        },
        {
            "description": "Prefixed Load VSX Scalar Single-Precision",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plxssp",
                    "operands": [
                        "VRT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "43"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \u201clxssp\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cplxssp\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplxssp\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "load_data ~ MEM(EA,4)",
                "result ~ bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] ~ bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For plxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data, interpreted as a single-precision ",
                "floating-point value, is placed into doubleword element ",
                "0 of VSR[VRT+32] in double-precision format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Single:"
            ]
        },
        {
            "description": "Load VSX Scalar Single-Precision Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxsspx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "524"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "load_data ~ MEM(EA,4)",
                "result ~ bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] ~ bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data, interpreted as a single-precision ",
                "floating-point value, is placed in doubleword element 0 ",
                "of VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Byte & Zero Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxsibzx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "781"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32\u00d7TX+T].dword[0] ~ EXTZ64(MEM(EA,1))",
                "VSR[32\u00d7TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The unsigned integer in the byte in storage addressed ",
                "by EA is placed in doubleword element 0 of VSR[XT]. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Halfword & Zero Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxsihzx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "813"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32\u00d7TX+T].dword[0] ~ EXTZ64(MEM(EA,2))",
                "VSR[32\u00d7TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The unsigned integer in the halfword in storage ",
                "addressed by EA is placed in doubleword element 0 of ",
                "VSR[XT]. The contents of doubleword element 1 of ",
                "VSR[XT] are set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Word & Zero Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxsiwzx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "12"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32\u00d7TX+T].dword[0] := ExtendZero(MEM(EA,4))",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is zero-extended and placed in doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Word Algebraic Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxsiwax",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "76"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32\u00d7TX+T].dword[0] := EXTS64(MEM(EA,4))",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is sign-extended to a doubleword and ",
                "placed in doubleword element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Vector",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxv",
                    "operands": [
                        "XT",
                        "DQ(RA)"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "61"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DQ",
                    "size": "12"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "1"
                }
            ],
            "code": [
                "if \u201clxv\u201d &amp; TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if \u201clxv\u201d &amp; TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "if \u201cplxv\u201d &amp; MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201clxv\u201d  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if \u201cplxv\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplxv\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[32\u00d7TX+T] ~ MEM(EA,16)"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "For lxv, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For plxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into VSR[XT].",
                "",
                "For plxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Vector:"
            ]
        },
        {
            "description": "Prefixed Load VSX Vector",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plxv",
                    "operands": [
                        "XT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "25"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clxv\u201d &amp; TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if \u201clxv\u201d &amp; TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "if \u201cplxv\u201d &amp; MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201clxv\u201d  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if \u201cplxv\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplxv\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[32\u00d7TX+T] ~ MEM(EA,16)"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "For lxv, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For plxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into VSR[XT].",
                "",
                "For plxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Vector:"
            ]
        },
        {
            "description": "Load VSX Vector Byte*16 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvb16x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "876"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 15",
                "   VSR[32\u00d7TX+T].byte[i] ~ MEM(EA+i, 1)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 15, do the following.",
                "  ",
                "Loading a vector of 16 byte elements from Big-Endian ",
                "storage in VSR[XT] using lxvb16x, retaining left-to-right ",
                "element ordering.",
                "Loading a vector of 16 byte elements from ",
                "Little-Endian storage in VSR[XT] using lxvb16x, ",
                "retaining left-to-right element ordering."
            ]
        },
        {
            "description": "Load VSX Vector Doubleword & Splat Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvdsx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "332"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data ~ MEM(EA, 8)",
                "",
                "VSR[32\u00d7TX+T].dword[0] ~ load_data",
                "VSR[32\u00d7TX+T].dword[1] ~ load_data"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "load_data is copied into each doubleword element of ",
                "VSR[XT]."
            ]
        },
        {
            "description": "Load VSX Vector Doubleword*2 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvd2x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "844"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32\u00d7TX+T].dword[0] ~ MEM(EA, 8)",
                "VSR[32\u00d7TX+T].dword[1] ~ MEM(EA+8, 8)"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 1, do the following.",
                "  "
            ]
        },
        {
            "description": "Load VSX Vector Halfword*8 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvh8x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "812"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 7",
                "   VSR[32\u00d7TX+T].hword[i] ~ MEM(EA+2\u00d7i, 2)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 7, do the following.",
                "  ",
                "Loading a vector of 8 halfword elements from ",
                "Big-Endian storage in VSR[XT] using lxvh8x, retaining ",
                "left-to-right element ordering.",
                "Loading a vector of 8 halfword elements from ",
                "Little-Endian storage in VSR[XT] using lxvh8x, retaining ",
                "left-to-right element ordering."
            ]
        },
        {
            "description": "Load VSX Vector Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "4"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "12"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32\u00d7TX+T] ~ MEM(EA,16)"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into VSR[XT].",
                "Loading 16 bytes of data from Big-Endian storage in ",
                "VSR[XT] using lxvx.",
                "Loading 16 bytes of data from Little-Endian storage in ",
                "VSR[XT] using lxvx."
            ]
        },
        {
            "description": "Load VSX Vector Paired",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvp",
                    "operands": [
                        "XTp",
                        "DQ(RA)"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "6"
                },
                {
                    "name": "Tp",
                    "size": "4"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DQ",
                    "size": "12"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if \u201clxvp\u201d then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if \u201cplxvp\u201d then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "if \u201clxvp\u201d        then EA ~ EAbase + EAdisp",
                "if \u201cplxvp\u201d &amp; R=0 then EA ~ EAbase + EAdisp",
                "if \u201cplxvp\u201d &amp; R=1 then EA ~ CIA    + EAdisp",
                "",
                "load_data ~ MEM(EA, 32)",
                "",
                "VSR[32\u00d7TX+2\u00d7Tp]   ~ load_data.bit[  0:127]",
                "VSR[32\u00d7TX+2\u00d7Tp+1] ~ load_data.bit[128:255]"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XTp be the value 32\u00d7TX + 2\u00d7Tp (i.e., only even ",
                "values of XTp can be encoded in the instruction).",
                "Let EAbase be the contents of GPR[RA], or 0 if RA=0.",
                "For lxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0, and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For plxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For plxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "Bits 0-127 of load_data are placed into VSR[XTp].",
                "",
                "",
                "For plxvp, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Load VSX Vector Paired Pre",
                "fixed:"
            ]
        },
        {
            "description": "Prefixed Load VSX Vector Paired",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plxvp",
                    "operands": [
                        "XTp",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "58"
                },
                {
                    "name": "Tp",
                    "size": "4"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if \u201clxvp\u201d then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if \u201cplxvp\u201d then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "if \u201clxvp\u201d        then EA ~ EAbase + EAdisp",
                "if \u201cplxvp\u201d &amp; R=0 then EA ~ EAbase + EAdisp",
                "if \u201cplxvp\u201d &amp; R=1 then EA ~ CIA    + EAdisp",
                "",
                "load_data ~ MEM(EA, 32)",
                "",
                "VSR[32\u00d7TX+2\u00d7Tp]   ~ load_data.bit[  0:127]",
                "VSR[32\u00d7TX+2\u00d7Tp+1] ~ load_data.bit[128:255]"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XTp be the value 32\u00d7TX + 2\u00d7Tp (i.e., only even ",
                "values of XTp can be encoded in the instruction).",
                "Let EAbase be the contents of GPR[RA], or 0 if RA=0.",
                "For lxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0, and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For plxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For plxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "Bits 0-127 of load_data are placed into VSR[XTp].",
                "",
                "",
                "For plxvp, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Load VSX Vector Paired Pre",
                "fixed:"
            ]
        },
        {
            "description": "Load VSX Vector Paired Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvpx",
                    "operands": [
                        "XTp",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "Tp",
                    "size": "4"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "333"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data ~ MEM(EA,32)",
                "VSR[32\u00d7TX+2\u00d7Tp]   ~ load_data.bit[  0:127]",
                "VSR[32\u00d7TX+2\u00d7Tp+1] ~ load_data.bit[128:255]"
            ],
            "body": [
                "Let XTp be the value 32\u00d7TX + 2\u00d7Tp (i.e., only even ",
                "values of XTp can be encoded in the instruction).",
                "Let the effective address (EA) be the sum of the integer ",
                "value in GPR[RA], or 0 if RA=0, and the integer value in ",
                "GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "Bits 0-127 of load_data are placed into VSR[XTp]."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Byte Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvrbx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "13"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32\u00d7TX+T] = EXTZ128(MEM(EA,1))"
            ],
            "body": [
                "Let XT be the value of 32\u00d7TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Load the contents of the byte in storage at address EA ",
                "into byte element 15 of VSR[XT]. The contents of byte ",
                "elements 0-14 of VSR[XT] are set to 0."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvrdx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "109"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32\u00d7TX+T] = EXTZ128(MEM(EA,8))"
            ],
            "body": [
                "Let XT be the value of 32\u00d7TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Load the contents of the doubleword in storage at ",
                "address EA into doubleword element 1 of VSR[XT]. The ",
                "contents of doubleword element 0 of VSR[XT] are set to ",
                "0.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "load_data is placed into doubleword element 1 of ",
                "VSR[XT]. The contents of doubleword element 0 of ",
                "VSR[XT] are set to 0."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Halfword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvrhx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "45"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32\u00d7TX+T] = EXTZ128(MEM(EA,2))"
            ],
            "body": [
                "Let XT be the value of 32\u00d7TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the halfword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the halfword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into halfword element 7 of VSR[XT]. ",
                "The contents of halfword elements 0-6 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Word Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvrwx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "77"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32\u00d7TX+T] = EXTZ128(MEM(EA,4))"
            ],
            "body": [
                "Let XT be the value of 32\u00d7TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into word element 3 of VSR[XT]. ",
                "The contents of word elements 0-2 of VSR[XT] are set ",
                "to 0."
            ]
        },
        {
            "description": "Load VSX Vector Special Value Quadword",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvkq",
                    "operands": [
                        "XT",
                        "UIM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "31"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "360"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if UIM=0b00001 then VSR[32\u00d7TX+T] := 0x3FFF_0000_0000_0000_0000_0000_0000_0000  /* QP +1.0  */",
                "if UIM=0b00010 then VSR[32\u00d7TX+T] := 0x4000_0000_0000_0000_0000_0000_0000_0000  /* QP +2.0  */",
                "if UIM=0b00011 then VSR[32\u00d7TX+T] := 0x4000_8000_0000_0000_0000_0000_0000_0000  /* QP +3.0  */",
                "if UIM=0b00100 then VSR[32\u00d7TX+T] := 0x4001_0000_0000_0000_0000_0000_0000_0000  /* QP +4.0  */",
                "if UIM=0b00101 then VSR[32\u00d7TX+T] := 0x4001_4000_0000_0000_0000_0000_0000_0000  /* QP +5.0  */",
                "if UIM=0b00110 then VSR[32\u00d7TX+T] := 0x4001_8000_0000_0000_0000_0000_0000_0000  /* QP +6.0  */",
                "if UIM=0b00111 then VSR[32\u00d7TX+T] := 0x4001_C000_0000_0000_0000_0000_0000_0000  /* QP +7.0  */",
                "if UIM=0b01000 then VSR[32\u00d7TX+T] := 0x7FFF_0000_0000_0000_0000_0000_0000_0000  /* QP +Inf  */",
                "if UIM=0b01001 then VSR[32\u00d7TX+T] := 0x7FFF_8000_0000_0000_0000_0000_0000_0000  /* QP dQNaN */",
                "if UIM=0b10000 then VSR[32\u00d7TX+T] := 0x8000_0000_0000_0000_0000_0000_0000_0000  /* QP -0.0  */",
                "if UIM=0b10001 then VSR[32\u00d7TX+T] := 0xBFFF_0000_0000_0000_0000_0000_0000_0000  /* QP -1.0  */",
                "if UIM=0b10010 then VSR[32\u00d7TX+T] := 0xC000_0000_0000_0000_0000_0000_0000_0000  /* QP -2.0  */",
                "if UIM=0b10011 then VSR[32\u00d7TX+T] := 0xC000_8000_0000_0000_0000_0000_0000_0000  /* QP -3.0  */",
                "if UIM=0b10100 then VSR[32\u00d7TX+T] := 0xC001_0000_0000_0000_0000_0000_0000_0000  /* QP -4.0  */",
                "if UIM=0b10101 then VSR[32\u00d7TX+T] := 0xC001_4000_0000_0000_0000_0000_0000_0000  /* QP -5.0  */",
                "if UIM=0b10110 then VSR[32\u00d7TX+T] := 0xC001_8000_0000_0000_0000_0000_0000_0000  /* QP -6.0  */",
                "if UIM=0b10111 then VSR[32\u00d7TX+T] := 0xC001_C000_0000_0000_0000_0000_0000_0000  /* QP -7.0  */",
                "if UIM=0b11000 then VSR[32\u00d7TX+T] := 0xFFFF_0000_0000_0000_0000_0000_0000_0000  /* QP -Inf  */"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "UIM specifies one of a set of common values that is placed into VSR[XT]. Unspecified values of UIM are reserved."
            ]
        },
        {
            "description": "Load VSX Vector Word & Splat Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvwsx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "364"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data ~ MEM(EA,4)",
                "",
                "do i = 0 to 3",
                "   VSR[32\u00d7TX+T].word[i] ~ load_data",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is copied into each word element of VSR[XT].",
                "Loading scalar word data from Big-Endian storage in ",
                "VSR[XT] using lxvwsx.",
                "Loading scalar word data from Little-Endian storage in ",
                "VSR[XT] using lxvwsx."
            ]
        },
        {
            "description": "Load VSX Vector Word*4 Indexed ",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvw4x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "780"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32\u00d7TX+T].word[0] ~ MEM(EA, 4)",
                "VSR[32\u00d7TX+T].word[1] ~ MEM(EA+4, 4)",
                "VSR[32\u00d7TX+T].word[2] ~ MEM(EA+8, 4)",
                "VSR[32\u00d7TX+T].word[3] ~ MEM(EA+12, 4)"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 3, do the following.",
                "  "
            ]
        },
        {
            "description": "Load VSX Vector with Length",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvl",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "269"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ (RA=0) ? 0 : GPR[RA]",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb&gt;16 then nb ~ 16",
                "",
                "load_data ~ 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "",
                "if MSR.LE = 0 then  // Big-Endian byte-ordering",
                "   load_data.byte[0:nb-1]   ~ MEM(EA,nb)",
                "else                // Little-Endian byte-ordering",
                "   load_data.byte[16-nb:15] ~ MEM(EA,nb)",
                "",
                "VSR[32\u00d7TX+T] ~ load_data"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed ",
                "and the contents of VSR[XT] are set to 0.",
                "Otherwise, when Big-Endian byte-ordering is ",
                "employed, do the following.",
                "Otherwise, when Little-Endian byte ordering is ",
                "employed, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Loading less than 16-byte data from Big-Endian ",
                "storage in VSR[XT] using lxvl.",
                "Loading less than 16-byte data from Little-Endian ",
                "storage in VSR[XT] using lxvl."
            ]
        },
        {
            "description": "Load VSX Vector with Length Left-justified",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lxvll",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "301"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := (RA=0) ? 0 : GPR[RA]",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb&gt;16 then nb ~ 16",
                "if nb&gt;0 then do i = 0 to nb-1",
                "   VSR[32\u00d7TX+T].byte[i] := MEM(EA+i,1)",
                "end",
                "if nb&lt;16 then do i = nb to 15",
                "   VSR[32\u00d7TX+T].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed ",
                "and the contents of VSR[XT] are set to 0.",
                "Otherwise, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Loading less than 16-byte data from storage in ",
                "VSR[XT], left-justified, using lxvll."
            ]
        },
        {
            "description": "Load Vector Element Byte Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lvebx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "7"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "eb := EA.bit[60:63]",
                " ",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then ",
                "   VSR[VRT+32].byte[eb] := MEM(EA,1)",
                "else",
                "   VSR[VRT+32].byte[15-eb] := MEM(EA,1)"
            ],
            "body": [
                "Let EA be the sum of the contents of GPR[RA], or 0 if ",
                "RA=0, and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, the contents of the byte in storage at address ",
                "EA are placed into byte eb of VSR[VRT+32]. The ",
                "remaining bytes of VSR[VRT+32] are set to undefined ",
                "values.",
                "If Little-Endian byte ordering is used for the storage ",
                "access, the contents of the byte in storage at address ",
                "EA are placed into byte 15-eb of VSR[VRT+32]. The ",
                "remaining bytes of VSR[VRT+32] are set to undefined ",
                "values."
            ]
        },
        {
            "description": "Load Vector Element Halfword Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lvehx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "39"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFFE",
                "eb := EA.bit[60:63]",
                " ",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then ",
                "   VSR[VRT+32].byte[eb:eb+1] := MEM(EA,2)",
                "else",
                "   VSR[VRT+32].byte[14-eb:15-eb] := MEM(EA,2)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If Little-Endian byte ordering is used for the storage ",
                "access, "
            ]
        },
        {
            "description": "Load Vector Element Word Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lvewx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "71"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFFC",
                "eb := EA.bit[60:63]",
                "",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then ",
                "   VSR[VRT+32].byte[eb:eb+3] := MEM(EA,4)",
                "else",
                "   VSR[VRT+32].byte[12-eb:15-eb] := MEM(EA,4)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If if Little-Endian byte ordering is used for the storage ",
                "access, "
            ]
        },
        {
            "description": "Load Vector Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lvx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "103"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "VSR[VRT+32] := MEM(EA, 16)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of the quadword in storage at address EA ",
                "are placed into VSR[VRT+32]. "
            ]
        },
        {
            "description": "Load Vector Indexed Last",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lvxl",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "359"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "VSR[VRT+32] := MEM(EA, 16)",
                "",
                "mark_as_not_likely_to_be_needed_again_anytime_soon(EA)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of the quadword in storage at address EA ",
                "are placed into VSR[VRT+32]. ",
                "lvxl provides a hint that the quadword in storage ",
                "addressed by EA will probably not be needed again by ",
                "the program in the near future.",
                ""
            ]
        },
        {
            "description": "Load Vector for Shift Left Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lvsl",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "6"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "sh := (((RA=0) ? 0 : GPR[RA]) + GPR[RB]).bit[60:63]",
                "",
                "switch(sh)",
                "   case(0x0): VSR[VRT+32]:=0x000102030405060708090A0B0C0D0E0F",
                "   case(0x1): VSR[VRT+32]:=0x0102030405060708090A0B0C0D0E0F10",
                "   case(0x2): VSR[VRT+32]:=0x02030405060708090A0B0C0D0E0F1011",
                "   case(0x3): VSR[VRT+32]:=0x030405060708090A0B0C0D0E0F101112",
                "   case(0x4): VSR[VRT+32]:=0x0405060708090A0B0C0D0E0F10111213",
                "   case(0x5): VSR[VRT+32]:=0x05060708090A0B0C0D0E0F1011121314",
                "   case(0x6): VSR[VRT+32]:=0x060708090A0B0C0D0E0F101112131415",
                "   case(0x7): VSR[VRT+32]:=0x0708090A0B0C0D0E0F10111213141516",
                "   case(0x8): VSR[VRT+32]:=0x08090A0B0C0D0E0F1011121314151617",
                "   case(0x9): VSR[VRT+32]:=0x090A0B0C0D0E0F101112131415161718",
                "   case(0xA): VSR[VRT+32]:=0x0A0B0C0D0E0F10111213141516171819",
                "   case(0xB): VSR[VRT+32]:=0x0B0C0D0E0F101112131415161718191A",
                "   case(0xC): VSR[VRT+32]:=0x0C0D0E0F101112131415161718191A1B",
                "   case(0xD): VSR[VRT+32]:=0x0D0E0F101112131415161718191A1B1C",
                "   case(0xE): VSR[VRT+32]:=0x0E0F101112131415161718191A1B1C1D",
                "   case(0xF): VSR[VRT+32]:=0x0F101112131415161718191A1B1C1D1E"
            ],
            "body": [
                "Let sh be bits 60:63 of the sum of the contents of ",
                "GPR[RA], or 0 if RA=0, and the contents of GPR[RB].",
                "Let X be the 32-byte value 0x00 || 0x01 || 0x02 || \u2026 || 0x1D || ",
                "0x1E || 0x1F.",
                "Bytes sh to sh+15 of X are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Load Vector for Shift Right Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lvsr",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "38"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "sh := (((RA=0) ? 0 : GPR[RA]) + GPR[RB]).bit[60:63]",
                "",
                "switch(sh)",
                "   case(0x0): VSR[VRT+32]:=0x101112131415161718191A1B1C1D1E1F",
                "   case(0x1): VSR[VRT+32]:=0x0F101112131415161718191A1B1C1D1E",
                "   case(0x2): VSR[VRT+32]:=0x0E0F101112131415161718191A1B1C1D",
                "   case(0x3): VSR[VRT+32]:=0x0D0E0F101112131415161718191A1B1C",
                "   case(0x4): VSR[VRT+32]:=0x0C0D0E0F101112131415161718191A1B",
                "   case(0x5): VSR[VRT+32]:=0x0B0C0D0E0F101112131415161718191A",
                "   case(0x6): VSR[VRT+32]:=0x0A0B0C0D0E0F10111213141516171819",
                "   case(0x7): VSR[VRT+32]:=0x090A0B0C0D0E0F101112131415161718",
                "   case(0x8): VSR[VRT+32]:=0x08090A0B0C0D0E0F1011121314151617",
                "   case(0x9): VSR[VRT+32]:=0x0708090A0B0C0D0E0F10111213141516",
                "   case(0xA): VSR[VRT+32]:=0x060708090A0B0C0D0E0F101112131415",
                "   case(0xB): VSR[VRT+32]:=0x05060708090A0B0C0D0E0F1011121314",
                "   case(0xC): VSR[VRT+32]:=0x0405060708090A0B0C0D0E0F10111213",
                "   case(0xD): VSR[VRT+32]:=0x030405060708090A0B0C0D0E0F101112",
                "   case(0xE): VSR[VRT+32]:=0x02030405060708090A0B0C0D0E0F1011",
                "   case(0xF): VSR[VRT+32]:=0x0102030405060708090A0B0C0D0E0F10"
            ],
            "body": [
                "Let sh be bits 60:63 of the sum of the contents of ",
                "GPR[RA], or 0 if RA=0, and the contents of GPR[RB].",
                "Let X be the 32-byte value 0x00 || 0x01 || 0x02 || \u2026 || 0x1D || ",
                "0x1E || 0x1F.",
                "Bytes 16-sh to 31-sh of X are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Load Word Algebraic",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwa",
                    "operands": [
                        "RT",
                        "DS(RA)"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "58"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                }
            ],
            "code": [
                "if \u201clwa\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cplwa\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplwa\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwa, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For plwa with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwa with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit 0 of the loaded ",
                "word.",
                "",
                "For plwa, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word Alge",
                "braic:"
            ]
        },
        {
            "description": "Prefixed Load Word Algebraic",
            "form": "8LS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plwa",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "41"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clwa\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cplwa\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplwa\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwa, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For plwa with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwa with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit 0 of the loaded ",
                "word.",
                "",
                "For plwa, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word Alge",
                "braic:"
            ]
        },
        {
            "description": "Load Word Algebraic Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwax",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "341"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit ",
                "0 of the loaded word."
            ]
        },
        {
            "description": "Load Word Algebraic with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwaux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "373"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit ",
                "0 of the loaded word.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word And Reserve Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "lwarx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "20"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 4",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "This instruction creates a reservation for use by a ",
                "stwcx. or waitrsv  instruction. A real address com",
                "puted from the EA as described in Section 1.7.2.1 is ",
                "associated with the reservation, and replaces any ",
                "address previously associated with the reservation. A ",
                "length of 4 bytes is associated with the reservation, and ",
                "replaces any length previously associated with the res",
                "ervation.",
                "The value of EH provides a hint as to whether the pro",
                "gram will perform a subsequent store to the word in ",
                "storage addressed by EA before some other processor ",
                "attempts to modify it.",
                "EA must be a multiple of 4. If it is not, either the system ",
                "alignment error handler is invoked or the results are ",
                "boundedly undefined.",
                ""
            ]
        },
        {
            "description": "Load Word Atomic",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "lwat",
                    "operands": [
                        "RT",
                        "RA",
                        "FC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "582"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "(RT<sub>32:63</sub>,mem(EA,4)):= lat(mem(EA-4,12), RT+1<sub>32:63</sub>, ",
                "RT+2<sub>32:63</sub>, FC)",
                "RT<sub>0:31</sub>:=0"
            ],
            "body": [
                "Let the effective address (EA) be (RA).  The least sig",
                "nificant word of RT and the word of storage at EA are ",
                "updated as specified by load atomic function code FC.   ",
                "The most significant word of RT is set to zero.  Input ",
                "operands are function code specific, and may include ",
                "the least significant words of RT+1 and RT+2, and  ",
                "mem(EA-4,12)",
                "Figure3 contains the valid function codes.  An attempt ",
                "to execute lwat specifying an invalid function code will ",
                "cause the system data storage error handler to be ",
                "invoked.",
                "EA must be a multiple of 4, and the portion of ",
                "mem(EA-4,12) accessed by the instruction must be ",
                "contained within an aligned 32-byte block of storage.  If ",
                "either of these requirements is not satisfied, the system ",
                "alignment error handler is invoked."
            ]
        },
        {
            "description": "Load Word Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwbrx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "534"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 4)",
                "RT := <sup>32</sup>0 || load_data<sub>24:31</sub> || load_data<sub>16:23</sub>",
                "         || load_data<sub>8:15</sub> || load_data<sub>0:7</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "Bits 0:7 of the word in storage addressed by EA are ",
                "loaded into RT<sub>56:63</sub>. ",
                "Bits 8:15 of the word in storage addressed by EA are ",
                "loaded into RT<sub>48:55</sub>. ",
                "Bits 16:23 of the word in storage addressed by EA are ",
                "loaded into RT<sub>40:47</sub>. ",
                "Bits 24:31 of the word in storage addressed by EA are ",
                "loaded into RT<sub>32:39</sub>. ",
                "RT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Load Word and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwz",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "32"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clwz\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplwz\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplwz\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plwz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "",
                "For plwz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Prefixed Load Word and Zero",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "plwz",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "32"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201clwz\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cplwz\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cplwz\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plwz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "",
                "For plwz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Load Word and Zero Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "lwzcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "789"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged."
            ]
        },
        {
            "description": "Load Word and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwzx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "23"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Load Word and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwzu",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "33"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA) +<sub>D</sub>. ",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "lwzux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "55"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The word in storage addressed by EA is ",
                "loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "19"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "210"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvf16ger2\u201d | \u201cxvf16ger2pp\u201d | \u201cxvf16ger2pn\u201d | \u201cxvf16ger2np\u201d | \u201cxvf16ger2nn\u201d then do",
                "   PMSK := 0b11",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] &amp; YMSK.bit[j] then do",
                "         reset_flags()",
                "",
                "         src10 := bfp_CONVERT_FROM_BFP16((PMSK.bit[0]=0) ? 0x0000 : VSR[32\u00d7AX+A].word[i].hword[0])",
                "         src11 := bfp_CONVERT_FROM_BFP16((PMSK.bit[1]=0) ? 0x0000 : VSR[32\u00d7AX+A].word[i].hword[1])",
                "         src20 := bfp_CONVERT_FROM_BFP16((PMSK.bit[0]=0) ? 0x0000 : VSR[32\u00d7BX+B].word[j].hword[0])",
                "         src21 := bfp_CONVERT_FROM_BFP16((PMSK.bit[1]=0) ? 0x0000 : VSR[32\u00d7BX+B].word[j].hword[1])",
                "",
                "         p1    := bfp_MULTIPLY(src10, src20)",
                "         v1    := bfp_MULTIPLY_ADD(src11, src21, p1)",
                "         r1    := bfp_ROUND_TO_BFP32_NO_TRAP(FPSCR.RN, v1)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if ox_flag=1 then SetFX(FPSCR.OX)",
                "         if ux_flag=1 then SetFX(FPSCR.UX)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "         reset_flags()",
                "",
                "         if \u201c[pm]xvf16ger2\u201d then",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r1)",
                "",
                "         else do",
                "            acc := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "            if \u201c[pm]xvf16ger2pp\u201d then v2 := bfp_ADD(r1, acc)",
                "            if \u201c[pm]xvf16ger2pn\u201d then v2 := bfp_ADD(r1, bfp_NEGATE(acc))",
                "            if \u201c[pm]xvf16ger2np\u201d then v2 := bfp_ADD(bfp_NEGATE(r1), acc)",
                "            if \u201c[pm]xvf16ger2nn\u201d then v2 := bfp_ADD(bfp_NEGATE(r1), bfp_NEGATE(acc))",
                "",
                "            r2 := bfp_ROUND_TO_BFP32_NO_TRAP(FPSCR.RN, v2)",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "            if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "            if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "            if ox_flag=1 then SetFX(FPSCR.OX)",
                "            if ux_flag=1 then SetFX(FPSCR.UX)",
                "            if xx_flag=1 then SetFX(FPSCR.XX)",
                "         end",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of single-precision floating-point values.",
                "Let result be a 4\u00d74 matrix of word elements to be used as a temporary Accumulator.",
                "For xvf16ger2, xvf16ger2pp, xvf16ger2pn, xvf16ger2np, or xvf16ger2nn, let PMSK=0b11, XMSK=0b1111, and ",
                "YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following.",
                "Unlike other VSX Vector Floating-Point instructions, ACC[AT] is always updated by the execution of the instruction, ",
                "even when a trap-enabled exception occurs. For every multiply-add operation that is performed as part of the ",
                "execution of this instruction, if an exception occurs as the result of that particular multiply-add operation, the ",
                "trap-disabled exception result is returned, even if that exception type is trap-enabled. Exception detection is based ",
                "on the trap-disable definition. Exception status is accumulated and the appropriate exception status bits in the ",
                "FPSCR are updated at the completion of execution of the instruction. Otherwise, behavior is the same as any vector ",
                "floating-point instruction that can cause an exception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "82"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "146"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "18"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "75"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "107"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvi16ger2s\u201d | \u201cxvi16ger2spp\u201d then do",
                "   PMSK := 0b11",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] &amp; YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].hword[0]) * EXTS(VSR[32\u00d7BX+B].word[j].hword[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].hword[1]) * EXTS(VSR[32\u00d7BX+B].word[j].hword[1])",
                "",
                "         psum  := prod0 + prod1",
                "",
                "         if \u201c[pm]xvi16ger2\u201d   then ACC[AT][i].word[j] := CHOP32(psum)",
                "         if \u201c[pm]xvi16ger2pp\u201d then ACC[AT][i].word[j] := CHOP32(psum + EXTS(ACC[AT][i].word[j])",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of 32-bit signed integer values.",
                "For xvi16ger2 or xvi16ger2pp, let PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3 and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2s",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "43"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "42"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvi16ger2s\u201d | \u201cxvi16ger2spp\u201d then do",
                "   PMSK := 0b11",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "sat_flag := 0",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] &amp; YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].hword[0]) * EXTS(VSR[32\u00d7BX+B].word[j].hword[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].hword[1]) * EXTS(VSR[32\u00d7BX+B].word[j].hword[1])",
                "",
                "         psum  := prod0 + prod1",
                "",
                "         if \u201c[pm]xvi16ger2s\u201d then",
                "            ACC[AT][i].word[j] := si32_CLAMP( psum )",
                "         if \u201c[pm]xvi16ger2spp\u201d then",
                "            ACC[AT][i].word[j] := si32_CLAMP( psum + EXTS(ACC[AT][i].word[j] )",
                "",
                "         if sat_flag=1 then VSCR.SAT := 1",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of 32-bit signed integer values.",
                "For xvi16ger2s or xvi16ger2spp, let PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3 and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32ger",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "27"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gernn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "218"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvf32ger\u201d | \u201cxvf32gerpp\u201d | \u201cxvf32gerpn\u201d | \u201cxvf32gernp\u201d | \u201cxvf32gernn\u201d then do",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i]=1 &amp; YMSK.bit[j]=1 then do",
                "         reset_flags()",
                "",
                "         src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "         src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[j])",
                "         acc  := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "         if \u201c[pm]xvf32ger\u201d   then v := bfp_MULTIPLY( src1, src2 )",
                "         if \u201c[pm]xvf32gerpp\u201d then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "         if \u201c[pm]xvf32gerpn\u201d then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if \u201c[pm]xvf32gernp\u201d then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if \u201c[pm]xvf32gernn\u201d then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "",
                "         r := bfp_ROUND_TO_BFP32_NO_TRAP(v)",
                "",
                "         if \u201c[pm]xvf32gernp\u201d then r := bfp_NEGATE(r)",
                "         if \u201c[pm]xvf32gernn\u201d then r := bfp_NEGATE(r)",
                "",
                "         ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if ox_flag=1 then SetFX(FPSCR.OX)",
                "         if ux_flag=1 then SetFX(FPSCR.UX)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "      end",
                "      else",
                "         ACC[AT][i].word[j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of single-precision floating-point values.",
                "For xvf32ger, xvf32gerpp, xvf32gerpn, xvf32gernp, or xvf32gernn, let XMSK=0b1111 and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following.",
                "Unlike other vector floating-point instructions, ACC[AT] is always updated by the execution of the instruction, even ",
                "when a trap-enabled exception occurs. For every multiply-add operation that is performed as part of the execution of ",
                "this instruction, if an exception occurs as the result of that particular multiply-add operation, the trap-disabled ",
                "exception result is returned, even if that exception type is trap-enabled. Exception detection is based on the ",
                "trap-disable definition. Exception status is  and the appropriate exception status bits in the FPSCR are updated at ",
                "the completion of execution of the instruction. Otherwise, behavior is the same as any vector floating-point ",
                "instruction that can cause an eaccumulatedxception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gernp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "90"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gerpn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "154"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gerpp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "26"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 4-bit Signed Integer GER ( rank-8 update )",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi4ger8",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "35"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 4-bit Signed Integer GER ( rank-8 update ) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi4ger8pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "34"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvi4ger8\u201d | \u201cxvi4ger8pp\u201d then do",
                "   PMSK := 0b11111111",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] &amp; YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[0]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[1]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[1])",
                "         prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[2]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[2])",
                "         prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[3]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[3])",
                "         prod4 := (PMSK.bit[4]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[4]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[4])",
                "         prod5 := (PMSK.bit[5]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[5]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[5])",
                "         prod6 := (PMSK.bit[6]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[6]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[6])",
                "         prod7 := (PMSK.bit[7]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].nibble[7]) * EXTS(VSR[32\u00d7BX+B].word[j].nibble[7])",
                "",
                "         psum  := prod0 + prod1 + prod2 + prod3 + prod4 + prod5 + prod6 + prod7",
                "",
                "         if \u201c[pm]xvi4ger8\u201d   then ACC[AT][i].word[j] := CHOP32( psum )",
                "         if \u201c[pm]xvi4ger8pp\u201d then ACC[AT][i].word[j] := CHOP32( psum + EXTS(ACC[AT][i].word[j]) )",
                "      end",
                "      else",
                "         ACC[AT][i].word[j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of 32-bit signed integer values. ",
                "For xvi4ger8 or xvi4ger8pp, let PMSK=0b11111111, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64ger",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "59"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gernn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "250"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvf64ger\u201d | \u201cxvf64gerpp\u201d | \u201cxvf64gerpn\u201d | \u201cxvf64gernp\u201d | \u201cxvf64gernn\u201d then do",
                "   XMSK := 0b1111",
                "   YMSK := 0b11",
                "end",
                "vsrc1.qword[0] := VSR[32\u00d7AX+Ap]",
                "vsrc1.qword[1] := VSR[32\u00d7AX+Ap+1]",
                "vsrc2          := VSR[32\u00d7BX+B]",
                "do i = 0 to 3",
                "   do j = 0 to 1",
                "      if XMSK.bit[i]=1 &amp; YMSK.bit[j]=1 then do",
                "         reset_flags()",
                "",
                "         src1 := bfp_CONVERT_FROM_BFP64(vsrc1.dword[i])",
                "         src2 := bfp_CONVERT_FROM_BFP64(vsrc2.dword[j])",
                "         acc  := bfp_CONVERT_FROM_BFP64(ACC[AT][i].dword[j])",
                "",
                "         if \u201c[pm]xvf64ger\u201d   then v := bfp_MULTIPLY( src1, src2 )",
                "         if \u201c[pm]xvf64gerpp\u201d then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "         if \u201c[pm]xvf64gerpn\u201d then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if \u201c[pm]xvf64gernp\u201d then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if \u201c[pm]xvf64gernn\u201d then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "",
                "         r := bfp_ROUND_TO_BFP64_NO_TRAP(v)",
                "",
                "         if \u201c[pm]xvf64gernp\u201d then r := bfp_NEGATE(r)",
                "         if \u201c[pm]xvf64gernn\u201d then r := bfp_NEGATE(r)",
                "",
                "         ACC[AT][i].dword[j] := bfp64_CONVERT_FROM_BFP(r)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if ox_flag=1 then SetFX(FPSCR.OX)",
                "         if ux_flag=1 then SetFX(FPSCR.UX)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "      end",
                "      else",
                "         ACC[AT][i].dword[j] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XAp be the value of 32\u00d7AX + Ap. If XAp is odd, or is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d72 matrix of double-precision floating-point values.",
                "Let vsrcX be the concatenation of the contents of VSR[XAp] and VSR[XAp+1].",
                "For xvf64ger, xvf64gerpp, xvf64gerpn, xvf64gernp, and xvf64gernn, let XMSK=0b1111 and YMSK=0b11.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 1, do the following.",
                "Unlike other vector floating-point instructions, ACC[AT] is always updated by the execution of the instruction, even ",
                "when a trap-enabled exception occurs. For every multiply-add operation that is performed as part of the execution of ",
                "this instruction, if an exception occurs as the result of that particular multiply-add operation, the trap-disabled ",
                "exception result is returned, even if that exception type is trap-enabled. Exception detection is based on the ",
                "trap-disable definition. Exception status is accumulated and the appropriate exception status bits in the FPSCR are ",
                "updated at the completion of execution of the instruction. Otherwise, behavior is the same as any vector ",
                "floating-point instruction that can cause an exception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gernp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "122"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gerpn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "186"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gerpp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "58"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi8ger4",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "3"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi8ger4pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "2"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvi8ger4\u201d | \u201cxvi8ger4pp\u201d then do",
                "   PMSK := 0b1111",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] &amp; YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[0]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[1]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[1])",
                "         prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[2]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[2])",
                "         prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[3]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[3])",
                "",
                "         psum  := prod0 + prod1 + prod2 + prod3",
                "",
                "         if \u201c[pm]xvi8ger4\u201d   then ACC[AT][i].word[j] := CHOP32( psum )",
                "         if \u201c[pm]xvi8ger4pp\u201d then ACC[AT][i].word[j] := CHOP32( psum + EXTS(ACC[AT][i].word[j]) )",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of 32-bit signed integer values. ",
                "For xvi8ger4 or xvi8ger4pp, let PMSK=0b1111, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturate Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi8ger4spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "99"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvi8ger4pps\u201d then do",
                "   PMSK := 0b1111",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] &amp; YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[0]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[1]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[1])",
                "         prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[2]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[2])",
                "         prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32\u00d7AX+A].word[i].byte[3]) * EXTZ(VSR[32\u00d7BX+B].word[j].byte[3])",
                "",
                "         psum  := prod0 + prod1 + prod2 + prod3",
                "",
                "         ACC[AT][i].word[j] := si32_CLAMP( psum + EXTS(ACC[AT][i].word[j] )",
                "",
                "         if sat_flag=1 then VSCR.SAT := 1",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of 32-bit signed integer values. ",
                "For xvi8ger4spp, let PMSK=0b1111, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvbf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "51"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvbf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "242"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cxvbf16ger2\u201d | \u201cxvbf16ger2pp\u201d | \u201cxvbf16ger2pn\u201d | \u201cxvbf16ger2np\u201d | \u201cxvbf16ger2nn\u201d then do",
                "   PMSK := 0b11      // enable all rank updates",
                "   XMSK := 0b1111    // enable all ACC[AT] rows",
                "   YMSK := 0b1111    // enable all ACC[AT] columns",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i]=1 &amp; YMSK.bit[j]=1 then do",
                "         src11 := (PMSK.bit[0]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32\u00d7AX+A].word[i].hword[0])",
                "         src21 := (PMSK.bit[0]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32\u00d7BX+B].word[j].hword[0])",
                "         src12 := (PMSK.bit[1]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32\u00d7AX+A].word[i].hword[1])",
                "         src22 := (PMSK.bit[1]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32\u00d7BX+B].word[j].hword[1])",
                "",
                "         reset_flags()",
                "",
                "         p1 := bfp_MULTIPLY(src11, src21)",
                "         v1 := bfp_MULTIPLY_ADD(src12, src22, p1)",
                "         r1 := bfp_ROUND_TO_BFP32_SIGNIFICAND(v1)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "         if \u201c[pm]xvbf16ger2\u201d then do",
                "            reset_flags()",
                "",
                "            r2 := bfp_ROUND_TO_BFP32_NO_TRAP(r1)",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "            if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "            if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "            if ox_flag=1 then SetFX(FPSCR.OX)",
                "            if ux_flag=1 then SetFX(FPSCR.UX)",
                "            if xx_flag=1 then SetFX(FPSCR.XX)",
                "         end",
                "",
                "         else do",
                "            acc := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "            reset_flags()",
                "",
                "            if \u201c[pm]xvbf16ger2pp\u201d then v := bfp_ADD(r1, acc)",
                "            if \u201c[pm]xvbf16ger2pn\u201d then v := bfp_ADD(r1, bfp_NEGATE(acc))",
                "            if \u201c[pm]xvbf16ger2np\u201d then v := bfp_ADD(bfp_NEGATE(r1), acc)",
                "            if \u201c[pm]xvbf16ger2nn\u201d then v := bfp_ADD(bfp_NEGATE(r1), bfp_NEGATE(acc))",
                "",
                "            r2 := bfp_ROUND_TO_BFP32_NO_TRAP(v)",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "            if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "            if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "            if ox_flag=1 then SetFX(FPSCR.OX)",
                "            if ux_flag=1 then SetFX(FPSCR.UX)",
                "            if xx_flag=1 then SetFX(FPSCR.XX)",
                "         end",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32\u00d7AX + A. If XA is in the range 4\u00d7AT to 4\u00d7AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4\u00d74 matrix of single-precision floating-point values.",
                "For xvbf16ger2, xvbf16ger2pp, xvbf16ger2pn, xvbf16ger2np, or xvbf16ger2nn, let PMSK=0b11, XMSK=0b1111, and ",
                "YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following.",
                "Unlike other VSX Vector Floating-Point instructions, ACC[AT] is always updated by the execution of the instruction, ",
                "even when a trap-enabled exception occurs. For every rounding operation that is performed as part of the execution ",
                "of this instruction, if an exception occurs as the result of that particular rounding operation, the trap-disabled ",
                "exception result is returned, even if that exception type is trap-enabled. Exception detection is based on the ",
                "trap-disabled definition. Exception status is accumulated and the appropriate exception status bits in the FPSCR are ",
                "updated at the completion of execution of the instruction. Otherwise, behavior is the same as any vector ",
                "floating-point instruction that can cause an exception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvbf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "114"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvbf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "178"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pmxvbf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "50"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Message Clear",
            "form": "X-form",
            "category": "Processor Control  ",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "msgclr",
                    "operands": [
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "238"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "t := hypervisor thread number of executing thread",
                "if(msgtype = 0x05) then",
                "clear any Directed Hypervisor Doorbell exception",
                "for thread t"
            ],
            "body": [
                "msgclr clears a message previously accepted by the ",
                "thread executing the msgclr.",
                "Let msgtype be (RB)<sub>32: 36</sub>, and let t be the hypervisor ",
                "thread number of the thread executing the msgclr ",
                "instruction. ",
                "If msgtype = 0x05, then clear any Directed Hypervisor ",
                "Doorbell exception that exists on thread t; otherwise, ",
                "this instruction is treated as a no-op.",
                "This instruction is hypervisor privileged.",
                " "
            ]
        },
        {
            "description": "Message Clear Privileged",
            "form": "X-form",
            "category": "Processor Control  ",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "msgclrp",
                    "operands": [
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "174"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := (RB)<sub>32:36</sub>",
                "t := privileged thread number of executing thread",
                "IF(msgtype = 0x05)",
                "  then",
                "DPDES<sub>63-t</sub> := 0"
            ],
            "body": [
                "msgclrp clears a message previously accepted by the ",
                "thread executing the msgclrp.",
                "Let msgtype be (RB)<sub>32:36</sub>, and let t be the privileged ",
                "thread number of the thread executing the msgclrp. ",
                "If msgtype = 0x05, then clear any Directed Privileged ",
                "Doorbell exception that exists on thread t by setting ",
                "DPDES<sub>63-t</sub> to 0; otherwise, this instruction is treated as ",
                "a no-op.",
                "This instruction is privileged.",
                " "
            ]
        },
        {
            "description": "Message Clear Ultravisor",
            "form": "X-form",
            "category": "Processor Control  ",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "msgclru",
                    "operands": [
                        "RB"
                    ],
                    "release": "v3.0C"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "110"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "t := hypervisor thread number of executing thread",
                "if (msgtype = 0x05) then",
                "clear any Directed Ultravisor Doorbell exception",
                "for thread t"
            ],
            "body": [
                "msgclru clears a message previously accepted by the ",
                "thread executing the msgclru.",
                "Let msgtype be (RB)<sub>32: 36</sub>, and let t be the hypervisor ",
                "thread number of the thread executing the msgclru ",
                "instruction. ",
                "If msgtype = 0x05, then clear any Directed Ultravisor ",
                "Doorbell exception that exists on thread t; otherwise, ",
                "this instruction is treated as a no-op.",
                "This instruction is ultravisor privileged.",
                " "
            ]
        },
        {
            "description": "Message Send",
            "form": "X-form",
            "category": "Processor Control  ",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "msgsnd",
                    "operands": [
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "206"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := GPR(RB)<sub>32:36</sub>",
                "payload := GPR(RB)<sub>37:63</sub>",
                "if(msgtype = 0x05)then",
                "   send_msg(msgtype, payload)"
            ],
            "body": [
                "msgsnd sends a message to other threads in the sys",
                "tem. The message type and destination thread(s) are ",
                "specified in RB. ",
                "RB",
                "The contents of RB are defined below. Bits 37:63 are ",
                "referred to as the message payload.",
                "The actions taken on receipt of a message are defined ",
                "in Section11.2.",
                "This instruction is hypervisor privileged.",
                " "
            ]
        },
        {
            "description": "Message Send Privileged",
            "form": "X-form",
            "category": "Processor Control  ",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "msgsndp",
                    "operands": [
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "142"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := (RB)<sub>32:36</sub>",
                "payload := (RB)<sub>37:63</sub>",
                "t := (RB)<sub>57:63</sub>",
                "if msgtype = 5 and",
                "   t &lt;=  maximum privileged thread number",
                "       on processor or sub-processor",
                "  then",
                " DPDES<sub>63-t</sub> := 1",
                "    send_msg(msgtype, payload, t)"
            ],
            "body": [
                "msgsndp sends a message to other threads that are ",
                "on the same multi-threaded processor (if the processor ",
                "is not in sub-processor mode) or to other threads that ",
                "are on the same sub-processor (if the processor is in ",
                "sub-processor mode). The message type and destina",
                "tion thread(s) are specified in RB. ",
                "RB",
                "The contents of RB are defined below. Bits 37:63 are ",
                "referred to as the message payload.",
                "The actions taken on receipt of a message are defined ",
                "in Section11.2.",
                "This instruction is privileged.",
                " "
            ]
        },
        {
            "description": "Message Send Ultravisor",
            "form": "X-form",
            "category": "Processor Control  ",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "msgsndu",
                    "operands": [
                        "RB"
                    ],
                    "release": "v3.0C"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "78"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := GPR(RB)<sub>32:36</sub>",
                "payload := GPR(RB)<sub>37:63</sub>",
                "if (msgtype = 0x05) then",
                "   send_msg(msgtype, payload)"
            ],
            "body": [
                "msgsndu sends a message to other threads in the ",
                "system. The message type and destination thread(s) ",
                "are specified in RB. ",
                "RB",
                "The contents of RB are defined below. Bits 37:63 are ",
                "referred to as the message payload.",
                "The actions taken on receipt of a message are defined ",
                "in Section11.2.",
                "This instruction is ultravisor privileged.",
                " "
            ]
        },
        {
            "description": "Message Synchronize",
            "form": "X-form",
            "category": "Processor Control  ",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "msgsync",
                    "operands": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "886"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                " "
            ],
            "body": [
                "In conjunction with the Synchronize and msgsndu or ",
                "msgsnd instructions, the msgsync instruction pro",
                "vides an ordering function for stores that have been ",
                "performed with respect to the thread executing the ",
                "Synchronize and msgsndu or msgsnd instructions, ",
                "relative to data accesses by other threads that are per",
                "formed after a Directed Ultravisor Doorbell or Directed ",
                "Hypervisor Doorbell interrupt has occurred, as ",
                "described in the Synchronize instruction description on ",
                "p. 1249.",
                "This instruction is hypervisor privileged.",
                "Special Registers Altered:",
                "      None",
                ""
            ]
        },
        {
            "description": "Modulo Signed Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "modsd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "777"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "remainder = dividend - (quotient \u00d7 divisor)",
                "&lt;anything&gt; % 0",
                "   0x8000_0000_0000_0000 % -1"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit remainder of the dividend divided by the ",
                "divisor is placed into register RT. The quotient is not ",
                "supplied as a result.",
                "Both operands and the remainder are interpreted as ",
                "signed integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 \u00a3 remainder &lt; |divisor| if the dividend is ",
                "nonnegative, and -|divisor| &lt; remainder \u00a3 0 if the ",
                "dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Signed Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "modsw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "779"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31 </sub>  := (RB)<sub>32:63</sub>-",
                "RT<sub>32:63</sub>       := dividend % divisor",
                "RT<sub>0:31 </sub>       := undefined",
                "remainder = dividend - (quotient \u00d7 divisor)",
                "0x8000_0000 % -1",
                "&lt;anything&gt; % 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit remainder of the dividend divided ",
                "by the divisor is placed into RT<sub>32:63</sub>. The contents of ",
                "RT<sub>0:31</sub> are undefined. The quotient is not supplied as a ",
                "result.",
                "Both operands and the remainder are interpreted as ",
                "signed integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 \u00a3 remainder &lt; |divisor| if the dividend is ",
                "nonnegative, and -|divisor| &lt; remainder \u00a3 0 if the ",
                "dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Unsigned Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "modud",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "265"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "remainder = dividend - (quotient \u00d7 divisor)",
                "&lt;anything&gt; % 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit remainder of the dividend divided by the ",
                "divisor is placed into register RT. The quotient is not ",
                "supplied as a result.",
                "Both operands and the remainder are interpreted as ",
                "unsigned integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 \u00a3 remainder &lt; divisor.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Unsigned Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "moduw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "267"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31 </sub>  := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub>       := dividend % divisor",
                "RT<sub>0:31 </sub>       := undefined",
                "remainder = dividend - (quotient \u00d7 divisor)",
                "&lt;anything&gt; % 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit remainder of the dividend divided ",
                "by the divisor is placed into RT<sub>32:63</sub>. The contents of ",
                "RT<sub>0:31</sub> are undefined. The quotient is not supplied as a ",
                "result.",
                "Both operands and the remainder are interpreted as ",
                "unsigned integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 \u00a3 remainder &lt; divisor.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Move Condition Register Field",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mcrf",
                    "operands": [
                        "BF",
                        "BFA"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "BFA",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := CR<sub>4</sub>*<sub>BFA+32:4</sub>*<sub>BFA+35</sub>"
            ],
            "body": [
                "The contents of Condition Register field BFA are cop",
                "ied to Condition Register field BF.",
                "These instructions provide the means by which a pro",
                "gram can call upon the system to perform a service.",
                "",
                ""
            ]
        },
        {
            "description": "Move From Branch History Rolling Buffer Entry",
            "form": "XFX-form",
            "category": "Branch History Rolling Buffer",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "mfbhrbe",
                    "operands": [
                        "RT",
                        "BHRBE"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BHRBE",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "302"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := BHRBE<sub>0:9</sub>",
                "If n &lt; number of BHRBEs implemented then",
                " RT := BHRBE(n)",
                "else",
                " RT := <sup>64</sup>0"
            ],
            "body": [
                "The BHRBE field denotes an entry in the BHRB.  If the ",
                "designated entry is within the range of BHRB entries ",
                "implemented and Performance Monitor alterts are dis",
                "able (see Section10.5 of Book III), the contents of the ",
                "designated BHRB entry are placed into register RT; ",
                "otherwise, <sup>64</sup>0s are placed into register RT.",
                "In order to ensure that the current BHRB contents are ",
                "read by this instruction, one of the following must have ",
                "occurred prior to this instruction and after all previous ",
                "Branch and clrbhrb instructions have completed.",
                "  "
            ]
        },
        {
            "description": "Move From Condition Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mfcr",
                    "operands": [
                        "RT"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "   RT := <sup>32</sup>0 || CR"
            ],
            "body": [
                "The contents of the Condition Register are placed into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Move From FPSCR",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mffs",
                    "operands": [
                        "FRT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mffs.",
                    "operands": [
                        "FRT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "583"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of the FPSCR are placed into register ",
                "FRT.",
                "If Rc=1, CR field 1 is set to the value FX||FEX||VX||OX."
            ]
        },
        {
            "description": "Move From FPSCR & Clear Enables",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mffsce",
                    "operands": [
                        "FRT"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "583"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of the FPSCR are placed into register FRT.",
                "The contents of bits 56:60 (VE, OE, UE, ZE, XE) of the ",
                "FPSCR are set to 0."
            ]
        },
        {
            "description": "Move From FPSCR Control & Set DRN",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mffscdrn",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "20"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "583"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let new_DRN be the contents of bits 29:31 of register ",
                "FRB.",
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "are placed into the corresponding bits in register FRT. All ",
                "other bits in register FRT are set to 0.",
                "new_DRN is placed into bits 62:64 of the FPSCR (DRN).",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Control & Set DRN Immediate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mffscdrni",
                    "operands": [
                        "FRT",
                        "DRM"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "21"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "DRM",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "583"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "are placed into the corresponding bits in register FRT. All ",
                "other bits in register FRT are set to 0.",
                "The contents of bits 29:31 of the FPSCR (DRN) are set ",
                "to the value of DRM.",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Control & Set RN",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mffscrn",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "22"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "583"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let new_RN be the contents of bits 62:63 of register ",
                "FRB.",
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, ",
                "RN), are placed into the corresponding bits in register ",
                "FRT. All other bits in register FRT are set to 0.",
                "new_RN is placed into bits 62:63 of the FPSCR (RN).",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Control & Set RN Immediate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mffscrni",
                    "operands": [
                        "FRT",
                        "RM"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "23"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "RM",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "583"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "are placed into the corresponding bits in register FRT. All ",
                "other bits in register FRT are set to 0.",
                "The contents of bits 62:63 of the FPSCR (RN) are set to ",
                "the value of RM.",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Lightweight",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mffsl",
                    "operands": [
                        "FRT"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "24"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "583"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "and the non-sticky status bits in the FPSCR, that is, bits ",
                "45:51 (FR, FI, C, FL, FG, FE, FU), are placed into the cor",
                "responding bits in register FRT. All other bits in register ",
                "FRT are set to 0.",
                "  "
            ]
        },
        {
            "description": "Move From Machine State Register",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "mfmsr",
                    "operands": [
                        "RT"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "83"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT := MSR"
            ],
            "body": [
                "The contents of the MSR are placed into register RT. ",
                "This instruction is privileged."
            ]
        },
        {
            "description": "Move From One Condition Register Field",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mfocrf",
                    "operands": [
                        "RT",
                        "FXM"
                    ],
                    "release": "v2.01"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "FXM",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT := undefined",
                "count := 0",
                "do i = 0 to 7",
                "   if FXM<sub>i</sub> = 1 then",
                "      n := i",
                "      count := count + 1",
                "if count = 1 then",
                "   RT := <sup>64</sup>0",
                "   RT<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub> := CR<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub>"
            ],
            "body": [
                "If exactly one bit of the FXM field is set to 1, let n be the ",
                "position of that bit in the field (0 \u00a3 n \u00a3 7). The contents ",
                "of CR field n (CR bits 4*n+32:4*n+35) are placed into ",
                "bits 4\u00b4n+32:4\u00b4n+35 of register RT, and the contents of ",
                "the remaining bits of register RT are undefined. ",
                "Otherwise, the contents of register RT are undefined.",
                "If exactly one bit of the FXM field is set to 1, the ",
                "contents of the remaining bits of register RT are set to ",
                "0s instead of being undefined as specified above.",
                "  "
            ]
        },
        {
            "description": "Move From Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mfspr",
                    "operands": [
                        "RT",
                        "SPR"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "spr",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "339"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "   case(808, 809, 810, 811):",
                "   default:",
                "      if length(SPR(n)) = 64 then",
                "         RT := SPR(n)",
                "      else",
                "         RT := <sup>32</sup>0 || SPR(n)"
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in the table below.  If the SPR field ",
                "contains a value from 808 through 811, the instruction ",
                "specifies a reserved SPR, and is treated as a no-op; ",
                "see Section1.3.3, \u201cReserved Fields, Reserved Values, ",
                "and Reserved SPRs\u201d.  Otherwise, the contents of the ",
                "designated Special Purpose Register are placed into ",
                "register RT. For Special Purpose Registers that are 32 ",
                "bits long, the low-order 32 bits of RT receive the con",
                "tents of the Special Purpose Register and the ",
                "high-order 32 bits of RT are set to zero.",
                "If execution of this instruction is attempted specifying ",
                "an SPR number that is not shown above, one of the fol",
                "lowing occurs.",
                "A complete description of this instruction can be found ",
                "in Book III.",
                "Examples of extended mnemonics for Move From Spe",
                "cial Purpose Register:",
                " "
            ]
        },
        {
            "description": "Move From Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "mfspr",
                    "operands": [
                        "RT",
                        "SPR"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "spr",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "339"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "",
                "  case(808, 809, 810, 811):",
                "  default:",
                "    if length(SPR(n)) = 64 then",
                "      RT := SPR(n)",
                "    else",
                "      RT := <sup>32</sup>0 || SPR(n)",
                "",
                ""
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in Figure19.    If the SPR field con",
                "tains a value from 808 through 811, the instruction ",
                "specifies a reserved SPR, and is treated as a no-op; ",
                "see Section1.3.3, \u201cReserved Fields, Reserved Values, ",
                "and Reserved SPRs\u201d in Book I.  Otherwise, the con",
                "tents of the designated Special Purpose Register are ",
                "placed into register RT. For Special Purpose Registers ",
                "that are 32 bits long, the low-order 32 bits of RT receive ",
                "the contents of the Special Purpose Register and the ",
                "high-order 32 bits of RT are set to zero.",
                "spr<sub>0</sub>=1 if and only if reading the register is privileged. ",
                "Execution of this instruction specifying an SPR number ",
                "with spr<sub>0</sub>=1 when the privilege state of the thread does ",
                "not permit the access causes one of the following.",
                "Execution of this instruction specifying an SPR number ",
                "that is not defined for the implementation causes one of ",
                "the following. ",
                "  "
            ]
        },
        {
            "description": "Move From Time Base",
            "form": "XFX-form",
            "category": "Time Base ",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "mftb",
                    "operands": [
                        "RT",
                        "TBR"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "tbr",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "371"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "mfsprRy,268# Ry = Time Base",
                "lwzRx,ticks_per_sec",
                "divduRz,Ry,Rx# Rz = whole seconds",
                "stwRz,posix_sec",
                "mulldRz,Rz,Rx# Rz = quotient * divisor",
                "subRz,Ry,Rz# Rz = excess ticks",
                "lwzRx,ns_adj",
                "slwiRz,Rz,1# Rz = 2 * excess ticks",
                "mulhwuRz,Rz,Rx# mul by (ns/tick)/2 * 2<sup>32</sup>",
                "stwRz,posix_ns# product[0:31] = excess ns"
            ],
            "body": [
                "[Phased-Out]",
                "This instruction behaves as if it were an mfspr instruc",
                "tion; see the mfspr instruction description in ",
                "Section3.3.20 of Book I.",
                "None",
                "Extended mnemonics for Move From Time Base: ",
                "  ",
                " ",
                " ",
                " ",
                " ",
                "",
                "Since the update frequency of the Time Base is imple",
                "mentation-dependent, the algorithm for converting the ",
                "current value in the Time Base to time of day is also ",
                "implementation-dependent.",
                "As an example, assume that the Time Base increments ",
                "at the constant rate of 512 MHz. (Note, however, that ",
                "programs should allow for the possibility that some ",
                "implementations may not increment the least-signifi",
                "cant 4 bits of the Time Base at a constant rate.) What is ",
                "wanted is the pair of 32-bit values comprising a POSIX ",
                "standard clock:  the number of whole seconds that ",
                "have passed since 00:00:00 January 1, 1970, UTC, ",
                "and the remaining fraction of a second expressed as a ",
                "number of nanoseconds.",
                "Assume that:",
                "When the processor is in 64-bit mode, The POSIX ",
                "clock can be computed with an instruction sequence ",
                "such as this:",
                "In a system in which the update frequency of the Time ",
                "Base may change over time, it is not possible to con",
                "vert an isolated Time Base value into time of day.  ",
                "Instead, a Time Base value has meaning only with ",
                "respect to the current update frequency and the time of ",
                "day that the update frequency was last changed.  Each ",
                "time the update frequency changes, either the system ",
                "software is notified of the change via an interrupt (see ",
                "Book III), or the change was instigated by the system ",
                "software itself.  At each such change, the system soft",
                "ware must compute the current time of day using the ",
                "old update frequency, compute a new value of ",
                "ticks_per_sec for the new frequency, and save the time ",
                "of day, Time Base value, and tick rate.  Subsequent ",
                "calls to compute Time of Day use the current Time ",
                "Base Value and the saved value.",
                "",
                ""
            ]
        },
        {
            "description": "Move From VSR Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrd",
                    "operands": [
                        "RA",
                        "XS"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "51"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.FP=0 then FP_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := VSR[32\u00d7SX+S].dword[0]"
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "The contents of doubleword element 0 of VSR[XS] are ",
                "placed into GPR[RA].",
                "For SX=0, mfvsrd is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For SX=1, mfvsrd is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move From VSR Double",
                "word:"
            ]
        },
        {
            "description": "Move From VSR Lower Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrld",
                    "operands": [
                        "RA",
                        "XS"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "307"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := VSR[32\u00d7SX+S].dword[1]"
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "The contents of doubleword 1 of VSR[XS] are placed ",
                "into GPR[RA].",
                "For SX=0, mfvsrld is treated as a VSX instruction in ",
                "terms of resource availability.",
                "For SX=1, mfvsrld is treated as a Vector instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Move From VSR Word and Zero",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrwz",
                    "operands": [
                        "RA",
                        "XS"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "115"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.FP=0 then FP_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := EXTZ64(VSR[32\u00d7SX+S].word[1])"
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "The contents of word element 1 of VSR[XS] are placed ",
                "into bits 32:63 of GPR[RA]. The contents of bits 0:31 of ",
                "GPR[RA] are set to 0.",
                "For SX=0, mfvsrwz is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For SX=1, mfvsrwz is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Move From Vector Status and Control Register",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mfvscr",
                    "operands": [
                        "VRT"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1540"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := EXTZ128(VSCR)"
            ],
            "body": [
                "The contents of the VSCR are placed into word ",
                "element 3 of VSR[VRT+32].",
                "The remaining word elements in VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Move To Condition Register Fields",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtcrf",
                    "operands": [
                        "FXM",
                        "RS"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "FXM",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "144"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "mask := <sup>4</sup>(FXM<sub>0</sub>) || <sup>4</sup>(FXM<sub>1</sub>) || ... <sup>4</sup>(FXM<sub>7</sub>)",
                "CR := ((RS)<sub>32:63</sub> &amp; mask) | (CR &amp; ~mask)"
            ],
            "body": [
                "The contents of bits 32:63 of register RS are placed into ",
                "the Condition Register under control of the field mask ",
                "specified by FXM. The field mask identifies the 4-bit ",
                "fields affected. Let i be an integer in the range 0-7. If ",
                "FXM<sub>i</sub><sub>=1</sub> then CR field i (CR bits 4\u00b4i+32:4\u00b4i+35) is set to ",
                "the contents of the corresponding field of the low-order ",
                "32 bits of RS.",
                "Example of extended mnemonics for Move To Condi",
                "tion Register Fields:"
            ]
        },
        {
            "description": "Move To FPSCR Bit 0",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtfsb0",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsb0.",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "70"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Bit BT+32 of the FPSCR is set to 0.",
                "  "
            ]
        },
        {
            "description": "Move To FPSCR Bit 1",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtfsb1",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsb1.",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "38"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Bit BT+32 of the FPSCR is set to 1.",
                "   ",
                ""
            ]
        },
        {
            "description": "Move To FPSCR Field Immediate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtfsfi",
                    "operands": [
                        "BF",
                        "U",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsfi.",
                    "operands": [
                        "BF",
                        "U",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "W",
                    "size": "1"
                },
                {
                    "name": "U",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "134"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The value of the U field is placed into FPSCR field ",
                "BF+8*(1-W).",
                "FX is altered only if BF=0 and W=0.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Move To FPSCR Fields",
            "form": "XFL-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtfsf",
                    "operands": [
                        "FLM",
                        "FRB",
                        "L",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsf.",
                    "operands": [
                        "FLM",
                        "FRB",
                        "L",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "FLM",
                    "size": "8"
                },
                {
                    "name": "W",
                    "size": "1"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "711"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The FPSCR is modified as specified by the FLM, L, and ",
                "W fields.",
                "L=0",
                "L=1",
                "FX is not altered implicitly by this instruction.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Move To Machine State Register",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "mtmsr",
                    "operands": [
                        "RS",
                        "L"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "146"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then",
                "   MSR<sub>48</sub> := (RS)<sub>48</sub> | (RS)<sub>49</sub>",
                "   MSR<sub>58</sub> := ((RS)<sub>58</sub> | (RS)<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~(RS)<sub>49</sub><sub>))</sub>",
                "   MSR<sub>59</sub> := ((RS)<sub>59</sub> | (RS)<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~(RS)<sub>49</sub><sub>))</sub>",
                "   MSR<sub>32:40 42:47 49:50 52:57 60:62</sub> ",
                "      :=(RS)<sub>32:40 42:47 49:50 52:57 60:62</sub>",
                "else",
                "   MSR<sub>48 62</sub> := (RS)<sub>48 62</sub>"
            ],
            "body": [
                "L=0:",
                "If L=0 this instruction is context synchronizing. If L=1 ",
                "this instruction is execution synchronizing; in addition, ",
                "the alterations of the EE and RI bits take effect as soon ",
                "as the instruction completes.",
                "Except in the mtmsr instruction description in this sec",
                "tion, references to \u201cmtmsr\u201d in this document imply ",
                "either L value unless otherwise stated or obvious from ",
                "context (e.g., a reference to an mtmsr instruction that ",
                "modifies an MSR bit other than the EE or RI bit implies ",
                "L=0).",
                " ",
                "  ",
                "  ",
                "  ",
                "  ",
                "  "
            ]
        },
        {
            "description": "Move To Machine State Register Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "mtmsrd",
                    "operands": [
                        "RS",
                        "L"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "178"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then",
                "",
                "",
                "",
                "",
                "",
                "   MSR<sub>48</sub> := (RS)<sub>48</sub> | (RS)<sub>49</sub> ",
                "   MSR<sub>58</sub> := ((RS)<sub>58</sub> | (RS)<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~(RS)<sub>49</sub><sub>))</sub>",
                "   MSR<sub>59</sub> := ((RS)<sub>59</sub> | (RS)<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~(RS)<sub>49</sub><sub>))</sub>",
                "",
                "",
                "else",
                "   MSR<sub>48 62</sub> := (RS)<sub>48 62</sub>"
            ],
            "body": [
                "The MSR is set based on the contents of register RS ",
                "and of the L field.",
                "L=0:",
                "L=1:",
                "This instruction is privileged.",
                "If L=0 this instruction is context synchronizing. If L=1 ",
                "this instruction is execution synchronizing; in addition, ",
                "the alterations of the EE and RI bits take effect as soon ",
                "as the instruction completes.",
                "Except in the mtmsrd instruction description in this ",
                "section, references to \u201cmtmsrd\u201d in this document imply ",
                "either L value unless otherwise stated or obvious from ",
                "context (e.g., a reference to an mtmsrd instruction that ",
                "modifies an MSR bit other than the EE or RI bit implies ",
                "L=0).",
                "  ",
                "  ",
                "  ",
                "  ",
                ""
            ]
        },
        {
            "description": "Move To One Condition Register Field",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtocrf",
                    "operands": [
                        "FXM",
                        "RS"
                    ],
                    "release": "v2.01"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "FXM",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "144"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "count := 0",
                "do i = 0 to 7",
                "   if FXM<sub>i</sub> = 1 then",
                "      n := i",
                "   count := count + 1",
                "if count = 1 then",
                "   CR<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub> := (RS)<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub>",
                "else",
                "   CR := undefined"
            ],
            "body": [
                "If exactly one bit of the FXM field is set to 1, let n be the ",
                "position of that bit in the field (0 \u00a3 n \u00a3 7). The contents ",
                "of bits 4\u00b4n+32:4\u00b4n+35 of register RS are placed into CR ",
                "field n (CR bits 4\u00b4n+32:4\u00b4n+35). Otherwise, the contents ",
                "of the Condition Register are undefined."
            ]
        },
        {
            "description": "Move To Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtspr",
                    "operands": [
                        "SPR",
                        "RS"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "spr",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "467"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "   case(13): see Book III",
                "   case(808, 809, 810, 811):",
                "   default:",
                "      if length(SPR(n)) = 64 then",
                "         SPR(n) := (RS)",
                "      else",
                "         SPR(n) := (RS)<sub>32:63</sub>"
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in the table below. If the SPR field ",
                "contains a value from 808 through 811, the instruction ",
                "specifies a reserved SPR, and is treated as a no-op;  ",
                "see Section1.3.3, \u201cReserved Fields, Reserved Values, ",
                "and Reserved SPRs\u201d.  Otherwise, unless the SPR field ",
                "contains 13 (denoting the AMR), the contents of register ",
                "RS are placed into the designated Special Purpose ",
                "Register. For Special Purpose Registers that are 32 ",
                "bits long, the low-order 32 bits of RS are placed into the ",
                "SPR. ",
                "The AMR (Authority Mask Register) is used for \u201cstor",
                "age protection.\u201d This use, and operation of mtspr for ",
                "the AMR, are described in Book III.",
                "If execution of this instruction is attempted specifying ",
                "an SPR number that is not shown above, one of the fol",
                "lowing occurs.",
                "A complete description of this instruction can be found ",
                "in Book III.",
                "Examples of extended mnemonics for Move To Special ",
                "Purpose Register:",
                "     ",
                "  ",
                " "
            ]
        },
        {
            "description": "Move To Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "mtspr",
                    "operands": [
                        "SPR",
                        "RS"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "spr",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "467"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "  case(13): if MSR<sub>HV PR</sub> = 0b10 then",
                "              SPR(13) := (RS)",
                "            else",
                "              if MSR<sub>HV PR</sub> = 0b00 then",
                "                 SPR(13) := ((RS) &amp; AMOR) |",
                "                           ((SPR(13)) &amp; ~AMOR)",
                "              else ",
                "                 SPR(13) := ((RS) &amp; UAMOR) |",
                "                            ((SPR(13)) &amp; ~UAMOR)",
                "  case(29,61):if MSR<sub>HV PR</sub> = 0b10 then",
                "              SPR(n) := (RS)",
                "            else ",
                "               SPR(n) := ((RS) &amp; AMOR) |",
                "                           ((SPR(n)) &amp; ~AMOR)",
                "  case (157): if MSR<sub>HV PR</sub> = 0b10 then ",
                "                SPR(157) := (RS)",
                "              else ",
                "                SPR(157) := (RS) &amp; AMOR",
                "  case (336):SPR(336) := (SPR(336)) &amp; (RS)",
                "  case (158, 808, 809, 810, 811):",
                "  default: if length(SPR(n)) = 64 then",
                "             SPR(n) := (RS)",
                "           else",
                "             SPR(n) := (RS)<sub>32:63</sub>",
                "",
                ""
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in Figure19.  If the SPR field con",
                "tains the value 158, the instruction is treated as a privi",
                "leged no-op.  If the SPR field contains a value from 808 ",
                "through 811, the instruction specifies a reserved SPR, ",
                "and is treated as a no-op;  see Section1.3.3, ",
                "\u201cReserved Fields, Reserved Values, and Reserved ",
                "SPRs\u201d in Book I.  Otherwise, the contents of register ",
                "RS are placed into the designated Special Purpose ",
                "Register, except as described in the next five para",
                "graphs. For Special Purpose Registers that are 32 bits ",
                "long, the low-order 32 bits of RS are placed into the ",
                "SPR.",
                "When the designated SPR is the Authority Mask Regis",
                "ter (AMR), (using SPR 13 or SPR 29), or the desig",
                "nated SPR is the Instruction Authority Mask Register ",
                "(IAMR), and MSR<sub>HV</sub><sub>PR</sub>=0b00, the contents of bit posi",
                "tions of register RS corresponding to 1 bits in the ",
                "Authority Mask Override Register (AMOR) are placed ",
                "into the corresponding bits of the AMR or IAMR, ",
                "respectively; the other AMR or IAMR bits are not modi",
                "fied.",
                "When the designated SPR is the AMR, using SPR 13, ",
                "and MSR<sub>PR</sub>=1, the contents of bit positions of register ",
                "RS corresponding to 1 bits in the User Authority Mask ",
                "Override Register (UAMOR) are placed into the corre",
                "sponding bits of the AMR; the other AMR bits are not ",
                "modified.",
                "When the designated SPR is the UAMOR and ",
                "MSR<sub>HV</sub><sub>PR</sub>=0b00, the contents of register RS are ",
                "ANDed with the contents of the AMOR and the result is ",
                "placed into the UAMOR.",
                "When the designated SPR is the Hypervisor Mainte",
                "nance Exception Register (HMER), the contents of reg",
                "ister RS are ANDed with the contents of the HMER and ",
                "the result is placed into the HMER.",
                "For this instruction, SPRs TBL and TBU are treated as ",
                "separate 32-bit registers; setting one leaves the other ",
                "unaltered.",
                "spr<sub>0</sub>=1 if and only if writing the register is privileged. ",
                "Execution of this instruction specifying an SPR number ",
                "with spr<sub>0</sub>=1 when the privilege state of the thread does ",
                "not permit the access causes one of the following.",
                "Execution of this instruction specifying an SPR number ",
                "that is undefined for the implementation causes one of ",
                "the following.",
                "",
                "  ",
                "  ",
                ""
            ]
        },
        {
            "description": "Move To VSR Byte Mask Immediate",
            "form": "DX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrbmi",
                    "operands": [
                        "VRT",
                        "bm"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "b1",
                    "size": "5"
                },
                {
                    "name": "b0",
                    "size": "10"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "10"
                },
                {
                    "name": "b2",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "bm.bit[0:9]   := b0",
                "bm.bit[10:14] := b1",
                "bm.bit[15]    := b2",
                "do i = 0 to 15",
                "   if bm.bit[i]=0 then",
                "      VSR[VRT+32].byte[i] := 0x00",
                "   else",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "end"
            ],
            "body": [
                "Let bm be the concatenation of b0, b1 and b2.",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Move To VSR Double Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrdd",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "435"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if RA=0 then",
                "   VSR[32\u00d7TX+T].dword[0] := 0x0000_0000_0000_0000",
                "else",
                "   VSR[32\u00d7TX+T].dword[0] := GPR[RA]",
                "",
                "VSR[32\u00d7TX+T].dword[1] := GPR[RB]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of GPR[RA], or the value 0 if RA=0, are ",
                "placed into doubleword 0 of  VSR[XT].",
                "The contents of GPR[RB] are placed into doubleword 1 ",
                "of  VSR[XT].",
                "For TX=0, mtvsrdd is treated as a VSX instruction in ",
                "terms of resource availability.",
                "For TX=1, mtvsrdd is treated as a Vector instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Move To VSR Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrd",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "179"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.FP=0 then FP_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].dword[0] := GPR[RA]",
                "VSR[32\u00d7TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of GPR[RA] are placed into doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "undefined.",
                "For TX=0, mtvsrd is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For TX=1, mtvsrd is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Doubleword:"
            ]
        },
        {
            "description": "Move To VSR Word & Splat",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrws",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "403"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].word[0] := GPR[RA].bit[32:63]",
                "VSR[32\u00d7TX+T].word[1] := GPR[RA].bit[32:63]",
                "VSR[32\u00d7TX+T].word[2] := GPR[RA].bit[32:63]",
                "VSR[32\u00d7TX+T].word[3] := GPR[RA].bit[32:63]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of bits 32:63 of GPR[RA] are placed into ",
                "each word element of  VSR[XT].",
                "For TX=0, mtvsrws is treated as a VSX instruction in ",
                "terms of resource availability.",
                "For TX=1, mtvsrws is treated as a Vector instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Move To VSR Word Algebraic",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwa",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "211"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.FP=0 then FP_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].dword[0] := EXTS64(GPR[RA].bit[32:63])",
                "VSR[32\u00d7TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The two\u2019s-complement integer in bits 32:63 of GPR[RA] ",
                "is sign-extended to 64 bits and placed into doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "undefined.",
                "For TX=0, mtvsrwa is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For TX=1, mtvsrwa is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Word Alge",
                "braic:"
            ]
        },
        {
            "description": "Move To VSR Word and Zero",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwz",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "243"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.FP=0 then FP_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].dword[0] := EXTZ64(GPR[RA].word[1])",
                "VSR[32\u00d7TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of bits 32:63 of GPR[RA] are placed into ",
                "word element 1 of VSR[XT]. The contents of word ",
                "element 0 of VSR[XT] are set to 0.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "undefined.",
                "For TX=0, mtvsrwz is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For TX=1, mtvsrwz is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Move To Vector Status and Control Register",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvscr",
                    "operands": [
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1604"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSCR := VSR[VRB+32].word[3]"
            ],
            "body": [
                "The contents of word element 3 of VSR[VRB+32] are ",
                "placed into the VSCR."
            ]
        },
        {
            "description": "Move to CR from XER Extended",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mcrxrx",
                    "operands": [
                        "BF"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "576"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>4\u00d7BF+32:4\u00d7BF+35</sub> := XER<sub>OV OV32 CA CA32</sub>"
            ],
            "body": [
                "The contents of the OV, OV32, CA, and CA32 are copied to ",
                "Condition Register field BF."
            ]
        },
        {
            "description": "Move to Condition Register from FPSCR",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mcrfs",
                    "operands": [
                        "BF",
                        "BFA"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "BFA",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "64"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The contents of FPSCR<sub>32:63</sub> field BFA are copied to Condi",
                "tion Register field BF. All exception bits copied are set to ",
                "0 in the FPSCR. If the FX bit is copied, it is set to 0 in ",
                "the FPSCR."
            ]
        },
        {
            "description": "Move to VSR Byte Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrbm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "16"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   if GPR[RB].bit[48+i]=0 then",
                "      VSR[VRT+32].byte[i] := 0x00",
                "   else",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 48:63 of GPR[RB].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Move to VSR Doubleword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrdm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "19"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   if GPR[RB].bit[62+i]=0 then",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "   else",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 62:63 of GPR[RB].",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Move to VSR Halfword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrhm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "17"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   if GPR[RB].bit[56+i]=0 then",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "   else",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 56:63 of GPR[RB].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Move to VSR Quadword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrqm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "20"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if GPR[RB].bit[63]=0 then",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "else",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF"
            ],
            "body": [
                "Let bm be the contents of bits 63 of GPR[RB].",
                "The contents of VSR[VRT+32] is set to all 0s if bm is ",
                "equal to 0.",
                "The contents of VSR[VRT+32] is set to all 1s if bm is ",
                "equal to 1."
            ]
        },
        {
            "description": "Move to VSR Word Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "18"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   if GPR[RB].bit[60+i]=0 then",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "   else",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 60:63 of GPR[RB].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Multiply High Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mulhd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhd.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "73"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The high-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply High Doubleword Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mulhdu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhdu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The high-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "Both operands and the product are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero."
            ]
        },
        {
            "description": "Multiply High Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mulhw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhw.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "75"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:63</sub> := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := prod<sub>0:31</sub>",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA and ",
                "of RB. The high-order 32 bits of the 64-bit product of the ",
                "operands are placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> ",
                "are undefined.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply High Word Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mulhwu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhwu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "11"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:63</sub> := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := prod<sub>0:31</sub>",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA and ",
                "of RB. The high-order 32 bits of the 64-bit product of the ",
                "operands are placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> ",
                "are undefined.",
                "Both operands and the product are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero."
            ]
        },
        {
            "description": "Multiply Low Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mulld",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulld.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulldo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulldo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "233"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>64:127</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The low-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "If OE=1 then OV and OV32 are set to 1 if the product can",
                "not be represented in 64 bits.",
                "Both operands and the product are interpreted as ",
                "signed integers.",
                "  "
            ]
        },
        {
            "description": "Multiply Low Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mulli",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "7"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * EXTS(SI)",
                "RT := prod<sub>64:127</sub>"
            ],
            "body": [
                "The 64-bit first operand is (RA). The 64-bit second ",
                "operand is the sign-extended value of the SI field. The ",
                "low-order 64 bits of the 128-bit product of the operands ",
                "are placed into register RT.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply Low Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "mullw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullw.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullwo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullwo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "235"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA and ",
                "of RB. The 64-bit product of the operands is placed into ",
                "register RT.",
                "If OE=1 then OV and OV32 are set to 1 if the product can",
                "not be represented in 32 bits.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply-Add High Doubleword",
            "form": "VA-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "maddhd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "RC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "48"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) \u00d7 (RB)",
                "sum<sub>0:127</sub>  := prod + EXTS(RC)",
                "RT := sum<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is added ",
                "to (RC). The high-order 64 bits of the 128-bit sum are ",
                "placed into register RT.",
                "All three operands and the result are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply-Add High Doubleword Unsigned",
            "form": "VA-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "maddhdu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "RC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "49"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) \u00d7 (RB)",
                "sum<sub>0:127</sub>  := prod + EXTZ(RC)",
                "RT := sum<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is added ",
                "to (RC). The high-order 64 bits of the 128-bit sum are ",
                "placed into register RT.",
                "All three operands and the result are interpreted as ",
                "unsigned integers."
            ]
        },
        {
            "description": "Multiply-Add Low Doubleword",
            "form": "VA-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "maddld",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "RC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "51"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) \u00d7 (RB)",
                "sum<sub>0:127</sub>  := prod + EXTS(RC)",
                "RT := sum<sub>64:127</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is added ",
                "to (RC). The low-order 64 bits of the 128-bit sum are ",
                "placed into register RT.",
                "All three operands and the result are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "NAND",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "nand",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nand.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "476"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := ~((RS) &amp; (RB))"
            ],
            "body": [
                "The contents of register RS are ANDed with the con",
                "tents of register RB and the complemented result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "NOR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "nor",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nor.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "124"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := ~((RS) | (RB))"
            ],
            "body": [
                "The contents of register RS are ORed with the contents ",
                "of register RB and the complemented result is placed ",
                "into register RA.",
                "Example of extended mnemonics for NOR:"
            ]
        },
        {
            "description": "Negate",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "neg",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "neg.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nego",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nego.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "104"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + 1"
            ],
            "body": [
                "The sum \u00ac(RA) + 1 is placed into register RT.",
                "If the processor is in 64-bit mode and register RA con",
                "tains the most negative 64-bit number ",
                "(0x8000_0000_0000_0000), the result is the most nega",
                "tive number and, if OE=1, OV is set to 1. If (RA)<sub>32:63</sub> con",
                "tain the most negative 32-bit number (0x8000_0000) and ",
                "OE=1, OV32 is set to 1.",
                "Similarly, if the processor is in 32-bit mode and ",
                "(RA)<sub>32:63</sub> contain the most negative 32-bit number ",
                "(0x8000_0000), the low-order 32 bits of the result contain ",
                "the most negative 32-bit number and, if OE=1, OV and ",
                "OV32 are set to 1. "
            ]
        },
        {
            "description": "Prefixed Nop",
            "form": "MRR:*-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pnop",
                    "operands": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "18",
                    "value": "0"
                },
                {
                    "name": "any value",
                    "size": "32"
                }
            ],
            "code": [],
            "body": [
                "Prefix:",
                "Suffix::",
                "No operation is performed.",
                "  ",
                "  ",
                "  ",
                " "
            ]
        },
        {
            "description": "OR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "or",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "or.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "444"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) | (RB)"
            ],
            "body": [
                "The contents of register RS are ORed with the contents ",
                "of register RB and the result is placed into register RA.",
                "Some forms of or Rx,Rx,Rx provide special functions; ",
                "see Section 3.2 and Section 4.3.3, both in Book II.",
                "Example of extended mnemonics for OR:"
            ]
        },
        {
            "description": "OR Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "ori",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "24"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) | (<sup>48</sup>0 || UI)",
                "ori   0,0,0"
            ],
            "body": [
                "The contents of register RS are ORed with 480||UI ",
                "and the result is placed into register RA.",
                "The preferred \u201cno-op\u201d (an instruction that does nothing) ",
                "is:",
                "Example of extended mnemonics for OR Immediate:",
                "  "
            ]
        },
        {
            "description": "OR Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "oris",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "25"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) | (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "The contents of register RS are ORed with ",
                "320||UI||160 and the result is placed into register ",
                "RA."
            ]
        },
        {
            "description": "OR with Complement ",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "orc",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "orc.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "412"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) | ~(RB)"
            ],
            "body": [
                "The contents of register RS are ORed with the comple",
                "ment of the contents of register RB and the result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "Parallel Bits Deposit Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pdepd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "156"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "result := 0",
                "mask := (RB)",
                "m := 0",
                "k := 0",
                "do while(m &lt; 64)",
                "   if(mask<sub>63-m</sub> == 1) then do",
                "      result<sub>63-m</sub> := (RS)<sub>63-k</sub>",
                "      k := k + 1",
                "   end",
                "   m := m + 1",
                "end",
                "RA := result"
            ],
            "body": [
                "Let mask be the contents of register RB.",
                "Let n be the number of bits in mask having the value 1.",
                "The contents of the rightmost n bits of register RS are ",
                "placed into register RA under control of mask as follows. ",
                "The contents of bits in register RA corresponding to bits ",
                "in mask that contain a 0 are set to 0."
            ]
        },
        {
            "description": "Parallel Bits Extract Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pextd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "188"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "result := 0",
                "mask := (RB)",
                "m := 0",
                "k := 0",
                "do while(m &lt; 64)",
                "   if((RB)<sub>63-m</sub> == 1) then do",
                "      result<sub>63-k</sub> := (RS)<sub>63-m</sub>",
                "      k := k + 1",
                "   end",
                "   m := m + 1",
                "end",
                "RA := result"
            ],
            "body": [
                "Let mask be the contents of register RB.",
                "The contents of the bits in register RS corresponding to ",
                "bits in mask containing a 1 are packed into an n-bit ",
                "value. The extracted value is placed into register RA."
            ]
        },
        {
            "description": "Parity Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "prtyd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "186"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "s := 0",
                "do i = 0 to 7",
                "   s := s ^ (RS)<sub>i</sub><sub>%</sub><sub>8+7</sub>",
                "RA := 630 || s"
            ],
            "body": [
                "The least significant bit in each byte of the contents of ",
                "register RS is examined. If there is an odd number of ",
                "one bits the value 1 is placed into register RA; otherwise ",
                "the value 0 is placed into register RA."
            ]
        },
        {
            "description": "Parity Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "prtyw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "154"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "s := 0",
                "t := 0",
                "do i = 0 to 3",
                "   s := s ^ (RS)<sub>i</sub><sub>%</sub><sub>8+7</sub>",
                "do i = 4 to 7",
                "   t := t ^ (RS)<sub>i</sub><sub>%</sub><sub>8+7</sub>",
                "RA<sub>0:31</sub> := 310 || s ",
                "RA<sub>32:63</sub> := 310 || t"
            ],
            "body": [
                "The least significant bit in each byte of (RS)<sub>0:31</sub> is ",
                "examined. If there is an odd number of one bits the ",
                "value 1 is placed into RA<sub>0:31</sub>; otherwise the value 0 is ",
                "placed into RA<sub>0:31</sub>. The least significant bit in each byte ",
                "of (RS)<sub>32:63</sub> is examined. If there is an odd number of ",
                "one bits the value 1 is placed into RA<sub>32:63</sub>; otherwise the ",
                "value 0 is placed into RA<sub>32:63</sub>.",
                "  ",
                "  ",
                ""
            ]
        },
        {
            "description": "Paste",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "paste.",
                    "operands": [
                        "RA",
                        "RB",
                        "L"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "902"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [
                "if there was a copy-paste sequence error or a ",
                "translation conflict",
                "  CR0:=0b000||XER<sub>SO</sub>",
                "else",
                "  if RA = 0 then b := 0",
                "  else           b := (RA)",
                "  EA := b +(RB)",
                "  if L=1 then",
                "    copy_buffer.md:=0  /* clear metadata in buffer",
                "  post(MEM(EA,128)||MEM<sub>metadata</sub>(EA,128)):=copy_buffer",
                "  wait for completion status",
                "  if there was a data transfer problem",
                "    CR0:=0b000||XER<sub>SO</sub>",
                "  else",
                "    CR0:=0b001||XER<sub>SO</sub>",
                "clear the state of the Copy-Paste Facility",
                "",
                ""
            ],
            "body": [
                "If there was a copy-paste sequence error or a transla",
                "tion conflict, set CR0 to indicate failure.  Otherwise, ",
                "continue as follows.",
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). ",
                "If L=1, then set metadata bits in the copy buffer to zero.",
                "The physical target of the operation, and by implication ",
                "the function to be performed, is determined by the real ",
                "address that is translated from EA.  If the real address ",
                "is in the platform\u2019s system memory, a simple copy is ",
                "performed.  If the real address has an associated map",
                "ping to another system, the copy buffer is transmitted to ",
                "the other system.  If the real address is control memory ",
                "for an accelerator, the contents of the copy buffer is ",
                "queued to the accelerator. There is a wait for comple",
                "tion status on the data transfer.  CR0 is set as follows ",
                "based on the completion status.",
                "",
                "The state of the Copy-Paste Facility is cleared.",
                "",
                "If MSR<sub>PR</sub>=1, paste. with L=0 is an invalid form.",
                "If the EA is not a multiple of 128, the system alignment ",
                "error handler is invoked.",
                "If the specified block is in storage that is Caching Inhib",
                "ited, the system data storage error handler is invoked.",
                "If the associated copy specified an accelerator or the ",
                "paste. specifies an accelerator that was not properly ",
                "configured, the data storage error handler will be ",
                "invoked.",
                "When successful, this instruction is treated as a Store ",
                "(see Section4.3, \u201cCache Management Instructions\u201d), ",
                "except that the data transfer ordering is described in ",
                "Section1.7.1.1, \u201cStorage Ordering of Copy/Paste-Initi",
                "ated Data Transfers\u201d.",
                "Extended mnemonic for paste.:"
            ]
        },
        {
            "description": "Population Count Bytes",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "popcntb",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "122"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 7",
                "   n := 0",
                "   do j = 0 to 7",
                "      if (RS)<sub>(i</sub>*<sub>8)+j</sub> = 1 then",
                "          n := n+1",
                "   RA<sub>(i</sub>*<sub>8):(i</sub>*<sub>8)+7</sub> := n"
            ],
            "body": [
                "A count of the number of one bits in each byte of regis",
                "ter RS is placed into the corresponding byte of register ",
                "RA. This number ranges from 0 to 8, inclusive."
            ]
        },
        {
            "description": "Population Count Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "popcntd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "506"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := 0",
                "do i = 0 to 63",
                "   if (RS)<sub>i</sub> = 1 then",
                "   n := n+1",
                "RA := n"
            ],
            "body": [
                "A count of the number of one bits in register RS is ",
                "placed into register RA. This number ranges from 0 to ",
                "64, inclusive."
            ]
        },
        {
            "description": "Population Count Words",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "popcntw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "378"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 1",
                "   n := 0",
                "   do j = 0 to 31",
                "      if (RS)<sub>(i</sub>*<sub>32)+j</sub> = 1 then",
                "          n := n+1",
                "   RA<sub>(i</sub>*<sub>32):(i</sub>*<sub>32)+31</sub> := n"
            ],
            "body": [
                "A count of the number of one bits in each word of regis",
                "ter RS is placed into the corresponding word of register ",
                "RA. This number ranges from 0 to 32, inclusive."
            ]
        },
        {
            "description": "Return From Interrupt Doubleword",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "rfid",
                    "operands": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "18"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "",
                "",
                "MSR<sub>51</sub> := (MSR<sub>3</sub> &amp; SRR1<sub>51</sub>) | ((~MSR<sub>3</sub>) &amp; MSR<sub>51</sub>)",
                "MSR3 := MSR<sub>3</sub> &amp; SRR1<sub>3 </sub>",
                "",
                "MSR<sub>48</sub> := SRR1<sub>48</sub> | SRR1<sub>49</sub> ",
                "MSR<sub>58</sub> := (CTR<sub>58</sub> | CTR<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~CTR<sub>49</sub><sub>))</sub>",
                "MSR<sub>59</sub> := (CTR<sub>59</sub> | CTR<sub>49)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~CTR<sub>49</sub><sub>))</sub>",
                "",
                "NIA :=<sub>iea</sub> SRR0<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "",
                "",
                "If MSR<sub>3</sub>=1 then ",
                "bits 3 and 51 of SRR1 are placed into the correspond",
                "ing bits of the MSR. ",
                "",
                "",
                " The result of ORing bits 48 and 49 ",
                "of SRR1 is placed into MSR<sub>48</sub>. The result of ANDing bit ",
                "41 of the MSR with bit 3 of the MSR and with the com",
                "plement of bit 49 of SRR1 is complemented and then ",
                "ANDed with the result of ORing bits 58 and 49 of SRR1 ",
                "and placed into MSR<sub>58</sub>. The result of ANDing bit 41 of ",
                "the MSR with bit 3 of the MSR and with the comple",
                "ment of bit 49 of SRR1 is complemented and then ",
                "ANDed with the result of ORing bits 59 and 49 of SRR1 ",
                "and placed into MSR<sub>59</sub>. ",
                "",
                "",
                "If  the new MSR value does not enable any pending ",
                "exceptions, then the next instruction is fetched, under ",
                "control of the new MSR value, from the address ",
                "SRR0<sub>0:61</sub> || 0b00 (when SF=1 in the new MSR value) ",
                "or <sup>32</sup>0 || SRR0<sub>32:61</sub> || 0b00 (when SF=0 in the new MSR ",
                "value). If the new MSR value enables one or more ",
                "pending exceptions, the interrupt associated with the ",
                "highest priority pending exception is generated; in this ",
                "case the value placed into SRR0, HSRR0, or USRR0 ",
                "by the interrupt processing mechanism (see Section ",
                "7.4.3) is the address of the instruction that would have ",
                "been executed next had the interrupt not occurred.",
                "This instruction is privileged and context synchronizing.",
                "  "
            ]
        },
        {
            "description": "Return From System Call Vectored",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "rfscv",
                    "operands": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "82"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "MSR<sub>48</sub> := CTR<sub>48</sub> | CTR<sub>49</sub> ",
                "MSR<sub>58</sub> := (CTR<sub>58</sub> | CTR<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~CTR<sub>49</sub><sub>))</sub>",
                "MSR<sub>59</sub> := (CTR<sub>59</sub> | CTR<sub>49)</sub>",
                "<sub>    &amp; </sub>~(MSR<sub>41 </sub><sub>&amp; MSR</sub><sub>3 </sub><sub>&amp; (</sub>~CTR<sub>49</sub><sub>))</sub>",
                "",
                "NIA :=<sub>iea</sub> LR<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "I",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                " ",
                "The result of ORing bits 48 and 49 of the Count Regis",
                "ter is placed into MSR<sub>48</sub>. The result of ANDing bit 41 of ",
                "the MSR with bit 3 of the MSR and with the comple",
                "ment of bit 49 of the Count Register is complemented ",
                "and then ANDed with the result of ORing bits 58 and 49 ",
                "of the Count Register and placed into MSR<sub>58</sub>. The ",
                "result of ANDing bit 41 of the MSR with bit 3 of the ",
                "MSR and with the complement of bit 49 of the Count ",
                "Register is complemented and then ANDed with the ",
                "result of ORing bits 59 and 49 of the Count Register ",
                "and placed into MSR<sub>59</sub>. ",
                "",
                "",
                "If the new MSR value does not enable any pending ",
                "exceptions, then the next instruction is fetched, under ",
                "control of the new MSR value, from the address LR<sub>0:61</sub> ",
                "|| 0b00 (when SF=1 in the new MSR value) or <sup>32</sup>0 || ",
                "LR<sub>32:61</sub> || 0b00 (when SF=0 in the new MSR value). If ",
                "the new MSR value enables one or more pending ",
                "exceptions, the interrupt associated with the highest ",
                "priority pending exception is generated; in this case the ",
                "value placed into SRR0, HSRR0, or USRR0 by the ",
                "interrupt processing mechanism (see Section 7.4.3) is ",
                "the address of the instruction that would have been ",
                "executed next had the interrupt not occurred.",
                "This instruction is privileged and context synchronizing.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Return from Event-Based Branch",
            "form": "XL-form",
            "category": "Event-Based Branch Facility ",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "rfebbS",
                    "operands": [],
                    "release": ""
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "S",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "146"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "BESCR<sub>GE</sub> := S",
                "NIA :=<sub>iea</sub> EBBRR<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "BESCR<sub>GE</sub> is set to S.",
                "If there are no pending event-based exceptions, then ",
                "the next instruction is fetched from the address ",
                "EBBRR<sub>0:61</sub> || 0b00 (when MSR<sub>SF</sub>=1) or <sup>32</sup>0 || ",
                "EBBRR<sub>32:61</sub> || 0b00 (when MSR<sub>SF</sub>=0). If one or more ",
                "pending event-based exceptions exist, an event-based ",
                "branch is generated; in this case the value placed into ",
                "EBBRR by the Event-Based Branch facility is the ",
                "address of the instruction that would have been exe",
                "cuted next had the event-based branch not occurred.",
                "If BESCR<sub>32:33</sub>\u00b90b00 the instruction is treated as if the ",
                "instruction form were invalid.",
                "See Section4.4 of Book III for additional information ",
                "about this instruction.",
                "BESCR",
                "MSR (See Book III)",
                "  ",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rldic",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldic.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "30"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh",
                    "size": "5"
                },
                {
                    "name": "mb",
                    "size": "6"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "2"
                },
                {
                    "name": "sh",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, ~n)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63-SH and 0-bits elsewhere. The rotated data are ",
                "ANDed with the generated mask and the result is ",
                "placed into register RA.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear Left",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rldicl",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldicl.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "30"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh",
                    "size": "5"
                },
                {
                    "name": "mb",
                    "size": "6"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "0"
                },
                {
                    "name": "sh",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, 63)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63 and 0-bits elsewhere. The rotated data are ANDed ",
                "with the generated mask and the result is placed into ",
                "register RA.",
                "Examples of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear Left:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear Right",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rldicr",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldicr.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "30"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh",
                    "size": "5"
                },
                {
                    "name": "me",
                    "size": "6"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "1"
                },
                {
                    "name": "sh",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "e := me<sub>5</sub> || me<sub>0:4</sub>",
                "m := MASK(0, e)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit 0 through bit ",
                "ME and 0-bits elsewhere. The rotated data are ANDed ",
                "with the generated mask and the result is placed into ",
                "register RA.",
                "Examples of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear Right:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Mask Insert",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rldimi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldimi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "30"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh",
                    "size": "5"
                },
                {
                    "name": "mb",
                    "size": "6"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "3"
                },
                {
                    "name": "sh",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, ~n)",
                "RA := r&amp;m | (RA) &amp; ~m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63-SH and 0-bits elsewhere. The rotated data are ",
                "inserted into register RA under control of the generated ",
                "mask.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Mask Insert:",
                "  ",
                "The instructions in this section perform left and right ",
                "shifts.",
                "Immediate-form logical (unsigned) shift operations are ",
                "obtained by specifying appropriate masks and shift val",
                "ues for certain Rotate instructions. A set of extended ",
                "mnemonics is provided to make coding of such shifts ",
                "simpler and easier to understand. Some of these are ",
                "shown as examples with the Rotate instructions. See ",
                "AppendixC, \u201cAssembler Extended Mnemonics\u201d on ",
                "page1025 for additional extended mnemonics."
            ]
        },
        {
            "description": "Rotate Left Doubleword then Clear Left",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rldcl",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldcl.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "30"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "mb",
                    "size": "6"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, 63)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left the num",
                "ber of bits specified by (RB)<sub>58:63</sub>. A mask is generated ",
                "having 1-bits from bit MB through bit 63 and 0-bits else",
                "where. The rotated data are ANDed with the generated ",
                "mask and the result is placed into register RA.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword then Clear Left:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword then Clear Right",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rldcr",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldcr.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "30"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "me",
                    "size": "6"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "e := me<sub>5</sub> || me<sub>0:4</sub>",
                "m := MASK(0, e)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left the num",
                "ber of bits specified by (RB)<sub>58:63</sub>. A mask is generated ",
                "having 1-bits from bit 0 through bit ME and 0-bits else",
                "where. The rotated data are ANDed with the generated ",
                "mask and the result is placed into register RA.",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word Immediate then AND with Mask",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rlwinm",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwinm.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "21"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "MB",
                    "size": "5"
                },
                {
                    "name": "ME",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>32</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB+32 through ",
                "bit ME+32 and 0-bits elsewhere. The rotated data are ",
                "ANDed with the generated mask and the result is ",
                "placed into register RA.",
                "Examples of extended mnemonics for Rotate Left Word ",
                "Immediate then AND with Mask:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word Immediate then Mask Insert",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rlwimi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwimi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "20"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "MB",
                    "size": "5"
                },
                {
                    "name": "ME",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r&amp;m | (RA) &amp; ~m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>32</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB+32 through ",
                "bit ME+32 and 0-bits elsewhere. The rotated data are ",
                "inserted into register RA under control of the generated ",
                "mask.",
                "Example of extended mnemonics for Rotate Left Word ",
                "Immediate then Mask Insert:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word then AND with Mask",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "rlwnm",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwnm.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "23"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "MB",
                    "size": "5"
                },
                {
                    "name": "ME",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>32</sub> left the num",
                "ber of bits specified by (RB)<sub>59:63</sub>. A mask is generated ",
                "having 1-bits from bit MB+32 through bit ME+32 and 0-bits ",
                "elsewhere. The rotated data are ANDed with the gener",
                "ated mask and the result is placed into register RA.",
                "Example of extended mnemonics for Rotate Left Word ",
                "then AND with Mask:",
                "  "
            ]
        },
        {
            "description": "SLB Find Entry ESID",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbfee.",
                    "operands": [
                        "RT",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "979"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [],
            "body": [
                "The SLB is searched for an entry that matches the ",
                "effective address specified by register RB.  When ",
                "LPCR<sub>UPRT</sub>=1, this instruction is nonfunctional.  The ",
                "search is performed as if it were being performed for ",
                "purposes of address translation. That is, in order for a ",
                "given entry to satisfy the search, the entry must be ",
                "valid (V=1), (RB)<sub>0:63-s</sub> must equal SLBE[ESID<sub>0:63-s</sub>] ",
                "(where 2s is the segment size selected by the B field in ",
                "the entry). If exactly ",
                "one matching entry is found, the contents of the B, ",
                "VSID, K<sub>s</sub>, K<sub>p</sub>, N, L, C, and LP fields of the entry are ",
                "placed into register RT. If no matching entry is found, ",
                "register RT is set to 0. If more than one matching entry ",
                "is found, either one of the matching entries is used, as ",
                "if it were the only matching entry, or a Machine Check ",
                "occurs. If a Machine Check occurs, register RT, CR ",
                "Field 0 are set to ",
                "undefined values, and the description below of how this ",
                "register and set does not apply.",
                "The contents of registers RT and RB are interpreted as ",
                "shown in Figure55.",
                "RT",
                "RB",
                "RT<sub>0:1</sub>B",
                "RT<sub>2:51</sub>VSID",
                "RT<sub>52</sub>K<sub>s</sub>",
                "RT<sub>53</sub>K<sub>p</sub>",
                "RT<sub>54</sub>N",
                "RT<sub>55</sub>L",
                "RT<sub>56</sub>C",
                "RT<sub>57</sub>",
                "RT<sub>58:59</sub>LP",
                "RT<sub>60:63</sub>set to 0b0000",
                "RB<sub>0:35</sub>ESID",
                "",
                "",
                "",
                "If s &gt; 28, RT<sub>80-s:51</sub> are set to zeros. On implementa",
                "tions that support a virtual address size of only n bits, n ",
                "&lt; 78, RT<sub>2:79-n</sub> are set to zeros.",
                "CR Field 0 set ",
                "as follows. j is a 1-bit value that is equal to 0b1 if a ",
                "matching entry was found. Otherwise, j is 0b0.  When ",
                "LPCR<sub>UPRT</sub>\u00b90,  j=0b0.",
                "The hardware ignores the contents of RB<sub>36:38 40:63</sub>.",
                "If this instruction is executed in 32-bit mode, (RB)<sub>0:31</sub> ",
                "must be zeros (i.e., the ESID must be in the range ",
                "0-15).",
                "This instruction is privileged.",
                "  ",
                "  "
            ]
        },
        {
            "description": "SLB Invalidate All",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbia",
                    "operands": [
                        "IH"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "IH",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "498"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "switch (IH)",
                "  case (0b000, 0b001, 0b010, 0b110):",
                "    for each SLB entry except SLB entry 0",
                "     SLBE<sub>V</sub> := 0",
                "     all other fields of SLBE := undefined",
                "  case (0b011):",
                "    for each SLB entry such that SLBE<sub>Class </sub>= 1",
                "      SLBE<sub>V</sub> := 0",
                "      all other fields of SLBE := undefined",
                "  case (0b100):",
                "    for each SLB entry",
                "     SLBE<sub>V</sub> := 0",
                "     all other fields of SLBE := undefined",
                "  case (0b111):"
            ],
            "body": [
                "slbia invalidates the contents of the SLB, and of imple",
                "mentation-specific lookaside information for effective to ",
                "real address translations, based on the contents of the ",
                "IH field as described below.  SLB entries are invali",
                "dated by setting the V bit in the entry to 0.  When an ",
                "SLB entry is invalidated, the remaining fields of the ",
                "entry are set to undefined values.  ",
                "In the description of the IH values, \u201cimplementa",
                "tion-specific lookaside information\u201d is shorthand for ",
                "\u201cimplementation-specific lookaside information for ",
                "effective to real address translations,\u201d and \u201cwhen ",
                "address translation was enabled\u201d is shorthand for ",
                "\u201cwhen MSR<sub>IR</sub> was equal to 1 or MSR<sub>DR</sub> was equal to 1, ",
                "as appropriate for the type of access,\u201d and correspond",
                "ingly for \u201cwhen address translation was disabled.\u201d  The ",
                "descriptions specify which entries must be invalidated; ",
                "additional entries may be invalidated except where the ",
                "description states that certain SLB entries are not inval",
                "idated.",
                "0b000All SLB entries except entry 0 are invalidated; ",
                "SLB entry 0 is not invalidated.  ",
                "All implementation-specific lookaside informa",
                "tion is invalidated. ",
                "0b001All SLB entries except entry 0 are invalidated; ",
                "SLB entry 0 is not invalidated.  ",
                "All implementation-specific lookaside informa",
                "tion that was created when address transla",
                "tion was enabled and satisfies either of the ",
                "following conditions is invalidated.",
                "0b010All SLB entries except entry 0 are invalidated; ",
                "SLB entry 0 is not invalidated.  ",
                "All implementation-specific lookaside informa",
                "tion that was created when address transla",
                "tion was enabled is invalidated.",
                "0b011All SLB entries having a Class value of 1 are ",
                "invalidated; SLB entry 0 is not invalidated if it ",
                "has a Class value of 0.  ",
                "All implementation-specific lookaside informa",
                "tion that was created when address transla",
                "tion was enabled and satisfies either of the ",
                "following conditions is invalidated.",
                "0b100All SLB entries are invalidated.  ",
                "All implementation-specific lookaside informa",
                "tion is invalidated.",
                "0b110All SLB entries except entry 0 are invalidated; ",
                "SLB entry 0 is not invalidated.  ",
                "All implementation-specific lookaside informa",
                "tion that satisfies any of the following condi",
                "tions is invalidated.",
                "0b111No SLB entries are invalidated.  ",
                "All implementation-specific lookaside informa",
                "tion is invalidated.",
                " ",
                "All other IH values are reserved. If the IH field contains ",
                "a reserved value, the set of SLB entries and implemen",
                "tation-specific lookaside information that is invalidated ",
                "by the instruction is undefined.",
                "  ",
                "When IH=0b000, 0b100, or 0b111, execution of this ",
                "instruction has the side effect of clearing the storage ",
                "access history associated with the Hypervisor Real ",
                "Mode Storage Control facility. See Section6.7.3.2.1, ",
                "\u201cHypervisor Real Mode Storage Control\u201d for more ",
                "details.",
                "This instruction terminates any Segment Table walks ",
                "being performed on behalf of the thread that executes ",
                "it, and ensures that any new table walks will be per",
                "formed using the current PIDR value.",
                "This instruction is privileged.",
                "  ",
                "  ",
                "  ",
                " ",
                "",
                " ",
                "",
                " "
            ]
        },
        {
            "description": "SLB Invalidate All Global",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbiag",
                    "operands": [
                        "RS",
                        "L"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "850"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L=0 then target_PID = RS<sub>0:31</sub>",
                "if MSR<sub>HV</sub>=1 then target_LPID = RS<sub>32:63</sub>",
                "else target_LPID = LPIDR",
                "for each nest SLB",
                "  for each SLBE with LPID=target_LPID and",
                "                      (PID=target_PID | L=1)",
                "    SLBE<sub>V</sub><sub> </sub>:= 0",
                "    all other fields of SLBE := undefined",
                ""
            ],
            "body": [
                "The operation performed by this instruction is based on ",
                "the contents of register RS. The contents of this regis",
                "ter is shown below.",
                "RS",
                "RS<sub>0:31</sub>PID",
                "RS<sub>32:63</sub>LPID",
                "",
                "If L=0, let the target PID be RS<sub>0:31</sub>.  If the instruction is ",
                "executed in hypervisor state, let the target LPID be ",
                "RS<sub>32:63</sub>; otherwise let the target LPID be the contents ",
                "of LPIDR.  ",
                "All nest SLBs are searched.  If L=0, each SLBE for pro",
                "cess PID in partition LPID is invalidated.  If L=1, each ",
                "SLBE for partition LPID is invalidated.",
                "SLB entries are invalidated by setting the V bit in the ",
                "entry to 0, and the remaining fields of the entry are set ",
                "to undefined values.",
                "All implementation specific lookaside information asso",
                "ciated with SLB-derived translations for the target LPID ",
                "|| PID (L=0) or for the target LPID (L=1) is invalidated.  ",
                "Additional implementation specific lookaside informa",
                "tion may be invalidated. ",
                "The operation performed by this instruction is ordered ",
                "by the eieio (or [p]hwsync or ptesync) instruction with ",
                "respect to a subsequent slbsync instruction executed ",
                "by the thread executing the slbiag instruction. The ",
                "operations caused by slbiag and slbsync are ordered ",
                "by eieio as a fifth set of operations, which is indepen",
                "dent of the other four sets that eieio orders. ",
                "This instruction is privileged except when LPCR<sub>G</sub>",
                "TSE=0, making it hypervisor privileged.",
                "  ",
                "  ",
                " ",
                " ",
                ""
            ]
        },
        {
            "description": "SLB Invalidate Entry",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbie",
                    "operands": [
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "434"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "ea<sub>0:35</sub> := (RB)<sub>0:35</sub>",
                "if, for SLB entry that translates ",
                "  or most recently translated ea,",
                "    entry_class = (RB)<sub>36 </sub>and     ",
                "",
                "    entry_seg_size = size specified in (RB)<sub>37:38</sub>",
                "then for SLB entry (if any) that translates ea",
                "  SLBE<sub>V</sub><sub> </sub>:= 0",
                "  all other fields of SLBE := undefined",
                "else ",
                "   s := log_base_2(entry_seg_size)",
                "   esid := (RB)<sub>0:63-s</sub> ",
                "   u := undefined 1-bit value",
                "   if u then",
                "  if an SLB entry translates esid",
                "      SLBE<sub>V</sub><sub> </sub>:= 0",
                "        all other fields of SLBE := undefined"
            ],
            "body": [
                "The operation performed by this instruction is based on ",
                "the contents of register RB. The contents of this regis",
                "ter  shown below.",
                "RB",
                "RS<sub>0:31</sub>PID",
                "RS<sub>32:63</sub>LPID",
                "RB<sub>0:35</sub>ESID",
                "RB<sub>36</sub>Class",
                "RB<sub>37:38</sub>B",
                "",
                "",
                "Let the Effective Address (EA) be any EA for which ",
                "EA<sub>0:35</sub> = (RB)<sub>0:35</sub>.  Let the class be (RB)<sub>36</sub>.  ",
                " Let the segment size be equal to the ",
                "segment size specified in (RB)<sub>37:38</sub>; the allowed values ",
                "of (RB)<sub>37:38</sub>, and the correspondence between the val",
                "ues and the segment size, are the same as for the B ",
                "field in the SLBE (see Figure29 on page1218).",
                "The class value and segment size must be ",
                "the same as the class value and segment ",
                "size in the SLB entry that translates the EA, or the val",
                "ues that were in the SLB entry that most recently trans",
                "lated the EA if the translation is no longer in the SLB; if ",
                "these values are not the same, it is implementa",
                "tion-dependent whether the SLB entry (or implementa",
                "tion-dependent translation information) that translates ",
                "the EA is invalidated, and the next paragraph need not ",
                "apply.",
                "If the SLB contains only a single entry that translates ",
                "the EA, then that is the only SLB entry that is invali",
                "dated, except that it is implementation-dependent ",
                "whether an implementation-specific lookaside entry for ",
                "a real mode address \u201ctranslation\u201d is invalidated. If the ",
                "SLB contains more than one such entry, then zero or ",
                "more such entries are invalidated, and similarly for any ",
                "implementation-specific lookaside information used in ",
                "address translation; additionally, a machine check may ",
                "occur.",
                "SLB entries are invalidated by setting the V bit in the ",
                "entry to 0, and the remaining fields of the entry are set ",
                "to undefined values.",
                "This instruction terminates any Segment Table walks ",
                "being performed on behalf of the thread that executes ",
                "it.",
                "The hardware ignores the contents of RB listed below ",
                "and software must set them to 0s.",
                "If this instruction is executed in 32-bit mode, (RB)<sub>0:31</sub> ",
                "must be zeros.",
                "This instruction is privileged.",
                "  ",
                "   ",
                " ",
                "  ",
                "  ",
                " ",
                " "
            ]
        },
        {
            "description": "SLB Invalidate Entry Global",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbieg",
                    "operands": [
                        "RS",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "466"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "target_PID = RS<sub>0:31</sub>",
                "if MSR<sub>HV</sub>=1 then target_LPID = RS<sub>32:63</sub>",
                "else target_LPID = LPIDR",
                "ea<sub>0:35</sub> := (RB)<sub>0:35</sub>",
                "for each thread with LPIDR=target_LPID and",
                "                      PIDR=target_PID",
                "  if, for each SLB entry that",
                "  translates or most recently translated ea",
                "    entry_class = (RB)<sub>36 </sub>and",
                "",
                "    entry_seg_size = size specified in (RB)<sub>37:38</sub>",
                "  then for SLB entry (if any)",
                "  that translates ea and is not software-created",
                "    SLBE<sub>V</sub><sub> </sub>:= 0",
                "    all other fields of SLBE := undefined",
                "  else ",
                "     s := log_base_2(entry_seg_size)",
                "     esid := (RB)<sub>0:63-s</sub> ",
                "     u := undefined 1-bit value",
                "     if u then",
                "    if an SLB entry translates esid and the entry",
                "            is not software-created",
                "        SLBE<sub>V</sub><sub> </sub>:= 0",
                "          all other fields of SLBE := undefined",
                ""
            ],
            "body": [
                "The operation performed by this instruction is based on ",
                "the contents of registers RS and RB. The contents of ",
                "these registers are shown below.",
                "RS",
                "RB",
                "RS<sub>0:31</sub>PID",
                "RS<sub>32:63</sub>LPID",
                "RB<sub>0:35</sub>ESID",
                "RB<sub>36</sub>Class",
                "RB<sub>37:38</sub>B",
                "",
                "",
                "",
                "Let the target PID be RS<sub>0:31</sub>.  If the instruction is exe",
                "cuted in hypervisor state, let the target LPID be ",
                "RS<sub>32:63</sub>; otherwise let the target LPID be the contents ",
                "of LPIDR.  Let the Effective Address (EA) be any EA for ",
                "which EA<sub>0:35</sub> = (RB)<sub>0:35</sub>.  Let the class be (RB)<sub>36</sub>.  ",
                " Let the segment size be equal ",
                "to the segment size specified in (RB)<sub>37:38</sub>; the allowed ",
                "values of (RB)<sub>37:38</sub>, and the correspondence between ",
                "the values and the segment size, are the same as for ",
                "the B field in the SLBE (see Figure29 on page1218).",
                "Only SLBs for threads running on behalf of target_LPID ",
                "and target_PID are searched.  Software-created ",
                "entries are not invalidated.  The class value ",
                "and segment size must be the same as the class value",
                " and segment size in the SLB entry that trans",
                "lates the EA, or the values that were in the SLB entry ",
                "that most recently translated the EA if the translation is ",
                "no longer in the SLB; if these values are not the same, ",
                "it is implementation-dependent whether the SLB entry ",
                "(or implementation-dependent translation information) ",
                "that translates the EA is invalidated, and the next para",
                "graph need not apply.",
                "If the SLB contains only a single entry that translates ",
                "the EA, then that is the only SLB entry that is invali",
                "dated, except that it is implementation-dependent ",
                "whether an implementation-specific lookaside entry for ",
                "a real mode address \u201ctranslation\u201d is invalidated.  If the ",
                "SLB contains more than one such entry, then zero or ",
                "more such entries are invalidated, and similarly for any ",
                "implementation-specific lookaside information used in ",
                "address translation; additionally, a machine check may ",
                "occur.",
                "SLB entries are invalidated by setting the V bit in the ",
                "entry to 0, and the remaining fields of the entry are set ",
                "to undefined values.",
                "The hardware ignores the contents of RB listed below ",
                "and software must set them to 0s.",
                "If this instruction is executed in 32-bit mode, (RB)<sub>0:31</sub> ",
                "must be zeros.",
                "The operation performed by this instruction is ordered ",
                "by the eieio (or [p]hwsync or ptesync) instruction with ",
                "respect to a subsequent slbsync instruction executed ",
                "by the thread executing the slbieg instruction. The ",
                "operations caused by slbieg and slbsync are ordered ",
                "by eieio as a fifth set of operations, which is indepen",
                "dent of the other four sets that eieio orders. ",
                "This instruction is privileged except when LPCR<sub>G</sub>",
                "TSE=0, making it hypervisor privileged.",
                "  ",
                "   ",
                " ",
                " ",
                "  ",
                " ",
                " "
            ]
        },
        {
            "description": "SLB Move From Entry ESID",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbmfee",
                    "operands": [
                        "RT",
                        "RB"
                    ],
                    "release": "v2.00"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "915"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "This instruction is used to read software-loaded SLB ",
                "entries.  When LPCR<sub>UPRT</sub>=0, the entry is specified by ",
                "bits 52:63 of register RB.  When LPCR<sub>UPRT</sub>=1, only the ",
                "first four entries can be read, so bits 52:61 of register ",
                "RB are ignored.  If the specified entry is valid (V=1), the ",
                "contents of the ESID and V fields of the entry are ",
                "placed into register RT.  If LPCR<sub>UPRT</sub>=1, the value of ",
                "the BO field of the entry is also placed into register RT. ",
                "The contents of these registers are interpreted as ",
                "shown in Figure54.",
                "RT ",
                "RB",
                "If the SLB entry specified by bits 52:63 of register RB is ",
                "invalid (V=0), the contents of register RT are set to 0.",
                "High-order bits of (RB)<sub>52:63</sub> that correspond to SLB ",
                "entries beyond the size of the SLB provided by the ",
                "implementation must be zeros.",
                "The hardware ignores the contents of RB<sub>0:51</sub>.",
                "This instruction is privileged.",
                "The use of the L field is implementation specific.",
                " "
            ]
        },
        {
            "description": "SLB Move From Entry VSID",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbmfev",
                    "operands": [
                        "RT",
                        "RB"
                    ],
                    "release": "v2.00"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "851"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "This instruction is used to read software-loaded SLB ",
                "entries.  When LPCR<sub>UPRT</sub>=0, the entry is specified by ",
                "bits 52:63 of register RB.  When LPCR<sub>UPRT</sub>=1, only the ",
                "first four entries can be read, so bits 52:61 of register ",
                "RB are ignored.  If the specified entry is valid (V=1), the ",
                "contents of the B, VSID, K<sub>s</sub>, K<sub>p</sub>, N, L, C,  and LP ",
                "fields of the entry are placed into register RT. The con",
                "tents of these registers are interpreted as shown in ",
                "Figure53.",
                "RT",
                "RB",
                "On implementations that support a virtual address size ",
                "of only n bits, n&lt;78, RT<sub>2:79-n</sub> are set to zeros.",
                "If the SLB entry specified by bits 52:63 of register RB is ",
                "invalid (V=0), the contents of register RT are set to 0.",
                "High-order bits of (RB)<sub>52:63</sub> that correspond to SLB ",
                "entries beyond the size of the SLB provided by the ",
                "implementation must be zeros.",
                "The hardware ignores the contents of RB<sub>0:51</sub>.",
                "This instruction is privileged.",
                "The use of the L field is implementation specific."
            ]
        },
        {
            "description": "SLB Move To Entry",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbmte",
                    "operands": [
                        "RS",
                        "RB"
                    ],
                    "release": "v2.00"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "402"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "When LPCR<sub>UPRT</sub>=0, this instruction is the sole means ",
                "for specifying Segment translations to the hardware.  ",
                "When LPCR<sub>UPRT</sub>=1, Segment Table walks populate ",
                "the SLB, and this instruction is used only to bolt ",
                "thread-specific Segment translations.",
                "The SLB entry specified by bits 52:63 of register RB is ",
                "loaded from register RS and from the remainder of reg",
                "ister RB. The contents of these registers are inter",
                "preted as shown in Figure52.",
                "RS",
                "RB",
                "RS<sub>0:1</sub>B",
                "RS<sub>2:51</sub>VSID",
                "RS<sub>52</sub>K<sub>s</sub>",
                "RS<sub>53</sub>K<sub>p</sub>",
                "RS<sub>54</sub>N",
                "RS<sub>55</sub>L",
                "RS<sub>56</sub>C",
                "",
                "RS<sub>58:59</sub>LP",
                "RS<sub>60:63</sub>must be 0b0000",
                "RB<sub>0:35</sub>ESID",
                "RB<sub>36</sub>V",
                "RB<sub>37:51</sub>must be 0b000 || 0x000",
                "RB<sub>52:63</sub>index, which selects the SLB entry",
                "On implementations that support a virtual address size ",
                "of only n bits, n&lt;78, (RS)<sub>2:79-n</sub> must be zeros.",
                "When LPCR<sub>UPRT</sub>=1, the value of index must not ",
                "exceed 3.  (RB)<sub>52:61</sub> are ignored.",
                "High-order bits of (RB)<sub>52:63</sub> that correspond to SLB ",
                "entries beyond the size of the SLB provided by the ",
                "implementation must be zeros.",
                "The hardware ignores the contents of RS and RB listed ",
                "below and software must set them to 0s.",
                "If this instruction is executed in 32-bit mode, (RB)<sub>0:31</sub> ",
                "must be zeros (i.e., the ESID must be in the range 0:15).",
                "This instruction must not be used to load a segment ",
                "descriptor that is in the Segment Table when ",
                "LPCR<sub>UPRT</sub>=1, and cannot be used  to invalidate the ",
                "translation contained in an SLB entry.",
                "This instruction is privileged.",
                "  ",
                "  ",
                ""
            ]
        },
        {
            "description": "SLB Synchronize",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "slbsync",
                    "operands": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "338"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The slbsync instruction provides an ordering function ",
                "for the effects of all slbieg and slbiag instructions exe",
                "cuted by the thread executing the slbsync instruction, ",
                "with respect to the memory barrier created by a subse",
                "quent ptesync instruction executed by the same ",
                "thread. Executing a slbsync instruction ensures that all ",
                "of the following will occur.",
                "The operation performed by this instruction is ordered ",
                "by the eieio (or [p]hwsync or ptesync) instruction with ",
                "respect to preceding slbieg and slbiag instructions ",
                "executed by the thread executing the slbsync instruc",
                "tion. The operations caused by slbieg or slbiag and ",
                "slbsync are ordered by eieio as a fifth set of opera",
                "tions, which is independent of the other four sets that ",
                "eieio orders.",
                "The slbsync instruction may complete before opera",
                "tions caused by slbieg or slbiag instructions preceding ",
                "the slbsync instruction have been performed.",
                "This instruction is privileged except when LPCR<sub>G</sub>",
                "TSE=0, making it hypervisor privileged.",
                "See Section6.10 for a description of other require",
                "ments associated with the use of this instruction.",
                "  ",
                "",
                "In addition to managing the TLB, tlbie and tlbiel are ",
                "also used to manage the Page Walk Cache, In-Memory ",
                "Table caching, and implementation-specific lookaside ",
                "information that depends on the values of the PTEs.  ",
                "The parameters described below specify the type of ",
                "translations to invalidate and the scope of the invalida",
                "tion to be performed.  ",
                "Radix Invalidation Control (RIC) specifies whether to ",
                "invalidate the TLB, the Page Walk Cache, or both ",
                "together with partition and Process Table caching.     ",
                "The RIC values and functions are as follows.",
                "Process Scoped (PRS) specifies whether the transla",
                "tion(s) to be invalidated are partition scoped or process ",
                "scoped including, for RIC=2, whether process or Parti",
                "tion Table caching is being invalidated.",
                "Radix (R) specifies whether the translations to be inval",
                "idated are Radix Tree translations or HPT transla",
                "tions.  If the R value is incorrect for the target partition, ",
                "the results of the operation are boundedly undefined.  ",
                "(R is ignored for invalidates with IS=3 and MSR<sub>HV</sub>=1 ",
                "because they have the potential to target translations ",
                "for multiple partitions.)",
                "Invalidation Selector (IS) (found in RB) specifies the ",
                "scope of the context to be invalidated.",
                " ",
                "The IS\u00b90 RIC=2 variants of tlbie and tlbiel perform the ",
                "same TLB invalidations as the corresponding RIC=0 ",
                "variants, but in addition invalidate Page Walk Cache ",
                "Entries and partition or Process Table caching associ",
                "ated with the specified LPID or LPID/PID.  When RIC=1 ",
                "and IS\u00b90, the Page Walk Cache Entries for the speci",
                "fied LPID or LPID/PID are invalidated while leaving the ",
                "corresponding TLB entries intact.  The ability to target ",
                "an individual Page Walk Cache Entry or the set of ",
                "entries associated with a given Page Table Entry (i.e. ",
                "IS=0 for RIC=1 or RIC=2) is not supported by the ",
                "Power ISA.  When RIC=3 and IS=0, tlbie invalidates a ",
                "series of consecutive translations for HPT translation.   ",
                "For IS=0 invalidations of Radix Tree translations, the ",
                "use of tlbie[l] is limited to translations for quadrant 0.",
                "When reassigning an LPID or PID, after updating the ",
                "Partition and/or Process Table(s) software must use a ",
                "tlbie instruction to remove lookaside information asso",
                "ciated with the old parition or process.",
                "To invalidate TLB entries, software must supply an ",
                "effective page number for process-scoped Radix Tree ",
                "translations, a guest real page number for parti",
                "tion-scoped Radix Tree translations, and an abbrevi",
                "ated virtual page number for HPT translations.  The ",
                "RTL, RB illustration, and verbal description for R=1 ",
                "require the reader to make the appropriate mental sub",
                "stitution for partition-scoped invalidation.  Note also that ",
                "where page size is specified to be a function of L and ",
                "AP, it may also be a function of L and LP.  The architec",
                "ture allows for three independent sets of page sizes, ",
                "one for R=1, one for RIC=3 (requires R=0), and one for ",
                "all other cases.  An implementation may choose to ",
                "have a single set of encodings work consistenty ",
                "between any two or all three states."
            ]
        },
        {
            "description": "Set Boolean",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "setb",
                    "operands": [
                        "RT",
                        "BFA"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BFA",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "128"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if CR<sub>4\u00d7BFA+32</sub>=1 then",
                "   RT := 0xFFFF_FFFF_FFFF_FFFF",
                "",
                "else if CR<sub>4\u00d7BFA+33</sub>=1 then",
                "   RT := 0x0000_0000_0000_0001",
                "",
                "else",
                "   RT := 0x0000_0000_0000_0000"
            ],
            "body": [
                "If the contents of bit 0 of CR field BFA are equal to 0b1, ",
                "the contents of register RT are set to ",
                "0xFFFF_FFFF_FFFF_FFFF.",
                "Otherwise, if the contents of bit 1 of CR field BFA are ",
                "equal to 0b1, the contents of register RT are set to ",
                "0x0000_0000_0000_0001.",
                "Otherwise, the contents of register RT are set to ",
                "0x0000_0000_0000_0000."
            ]
        },
        {
            "description": "Set Boolean Condition",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "setbc",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "384"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  1 :  0"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 1. ",
                "Otherwise, register RT is set to 0."
            ]
        },
        {
            "description": "Set Boolean Condition Reverse",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "setbcr",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "416"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  0 :  1"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 0. ",
                "Otherwise, register RT is set to 1."
            ]
        },
        {
            "description": "Set Negative Boolean Condition",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "setnbc",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "448"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ? -1 :  0"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 1. ",
                "Otherwise, register RT is set to 0."
            ]
        },
        {
            "description": "Set Negative Boolean Condition Reverse",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "setnbcr",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "480"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  0 : -1"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 0. ",
                "Otherwise, register RT is set to -1."
            ]
        },
        {
            "description": "Shift Left Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sld",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "sld.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "27"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "if (RB)<sub>57</sub> = 0 then",
                "     m := MASK(0, 63-n)",
                "else m := <sup>64</sup>0",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are shifted left the number ",
                "of bits specified by (RB)<sub>57:63</sub>. Bits shifted out of position ",
                "0 are lost. Zeros are supplied to the vacated positions ",
                "on the right. The result is placed into register RA. Shift ",
                "amounts from 64 to 127 give a zero result."
            ]
        },
        {
            "description": "Shift Left Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "slw",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "slw.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "24"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "if (RB)<sub>58</sub> = 0 then",
                "     m := MASK(32, 63-n)",
                "else m := <sup>64</sup>0",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted left the number of bits specified by (RB)<sub>58:63</sub>. ",
                "Bits shifted out of position 32 are lost. Zeros are sup",
                "plied to the vacated positions on the right. The 32-bit ",
                "result is placed into RA<sub>32:63</sub>. RA<sub>0:31</sub> are set to zero. Shift ",
                "amounts from 32 to 63 give a zero result."
            ]
        },
        {
            "description": "Shift Right Algebraic Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "srad",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "srad.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "794"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "if (RB)<sub>57</sub> = 0 then",
                "    m := MASK(n, 63)",
                "else m := <sup>64</sup>0",
                "s := (RS)<sub>0</sub>",
                "RA := r&amp;m | (<sup>64</sup>s) &amp; ~m",
                "carry := s &amp; ((r &amp; ~m) != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of register RS are shifted right the number ",
                "of bits specified by (RB)<sub>57:63</sub>. Bits shifted out of position ",
                "63 are lost. Bit 0 of RS is replicated to fill the vacated ",
                "positions on the left. The result is placed into register ",
                "RA. CA and CA32 are set to 1 if (RS) is negative and any ",
                "1-bits are shifted out of position 63; otherwise CA and ",
                "CA32 are set to 0. A shift amount of zero causes RA to be ",
                "set equal to (RS), and CA and CA32 to be set to 0. Shift ",
                "amounts from 64 to 127 give a result of 64 sign bits in ",
                "RA, and cause CA and CA32 to receive the sign bit of ",
                "(RS).",
                "",
                ""
            ]
        },
        {
            "description": "Shift Right Algebraic Doubleword Immediate",
            "form": "XS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sradi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "sradi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "413"
                },
                {
                    "name": "sh",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "m := MASK(n, 63)",
                "s := (RS)<sub>0</sub>",
                "RA := r&amp;m | (<sup>64</sup>s) &amp; ~m",
                "carry := s &amp; ((r &amp; ~m) != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of register RS are shifted right SH bits. Bits ",
                "shifted out of position 63 are lost. Bit 0 of RS is repli",
                "cated to fill the vacated positions on the left. The result ",
                "is placed into register RA. CA and CA32 are set to 1 if (RS) ",
                "is negative and any 1-bits are shifted out of position 63; ",
                "otherwise CA and CA32 are set to 0. A shift amount of ",
                "zero causes RA to be set equal to (RS), and CA and CA32 ",
                "to be set to 0.",
                "",
                "",
                "Special Registers Altered:"
            ]
        },
        {
            "description": "Shift Right Algebraic Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sraw",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "sraw.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "792"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "if (RB)<sub>58</sub> = 0 then",
                "    m := MASK(n+32, 63)",
                "else m := <sup>64</sup>0",
                "s := (RS)<sub>32</sub>",
                "RA := r&amp;m | (<sup>64</sup>s) &amp; ~m",
                "carry := s &amp; ((r &amp; ~m)<sub>32:63</sub> != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right the number of bits specified by (RB)<sub>58:63</sub>. ",
                "Bits shifted out of position 63 are lost. Bit 32 of RS is ",
                "replicated to fill the vacated positions on the left. The ",
                "32-bit result is placed into RA<sub>32:63</sub>. Bit 32 of RS is repli",
                "cated to fill RA<sub>0:31</sub>. CA and CA32 are set to 1 if the ",
                "low-order 32 bits of (RS) contain a negative number ",
                "and any 1-bits are shifted out of position 63; otherwise ",
                "CA and CA32 are set to 0. A shift amount of zero causes ",
                "RA to receive EXTS((RS)<sub>32:63</sub><sub>)</sub>, and CA and CA32 to be set ",
                "to 0. Shift amounts from 32 to 63 give a result of 64 ",
                "sign bits, and cause CA and CA32 to receive the sign bit ",
                "of (RS)<sub>32:63</sub>.",
                "",
                "",
                ""
            ]
        },
        {
            "description": "Shift Right Algebraic Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "srawi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "srawi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "824"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "m := MASK(n+32, 63)",
                "s := (RS)<sub>32</sub>",
                "RA := r&amp;m | (<sup>64</sup>s) &amp; ~m",
                "carry := s &amp; ((r &amp; ~m)<sub>32:63</sub> != 0 )",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right SH bits. Bits shifted out of position 63 are ",
                "lost. Bit 32 of RS is replicated to fill the vacated positions ",
                "on the left. The 32-bit result is placed into RA<sub>32:63</sub>. Bit 32 ",
                "of RS is replicated to fill RA<sub>0:31</sub>. CA and CA32 are set to 1 if ",
                "the low-order 32 bits of (RS) contain a negative number ",
                "and any 1-bits are shifted out of position 63; otherwise ",
                "CA and CA32 are set to 0. A shift amount of zero causes ",
                "RA to receive EXTS((RS)<sub>32:63</sub><sub>)</sub>, and CA and CA32 to be set ",
                "to 0.",
                "",
                ""
            ]
        },
        {
            "description": "Shift Right Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "srd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "srd.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "539"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "if (RB)<sub>57</sub> = 0 then",
                "    m := MASK(n, 63)",
                "else m := <sup>64</sup>0",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of register RS are shifted right the number ",
                "of bits specified by (RB)<sub>57:63</sub>. Bits shifted out of position ",
                "63 are lost. Zeros are supplied to the vacated positions ",
                "on the left. The result is placed into register RA. Shift ",
                "amounts from 64 to 127 give a zero result."
            ]
        },
        {
            "description": "Shift Right Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "srw",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "srw.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "536"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "if (RB)<sub>58</sub> = 0 then",
                "    m := MASK(n+32, 63)",
                "else m := <sup>64</sup>0",
                "RA := r &amp; m"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right the number of bits specified by (RB)<sub>58:63</sub>. ",
                "Bits shifted out of position 63 are lost. Zeros are sup",
                "plied to the vacated positions on the left. The 32-bit ",
                "result is placed into RA<sub>32:63</sub>. RA<sub>0:31</sub> are set to zero. Shift ",
                "amounts from 32 to 63 give a zero result."
            ]
        },
        {
            "description": "Store Byte",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stb",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "38"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstb\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstb\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstb\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stb, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstb with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstb with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>56:63</sub> are stored into the byte in storage addressed ",
                "by EA.",
                "",
                "For pstb, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Byte:"
            ]
        },
        {
            "description": "Prefixed Store Byte",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstb",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "38"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstb\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstb\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstb\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stb, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstb with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstb with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>56:63</sub> are stored into the byte in storage addressed ",
                "by EA.",
                "",
                "For pstb, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Byte:"
            ]
        },
        {
            "description": "Store Byte Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "stbcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "981"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)<sub>56:63</sub> are stored into the byte in ",
                "storage addressed by EA.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged."
            ]
        },
        {
            "description": "Store Byte Conditional Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "stbcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "694"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                "  if RESERVE_LENGTH = 1 &amp;",
                "     RESERVE_ADDR = real_addr(EA) then",
                "      MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "",
                "      undefined_case  := 0",
                "      store_performed := 1",
                "   else",
                "      z := smallest real page size supported by ",
                "          implementation",
                "      if RESERVE_ADDR \u00b8 z = real_addr(EA) \u00b8 z then",
                "         undefined_case  := 1",
                "      else",
                "        undefined_case  := 0",
                "        store_performed := 0",
                "else",
                "  undefined_case  := 0",
                "  store_performed := 0",
                "if undefined_case then",
                "  u1 := undefined 1-bit value",
                "  if u1 then",
                "    MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "",
                "  u2 := undefined 1-bit value",
                "  CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "",
                "else",
                "  CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "",
                "",
                "RESERVE := 0"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "If a reservation exists, the length associated with the ",
                "reservation is 1 byte, and the real storage location ",
                "specified by the stbcx. is the same as the real storage ",
                "location specified by the lbarx instruction that estab",
                "lished the reservation, (RS)<sub>56:63</sub> are stored into the ",
                "byte in storage addressed by EA.",
                "If a reservation exists, and either the length associated ",
                "with the reservation is not 1 byte or the real storage ",
                "location specified by the stbcx. is not the same as the ",
                "real storage location specified by the lbarx instruction ",
                "that established the reservation, the following applies. ",
                "Let z denote the smallest real page size supported by ",
                "the implementation. If the real storage location speci",
                "fied by the stbcx. is in the same aligned z-byte block of ",
                "real storage as the real storage location specified by ",
                "the lbarx instruction that established the reservation, it ",
                "is undefined whether (RS)<sub>56:63</sub> are stored into the byte ",
                "in storage addressed by EA. Otherwise, no store is per",
                "formed.",
                "If a reservation does not exist, no store is performed.",
                "CR Field 0 set ",
                "as follows. n is a 1-bit value that indicates whether the ",
                "store was performed, except that if, per the preceding ",
                "description, it is undefined whether the store is per",
                "formed, the value of n is undefined (and need not ",
                "reflect whether the store was performed).",
                "The reservation is cleared."
            ]
        },
        {
            "description": "Store Byte Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stbx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "215"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. (RS)<sub>56:63</sub> are stored into the byte in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Byte with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stbu",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "39"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "(RS)<sub>56:63</sub> are stored into the byte in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Byte with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stbux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "247"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. (RS)<sub>56:63</sub> are stored into the byte in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Doubleword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "std",
                    "operands": [
                        "RS",
                        "DS(RA)"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "62"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                }
            ],
            "code": [
                "if \u201cstd\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpstd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For std, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pstd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "",
                "For pstd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Doubleword:"
            ]
        },
        {
            "description": "Prefixed Store Doubleword",
            "form": "8LS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstd",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "61"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstd\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpstd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For std, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pstd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "",
                "For pstd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Doubleword:"
            ]
        },
        {
            "description": "Store Doubleword Atomic",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "stdat",
                    "operands": [
                        "RS",
                        "RA",
                        "FC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "742"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "mem(EA,16):= stat(mem(EA,16), RS, FC)"
            ],
            "body": [
                "Let the effective address (EA) be (RA).  Eight or sixteen ",
                "bytes of storage at EA are updated as specified by ",
                "store atomic function code FC.  Input operands are ",
                "function code specific, and may include RS and  ",
                "mem(EA,16).",
                "Figure4 contains the valid function codes.  An attempt ",
                "to execute stdat specifying an invalid function code will ",
                "cause the system data storage error handler to be ",
                "invoked.",
                "EA must be a multiple of 8, and the portion of  ",
                "mem(EA,16) accessed by the instruction must be con",
                "tained within an aligned 32-byte block of storage.  If ",
                "either of these requirements is not satisfied, the system ",
                "alignment error handler is invoked.",
                "",
                "The synchronization instructions are used to ensure ",
                "that certain instructions have completed before other ",
                "instructions are initiated, or to control storage access ",
                "ordering, or to support debug operations."
            ]
        },
        {
            "description": "Store Doubleword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stdbrx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "660"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>",
                "|| (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub>",
                "|| (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub>",
                "|| (RS)<sub>8:15</sub>  || (RS)<sub>0:7</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "(RS)<sub>56:63</sub> are stored into bits 0:7 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>48:55</sub> are stored into bits 8:15 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>40:47</sub> are stored into bits 16:23 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>32:39</sub> are stored into bits 23:31 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>24:31</sub> are stored into bits 32:39 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>16:23</sub> are stored into bits 40:47 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>8:15</sub> are stored into bits 48:55 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>0:7</sub> are stored into bits 56:63 of the doubleword in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Doubleword Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "stdcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "1013"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS) is stored into the doubleword in ",
                "storage addressed by EA.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged."
            ]
        },
        {
            "description": "Store Doubleword Conditional Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "stdcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "214"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                "  if RESERVE_LENGTH = 8 &amp;",
                "     RESERVE_ADDR = real_addr(EA) then",
                "      MEM(EA, 8) := (RS)",
                "",
                "      undefined_case  := 0",
                "      store_performed := 1",
                "   else",
                "      z := smallest real page size supported by ",
                "          implementation",
                "      if RESERVE_ADDR \u00b8 z = real_addr(EA) \u00b8 z then",
                "        undefined_case  := 1",
                "      else",
                "        undefined_case  := 0",
                "        store_performed := 0",
                "else",
                "  undefined_case  := 0",
                "  store_performed := 0",
                "if undefined_case then",
                "  u1 := undefined 1-bit value",
                "  if u1 then",
                "    MEM(EA, 8) := (RS)",
                "",
                "  u2 := undefined 1-bit value",
                "  CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "",
                "else",
                "  CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "",
                "",
                "RESERVE := 0"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "If a reservation exists, the length associated with the ",
                "reservation is 8 bytes, and the real storage location ",
                "specified by the stdcx. is the same as the real storage ",
                "location specified by the ldarx instruction that estab",
                "lished the reservation, (RS) is stored into the double",
                "word in storage addressed by EA.",
                "If a reservation exists, and either the length associated ",
                "with the reservation is not 8 bytes or the real storage ",
                "location specified by the stdcx. is not the same as the ",
                "real storage location specified by the ldarx instruction ",
                "that established the reservation, the following applies. ",
                "Let z denote the smallest real page size supported by ",
                "the implementation. If the real storage location speci",
                "fied by the stdcx. is in the same aligned z-byte block of ",
                "real storage as the real storage location specified by ",
                "the ldarx instruction that established the reservation, it ",
                "is undefined whether (RS) is stored into the double",
                "word in storage addressed by EA. Otherwise, no store ",
                "is performed. ",
                "If a reservation does not exist, no store is performed.",
                "CR Field 0 set ",
                "as follows. n is a 1-bit value that indicates whether the ",
                "store was performed, except that if, per the preceding ",
                "description, it is undefined whether the store is per",
                "formed, the value of n is undefined (and need not ",
                "reflect whether the store was performed).",
                "The reservation is cleared.",
                "EA must be a multiple of 8. If it is not, either the system ",
                "alignment error handler is invoked or the results are ",
                "boundedly undefined.",
                "For lqarx, the quadword in storage addressed by EA is ",
                "loaded into an even-odd pair of GPRs as follows. In ",
                "Big-Endian mode, the even-numbered GPR is loaded ",
                "with the doubleword from storage addressed by EA ",
                "and the odd-numbered GPR is loaded with the double",
                "word addressed by EA+8. In Little-Endian mode, the ",
                "even-numbered GPR is loaded with the byte-reversed ",
                "doubleword from storage addressed by EA+8 and the ",
                "odd-numbered GPR is loaded with the byte-reversed ",
                "doubleword addressed by EA.",
                "In the preferred form of the Load Quadword instruction ",
                "RA \u00b9 RTp+1 and RB \u00b9 RTp+1.",
                "For stqcx., the contents of an even-odd pair of GPRs is ",
                "stored into the quadword in storage addressed by EA ",
                "as follows. In Big-Endian mode, the even-numbered ",
                "GPR is stored into the doubleword in storage ",
                "addressed by EA and the odd-numbered GPR is stored ",
                "into the doubleword addressed by EA+8. In Lit",
                "tle-Endian mode, the even-numbered GPR is stored ",
                "byte-reversed into the doubleword in storage ",
                "addressed by EA+8 and the odd-numbered GPR is ",
                "stored byte-reversed into the doubleword addressed by ",
                "EA.",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        {
            "description": "Store Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stdx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "149"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA."
            ]
        },
        {
            "description": "Store Doubleword with Update",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stdu",
                    "operands": [
                        "RS",
                        "DS(RA)"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "62"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "MEM(EA, 8) := (RS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(DS||0b00)</sub>.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Doubleword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stdux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "181"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 8) := (RS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfd",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "54"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstfd\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstfd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstfd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (FRS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "",
                "For pstfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Prefixed Store Floating-Point Double",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstfd",
                    "operands": [
                        "FRS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "54"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstfd\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstfd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstfd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (FRS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "",
                "For pstfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Store Floating-Point Double Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfdx",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "727"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (FRS)",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA."
            ]
        },
        {
            "description": "Store Floating-Point Double Pair",
            "form": "DS-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfdp",
                    "operands": [
                        "FRSp",
                        "DS(RA)"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "61"
                },
                {
                    "name": "FRSp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DS||0b00)",
                "MEM(EA, 8)   := FRSp<sub>even</sub>",
                "MEM(EA+8, 8) := FRSp<sub>odd</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(DS||0b00)</sub>. ",
                "The contents of the even-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by EA.",
                "The contents of the odd-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by ",
                "EA+8.",
                "If FRSp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double Pair Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfdpx",
                    "operands": [
                        "FRSp",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRSp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "919"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8)   := FRSp<sub>even</sub>",
                "MEM(EA+8, 8) := FRSp<sub>odd</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(DS||0b00)</sub>. ",
                "The contents of the even-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by ",
                "EA.",
                "The contents of the odd-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by ",
                "EA+8.",
                "If FRSp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfdu",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "55"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 8) := (FRS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfdux",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "759"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 8) := (FRS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Single",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfs",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "52"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstfs\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstfs\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstfs\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := SINGLE((FRS))",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "",
                "For pstfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Prefixed Store Floating-Point Single",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstfs",
                    "operands": [
                        "FRS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "52"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstfs\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstfs\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstfs\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := SINGLE((FRS))",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "",
                "For pstfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Store Floating-Point Single Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfsx",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "663"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := SINGLE((FRS))",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA."
            ]
        },
        {
            "description": "Store Floating-Point Single with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfsu",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "53"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 4) := SINGLE((FRS))",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Single with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfsux",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "695"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 4) := SINGLE((FRS))",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point as Integer Word Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stfiwx",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "983"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (FRS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(FRS)<sub>32:63</sub> are stored, without conversion, into the word ",
                "in storage addressed by EA.",
                "If the contents of register FRS were produced, either ",
                "directly or indirectly, by a Load Floating-Point Single ",
                "instruction, a single-precision Arithmetic instruction, or ",
                "frsp, then the value stored is undefined. (The contents ",
                "of register FRS are produced directly by such an instruc",
                "tion if FRS is the target register for the instruction. The ",
                "contents of register FRS are produced indirectly by such ",
                "an instruction if FRS is the final target register of a ",
                "sequence of one or more Floating-Point Move instruc",
                "tions, with the input to the sequence having been pro",
                "duced directly by such an instruction.)",
                "  "
            ]
        },
        {
            "description": "Store Halfword",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sth",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "44"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201csth\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpsth\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpsth\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For sth, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For psth with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For psth with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>48:63</sub> are stored into the halfword in storage ",
                "addressed by EA.",
                "",
                "For psth, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Halfword:"
            ]
        },
        {
            "description": "Prefixed Store Halfword",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "psth",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "44"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201csth\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpsth\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpsth\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For sth, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For psth with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For psth with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>48:63</sub> are stored into the halfword in storage ",
                "addressed by EA.",
                "",
                "For psth, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Halfword:"
            ]
        },
        {
            "description": "Store Halfword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sthbrx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "918"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(RS)<sub>56:63</sub> are stored into bits 0:7 of the halfword in stor",
                "age addressed by EA. ",
                "(RS)<sub>48:55</sub> are stored into bits 8:15 of the halfword in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Halfword Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "sthcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "949"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)<sub>48:63</sub> are stored into the halfword ",
                "in storage addressed by EA.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged.",
                ""
            ]
        },
        {
            "description": "Store Halfword Conditional Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "sthcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "726"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                "  if RESERVE_LENGTH = 2 &amp;",
                "     RESERVE_ADDR = real_addr(EA) then",
                "      MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "",
                "      undefined_case  := 0",
                "      store_performed := 1",
                "   else",
                "      z := smallest real page size supported by ",
                "         implementation",
                "      if RESERVE_ADDR \u00b8 z = real_addr(EA) \u00b8 z then",
                "         undefined_case  := 1",
                "      else",
                "        undefined_case  := 0",
                "        store_performed := 0",
                "else",
                "  undefined_case  := 0",
                "  store_performed := 0",
                "if undefined_case then",
                "  u1 := undefined 1-bit value",
                "  if u1 then",
                "    MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "",
                "  u2 := undefined 1-bit value",
                "  CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "",
                "else",
                "  CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "",
                "",
                "RESERVE := 0"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "If a reservation exists, the length associated with the ",
                "reservation is 2 bytes, and the real storage location ",
                "specified by the sthcx. is the same as the real storage ",
                "location specified by the lharx instruction that estab",
                "lished the reservation, (RS)<sub>48:63</sub> are stored into the ",
                "halfword in storage addressed by EA.",
                "If a reservation exists, and either the length associated ",
                "with the reservation is not 2 bytes or the real storage ",
                "location specified by the sthcx. is not the same as the ",
                "real storage location specified by the lharx instruction ",
                "that established the reservation, the following applies. ",
                "Let z denote the smallest real page size supported by ",
                "the implementation. If the real storage location speci",
                "fied by the sthcx. is in the same aligned z-byte block of ",
                "real storage as the real storage location specified by ",
                "the lharx instruction that established the reservation, it ",
                "is undefined whether (RS)<sub>48:63</sub> are stored into the half",
                "word in storage addressed by EA. Otherwise, no store ",
                "is performed.",
                "If a reservation does not exist, no store is performed.",
                "CR Field 0 set ",
                "as follows. n is a 1-bit value that indicates whether the ",
                "store was performed, except that if, per the preceding ",
                "description, it is undefined whether the store is per",
                "formed, the value of n is undefined (and need not ",
                "reflect whether the store was performed).",
                "The reservation is cleared.",
                "EA must be a multiple of 2. If it is not, either the system ",
                "alignment error handler is invoked or the results are ",
                "boundedly undefined.",
                ""
            ]
        },
        {
            "description": "Store Halfword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sthx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "407"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. (RS)<sub>48:63</sub> are stored into the halfword ",
                "in storage addressed by EA."
            ]
        },
        {
            "description": "Store Halfword with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sthu",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "45"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "(RS)<sub>48:63</sub> are stored into the halfword in storage ",
                "addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Halfword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sthux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "439"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. (RS)<sub>48:63</sub> are stored into the halfword in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Multiple Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stmw",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "47"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RS",
                "do while r &lt;= 31",
                "   MEM(EA, 4) := GPR(r)<sub>32:63</sub>",
                "",
                "   r := r + 1",
                "   EA := EA + 4"
            ],
            "body": [
                "Let n = (32-RS). Let the effective address (EA) be the ",
                "sum (RA|0)+<sub>D</sub>.",
                "n consecutive words starting at EA are stored from the ",
                "low-order 32 bits of GPRs RS through 31.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Store Quadword Conditional Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "stqcx.",
                    "operands": [
                        "RSp",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RSp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "182"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                "  if RESERVE_LENGTH = 16 &amp;",
                "     RESERVE_ADDR = real_addr(EA) then",
                "      MEM(EA, 16) := (RSp)",
                "",
                "      undefined_case  := 0",
                "      store_performed := 1",
                "   else",
                "      z := smallest real page size supported by ",
                "          implementation",
                "      if RESERVE_ADDR \u00b8 z = real_addr(EA) \u00b8 z then",
                "         undefined_case  := 1",
                "      else",
                "         undefined_case  := 0",
                "         store_performed := 0",
                "else",
                "  undefined_case  := 0",
                "  store_performed := 0",
                "if undefined_case then",
                "  u1 := undefined 1-bit value",
                "  if u1 then",
                "    MEM(EA, 16) := (RSp)",
                "",
                "  u2 := undefined 1-bit value",
                "  CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "",
                "else",
                "  CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "",
                "",
                "RESERVE := 0"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "If a reservation exists, the length associated with the ",
                "reservation is 16 bytes, and the real storage location ",
                "specified by the stqcx. is the same as the real storage ",
                "location specified by the lqarx instruction that estab",
                "lished the reservation, (RSp) is stored into the quad",
                "word in storage addressed by EA.",
                "",
                "",
                "If a reservation exists, and either the length associated ",
                "with the reservation is not 16 bytes or the real storage ",
                "location specified by the stqcx. is not the same as the ",
                "real storage location specified by the lqarx instruction ",
                "that established the reservation, the following applies. ",
                "Let z denote the smallest real page size supported by ",
                "the implementation. If the real storage location speci",
                "fied by the stqcx. is in the same aligned z-byte block of ",
                "real storage as the real storage location specified by ",
                "the lqarx instruction that established the reservation, it ",
                "is undefined whether (RSp) is stored into the quadword ",
                "in storage addressed by EA. Otherwise, no store is per",
                "formed. ",
                "If a reservation does not exist, no store is performed.",
                "CR Field 0 set ",
                "as follows. n is a 1-bit value that indicates whether the ",
                "store was performed, except that if, per the preceding ",
                "description, it is undefined whether the store is per",
                "formed, the value of n is undefined (and need not ",
                "reflect whether the store was performed).",
                "The reservation is cleared.",
                "EA must be a multiple of 16. If it is not, either the sys",
                "tem alignment error handler is invoked or",
                " the results are boundedly undefined.",
                "If RSp is odd, the instruction form is invalid.",
                "CR0"
            ]
        },
        {
            "description": "Store String Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stswi",
                    "operands": [
                        "RS",
                        "RA",
                        "NB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "NB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "725"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RS - 1",
                "i := 32",
                "do while n &gt; 0",
                "   if i = 32 then r := r + 1 (mod 32)",
                "   MEM(EA, 1) := GPR(r)<sub>i:i+7</sub>",
                "",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n = NB if ",
                "NB\u00b90, n=32 if NB=0; n is the number of bytes to store. ",
                "Let nr=CEIL(n/4); nr is the number of registers to ",
                "supply data.",
                "n consecutive bytes starting at EA are stored from ",
                "GPRs RS through RS+nr-1. Data are stored from the ",
                "low-order four bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Store String Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stswx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "661"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER<sub>57:63</sub>",
                "r := RS - 1",
                "i := 32",
                "do while n &gt; 0",
                "   if i = 32 then r := r + 1 (mod 32)",
                "   MEM(EA, 1) := GPR(r)<sub>i:i+7</sub>",
                "",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. Let n = XER<sub>57:63</sub>; n is the number of ",
                "bytes to store. Let nr = CEIL(n/4); nr is the number of ",
                "registers to supply data.",
                "If n&gt;0, n consecutive bytes starting at EA are stored from ",
                "GPRs RS through RS+nr-1. Data are stored from the ",
                "low-order four bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "If n=0, no bytes are stored.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode and n&gt;0, the sys",
                "tem alignment error handler is invoked."
            ]
        },
        {
            "description": "Store VSX Scalar Doubleword",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxsd",
                    "operands": [
                        "VRS",
                        "DS(RA)"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "61"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \u201cstxsd\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpstxsd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstxsd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,8)    := VSR[VRS+32].dword[0]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxsd with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxsd with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of doubleword element ",
                "0 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "",
                "For pstxsd, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Prefixed Store VSX Scalar Doubleword",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstxsd",
                    "operands": [
                        "VRS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "46"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \u201cstxsd\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpstxsd\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstxsd\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,8)    := VSR[VRS+32].dword[0]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxsd with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxsd with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of doubleword element ",
                "0 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "",
                "For pstxsd, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Store VSX Scalar Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxsdx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "716"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,8)    := VSR[XS].dword[0]",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "Let store_data be the contents of doubleword element ",
                "0 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;"
            ]
        },
        {
            "description": "Store VSX Scalar Single - Precision Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxsspx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "652"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,4) ~ bfp32_CONVERT_FROM_BFP64(VSR[32\u00d7SX+S].dword[0])",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "Let store_data be the double-precision floating-point ",
                "value in doubleword element 0 of VSR[XS] converted to ",
                "single-precision format",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;"
            ]
        },
        {
            "description": "Store VSX Scalar Single-Precision",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxssp",
                    "operands": [
                        "VRS",
                        "DS(RA)"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "61"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \u201cstxsso\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpstxssp\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstxssp\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,4) ~ bfp32_CONVERT_FROM_BFP64(VSR[VRS+32].dword[0])",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the double-precision floating-point ",
                "value in doubleword element 0 of VSR[XS] converted to ",
                "single-precision format",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "",
                "For pstxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Single-Precision:"
            ]
        },
        {
            "description": "Prefixed Store VSX Scalar Single-Precision",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstxssp",
                    "operands": [
                        "VRS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "47"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \u201cstxsso\u201d  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if \u201cpstxssp\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstxssp\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,4) ~ bfp32_CONVERT_FROM_BFP64(VSR[VRS+32].dword[0])",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the double-precision floating-point ",
                "value in doubleword element 0 of VSR[XS] converted to ",
                "single-precision format",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "",
                "For pstxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Single-Precision:"
            ]
        },
        {
            "description": "Store VSX Scalar as Integer Byte Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxsibx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "909"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,1) ~ VSR[32\u00d7SX+S].byte[7]",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The contents of byte element 7 of VSR[XS] are placed ",
                "into the byte in storage addressed by EA."
            ]
        },
        {
            "description": "Store VSX Scalar as Integer Halfword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxsihx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "941"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,2) ~ VSR[32\u00d7SX+S].hword[3]",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The contents of halfword element 3 of VSR[XS] are ",
                "placed into the halfword in storage addressed by EA."
            ]
        },
        {
            "description": "Store VSX Scalar as Integer Word Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxsiwx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "140"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ( (RA=0) ? 0 : GPR[RA] ) + GPR[RB]",
                "",
                "MEM(EA,4) := VSR[32\u00d7SX+S].word[1]",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "Let store_data be the contents of word element 1 of ",
                "VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;"
            ]
        },
        {
            "description": "Store VSX Vector",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxv",
                    "operands": [
                        "XS",
                        "DQ(RA)"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "61"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DQ",
                    "size": "12"
                },
                {
                    "name": "SX",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "5"
                }
            ],
            "code": [
                "if stxv\u201d &amp; SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if stxv\u201d &amp; SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "if \u201cpstxv\u201d &amp; MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cstxv\u201d  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if \u201cpstxv\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstxv\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,16) := VSR[32\u00d7SX+S]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value 32\u00d7SX + S.",
                "For stxv, let the effective address (EA) be the sum of ",
                "the contents of GPR[RA], or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For pstxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of GPR[RA], or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "",
                "For pstxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Vector:"
            ]
        },
        {
            "description": "Prefixed Store VSX Vector",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstxv",
                    "operands": [
                        "XS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "27"
                },
                {
                    "name": "SX",
                    "size": "1"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if stxv\u201d &amp; SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if stxv\u201d &amp; SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "if \u201cpstxv\u201d &amp; MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \u201cstxv\u201d  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if \u201cpstxv\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstxv\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,16) := VSR[32\u00d7SX+S]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value 32\u00d7SX + S.",
                "For stxv, let the effective address (EA) be the sum of ",
                "the contents of GPR[RA], or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For pstxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of GPR[RA], or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "",
                "For pstxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Vector:"
            ]
        },
        {
            "description": "Store VSX Vector Byte*16 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvb16x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "1004"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "do i = 0 to 15",
                "   MEM(EA+i,1) ~ VSR[32\u00d7SX+S].byte[i]",
                "end",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 15, do the following.",
                "  ",
                "Storing a vector of 16 byte elements from VSR[XS] into ",
                "Big-Endian storage using sxvb16x, retaining ",
                "left-to-right element ordering.",
                "Loading a vector of 16 byte elements from ",
                "Little-Endian storage in VSR[XT] using lxvb16x, ",
                "retaining left-to-right element ordering."
            ]
        },
        {
            "description": "Store VSX Vector Doubleword*2 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvd2x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "972"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,8)     := VSR[32\u00d7SX+S].dword[0]",
                "MEM(EA+8,8)   := VSR[32\u00d7SX+S].dword[1]",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Store VSX Vector Halfword*8 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvh8x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "940"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "do i = 0 to 7",
                "   MEM(EA+2\u00d7i,2) ~ VSR[32\u00d7SX+S].hword[i]",
                "end",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 7, do the following.",
                "For each integer value from 0 to 7, do the following.",
                "Storing a vector of 8 halfword elements from VSR[X] ",
                "into Big-Endian storage using stxvh8x, retaining ",
                "left-to-right element ordering.",
                "Storing a vector of 8 halfword elements from VSR[X] ",
                "into Little-Endian storage using stxvh8x, retaining ",
                "left-to-right element ordering."
            ]
        },
        {
            "description": "Store VSX Vector Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "396"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,16) ~ VSR[32\u00d7SX+S]",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "  ",
                "Storing 16 bytes of data into Big-Endian storage from ",
                "VSR[XS] using stxvx.",
                "Storing 16 bytes of data into Little-Endian storage from ",
                "VSR[XS] using stxvx."
            ]
        },
        {
            "description": "Store VSX Vector Paired",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvp",
                    "operands": [
                        "XSp",
                        "DQ(RA)"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "6"
                },
                {
                    "name": "Sp",
                    "size": "4"
                },
                {
                    "name": "SX",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DQ",
                    "size": "12"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if \u201cstxvp\u201d then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if \u201cpstxvp\u201d then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "",
                "if \u201cstxvp\u201d        then EA ~ EAbase + EAdisp",
                "if \u201cpstxvp\u201d &amp; R=0 then EA ~ EAbase + EAdisp",
                "if \u201cpstxvp\u201d &amp; R=1 then EA ~ CIA    + EAdisp",
                "",
                "store_data.bit[  0:127] ~ VSR[32\u00d7SX+2\u00d7Sp]",
                "store_data.bit[128:255] ~ VSR[32\u00d7SX+2\u00d7Sp+1]",
                "",
                "MEM(EA,32) ~ store_data",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XSp be the value 32\u00d7SX+2\u00d7Sp (i.e., only even ",
                "values of XSp can be encoded in the instruction).",
                "For stxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0 and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For pstxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For pstxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XSp] ",
                "concatenated with VSR[XSp+1].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "For pstxvp, if R is equal to 1 and ",
                "RA is not equal to 0, the instruction form is invalid.",
                "",
                "",
                "Extended mnemonics for Store VSX Vector Paired Pre",
                "fixed:",
                "  "
            ]
        },
        {
            "description": "Prefixed Store VSX Vector Paired",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstxvp",
                    "operands": [
                        "XSp",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "62"
                },
                {
                    "name": "Sp",
                    "size": "4"
                },
                {
                    "name": "SX",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if \u201cstxvp\u201d then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if \u201cpstxvp\u201d then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "",
                "if \u201cstxvp\u201d        then EA ~ EAbase + EAdisp",
                "if \u201cpstxvp\u201d &amp; R=0 then EA ~ EAbase + EAdisp",
                "if \u201cpstxvp\u201d &amp; R=1 then EA ~ CIA    + EAdisp",
                "",
                "store_data.bit[  0:127] ~ VSR[32\u00d7SX+2\u00d7Sp]",
                "store_data.bit[128:255] ~ VSR[32\u00d7SX+2\u00d7Sp+1]",
                "",
                "MEM(EA,32) ~ store_data",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XSp be the value 32\u00d7SX+2\u00d7Sp (i.e., only even ",
                "values of XSp can be encoded in the instruction).",
                "For stxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0 and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For pstxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For pstxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XSp] ",
                "concatenated with VSR[XSp+1].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "For pstxvp, if R is equal to 1 and ",
                "RA is not equal to 0, the instruction form is invalid.",
                "",
                "",
                "Extended mnemonics for Store VSX Vector Paired Pre",
                "fixed:",
                "  "
            ]
        },
        {
            "description": "Store VSX Vector Paired Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvpx",
                    "operands": [
                        "XSp",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "Sp",
                    "size": "4"
                },
                {
                    "name": "SX",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "461"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "store_data.bit[  0:127] ~ VSR[32\u00d7SX+2\u00d7Sp]",
                "store_data.bit[128:255] ~ VSR[32\u00d7SX+2\u00d7Sp+1]",
                "",
                "MEM(EA,32) ~ store_data",
                ""
            ],
            "body": [
                "Let XSp be the value 32\u00d7SX + 2\u00d7Sp (i.e., only even ",
                "values of XSp can be encoded in the instruction).",
                "Let the effective address (EA) be the sum of the integer ",
                "value in GPR[RA], or 0 if RA=0, and the integer value in ",
                "GPR[RB].",
                "Let store_data be the contents of VSR[XSp] ",
                "concatenated with VSR[XSp+1].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Byte Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvrbx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "141"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB];",
                "MEM(EA,1) = VSR[32\u00d7SX+S].byte[15];"
            ],
            "body": [
                "Let XS be the value of 32\u00d7SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "The contents of byte element 15 of VSR[XS] are placed ",
                "into storage at address EA."
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvrdx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "237"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,8) = VSR[32\u00d7SX+S].dword[1]"
            ],
            "body": [
                "Let XS be the value of 32\u00d7SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Let store_data be the contents of doubleword element ",
                "1 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the doubleword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the doubleword in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Halfword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvrhx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "173"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,2) = VSR[32\u00d7SX+S].hword[7]"
            ],
            "body": [
                "Let XS be the value of 32\u00d7SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Let store_data be the contents of halfword element 7 ",
                "of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the halfword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the halfword in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Word Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvrwx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "205"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,4) = VSR[32\u00d7SX+S].word[3]"
            ],
            "body": [
                "Let XS be the value of 32\u00d7SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Let store_data be the contents of word element 3 of ",
                "VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the word in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the word in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Word*4 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvw4x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "908"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,4)     := VSR[32\u00d7SX+S].word[0]",
                "MEM(EA+4,4)   := VSR[32\u00d7SX+S].word[1]",
                "MEM(EA+8,4)   := VSR[32\u00d7SX+S].word[2]",
                "MEM(EA+12,4)  := VSR[32\u00d7SX+S].word[3]",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 3, do the following.",
                "  "
            ]
        },
        {
            "description": "Store VSX Vector with Length",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvl",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "397"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ (RA=0) ? 0 : GPR[RA]",
                "",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb&gt;16 then nb ~ 16",
                "",
                "if MSR.LE = 0 then       // Big-Endian byte-ordering",
                "   store_data ~ VSR[32\u00d7SX+S].byte[0:nb-1]",
                "else                     // Little-Endian byte ordering",
                "   store_data ~ VSR[32\u00d7SX+S].byte[16-nb:15]",
                "",
                "MEM(EA,nb) ~ store_data",
                ""
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed.",
                "Otherwise, when Big-Endian byte-ordering is ",
                "employed, do the following.",
                "Otherwise, when Little-Endian byte ordering is ",
                "employed, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Storing less than 16-byte data in VSR[XS] into ",
                "BigEndian storage using stxvl.",
                "Storing less than 16-byte data in VSR[XS] into ",
                "LittleEndian storage using stxvl."
            ]
        },
        {
            "description": "Store VSX Vector with Length Left-justified",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stxvll",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "429"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ (RA=0) ? 0 : GPR[RA]",
                "",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb&gt;16 then nb ~ 16",
                "",
                "if nb&gt;0 then do i = 0 to nb-1",
                "   MEM(EA+i,1) ~ VSR[32\u00d7SX+S].byte[i]",
                "",
                "end"
            ],
            "body": [
                "Let XS be the value 32\u00d7SX + S.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed.",
                "Otherwise, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Storing less than 16-byte data, left-justified in VSR[XS], ",
                "into storage using stxvll."
            ]
        },
        {
            "description": "Store Vector Element Byte Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stvebx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "135"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then ",
                "   MEM(EA,1) := VSR[VRS+32].byte[eb]",
                "else",
                "   MEM(EA,1) := VSR[VRS+32].byte[15-eb]"
            ],
            "body": [
                "Let EA be the sum of the contents of GPR[RA], or 0 if ",
                "RA=0, and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, the contents of byte eb of VSR[VRS+32] are ",
                "placed in the byte in storage at address EA.",
                "If Little-Endian byte ordering is used for the storage ",
                "access, the contents of byte 15-eb of VSR[VRS+32] are ",
                "placed in the byte in storage at address EA.",
                " "
            ]
        },
        {
            "description": "Store Vector Element Halfword Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stvehx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "167"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFFE",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then ",
                "   MEM(EA,2) := VSR[VRS+32].byte[eb:eb+1]",
                "else",
                "   MEM(EA,2) := VSR[VRS+32][14-eb:15-eb]"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If Little-Endian byte ordering is used for the storage ",
                "access, ",
                "  "
            ]
        },
        {
            "description": "Store Vector Element Word Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stvewx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "199"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFFC",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then ",
                "   MEM(EA,4) := VSR[VRS+32].byte[eb:eb+3]",
                "else",
                "   MEM(EA,4) := VSR[VRS+32].byte[12-eb:15-eb]"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If Little-Endian byte ordering is used for the storage ",
                "access,",
                " "
            ]
        },
        {
            "description": "Store Vector Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stvx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "231"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "MEM(EA, 16) := VSR[VRS+32]"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of VSR[VRS+32] are placed into the ",
                "quadword in storage at address EA. "
            ]
        },
        {
            "description": "Store Vector Indexed Last",
            "form": "X-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stvxl",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "487"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA &amp; 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "MEM(EA, 16) := VSR[VRS+32]",
                "",
                "mark_as_not_likely_to_be_needed_again_anytime_soon(EA)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of VSR[VRS+32] are placed into the ",
                "quadword in storage at address EA. ",
                "stvxl provides a hint that the quadword in storage ",
                "addressed by EA will probably not be needed again by ",
                "the program in the near future.",
                ""
            ]
        },
        {
            "description": "Store Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stw",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "36"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstw\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstw\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstw\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stw, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstw with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstw with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>32:63</sub> are stored into the word in storage addressed ",
                "by EA.",
                "",
                "For pstw, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Word:"
            ]
        },
        {
            "description": "Prefixed Store Word",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "pstw",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "36"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \u201cstw\u201d  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if \u201cpstw\u201d &amp; R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if \u201cpstw\u201d &amp; R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stw, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstw with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstw with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>32:63</sub> are stored into the word in storage addressed ",
                "by EA.",
                "",
                "For pstw, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Word:"
            ]
        },
        {
            "description": "Store Word Atomic",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "stwat",
                    "operands": [
                        "RS",
                        "RA",
                        "FC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "710"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "mem(EA,8):= stat(mem(EA,8), RS<sub>32:63</sub>, FC)"
            ],
            "body": [
                "Let the effective address (EA) be (RA).  Four or eight ",
                "bytes of storage at EA are updated as specified by ",
                "store atomic function code FC.  Input operands are ",
                "function code specific, and may include RS<sub>32:63</sub> and  ",
                "mem(EA,8).",
                "Figure4 contains the valid function codes.  An attempt ",
                "to execute stwat specifying an invalid function code will ",
                "cause the system data storage error handler to be ",
                "invoked.",
                "EA must be a multiple of 4, and the portion of  ",
                "mem(EA,8) accessed by the instruction must be con",
                "tained within an aligned 32-byte block of storage.  If ",
                "either of these requirements is not satisfied, the system ",
                "alignment error handler is invoked."
            ]
        },
        {
            "description": "Store Word Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stwbrx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "662"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> || (RS)<sub>40:47</sub>",
                "               ||(RS)<sub>32:39</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(RS)<sub>56:63</sub> are stored into bits 0:7 of the word in storage ",
                "addressed by EA. ",
                "(RS)<sub>48:55</sub> are stored into bits 8:15 of the word in storage ",
                "addressed by EA. ",
                "(RS)<sub>40:47</sub> are stored into bits 16:23 of the word in stor",
                "age addressed by EA. ",
                "(RS)<sub>32:39</sub> are stored into bits 24:31 of the word in stor",
                "age addressed by EA."
            ]
        },
        {
            "description": "Store Word Caching Inhibited Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "stwcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "917"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)<sub>32:63</sub> are stored into the word in ",
                "storage addressed by EA.",
                "The storage access caused by this instruction is per",
                "formed as though the specified storage location is ",
                "Caching Inhibited and Guarded.",
                "This instruction is hypervisor privileged."
            ]
        },
        {
            "description": "Store Word Conditional Indexed",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "stwcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "150"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                "  if RESERVE_LENGTH = 4 &amp;",
                "     RESERVE_ADDR = real_addr(EA) then",
                "      MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "",
                "      undefined_case  := 0",
                "      store_performed := 1",
                "   else",
                "      z := smallest real page size supported by ",
                "          implementation",
                "      if RESERVE_ADDR \u00b8 z = real_addr(EA) \u00b8 z then",
                "        undefined_case  := 1",
                "      else",
                "        undefined_case  := 0",
                "        store_performed := 0",
                "else",
                "  undefined_case  := 0",
                "  store_performed := 0",
                "if undefined_case then",
                "  u1 := undefined 1-bit value",
                "  if u1 then",
                "    MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "",
                "  u2 := undefined 1-bit value",
                "  CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "",
                "else",
                "  CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "",
                "",
                "RESERVE := 0"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB).",
                "If a reservation exists, the length associated with the ",
                "reservation is 4 bytes, and the real storage location ",
                "specified by the stwcx. is the same as the real storage ",
                "location specified by the lwarx instruction that estab",
                "lished the reservation, (RS)<sub>32:63</sub> are stored into the ",
                "word in storage addressed by EA.",
                "If a reservation exists, and either the length associated ",
                "with the reservation is not 4 bytes or the real storage ",
                "location specified by the stwcx. is not the same as the ",
                "real storage location specified by the lwarx instruction ",
                "that established the reservation, the following applies. ",
                "Let z denote the smallest real page size supported by ",
                "the implementation. If the real storage location speci",
                "fied by the stwcx. is in the same aligned z-byte block of ",
                "real storage as the real storage location specified by ",
                "the lwarx instruction that established the reservation, it ",
                "is undefined whether (RS)<sub>32:63</sub> are stored into the word ",
                "in storage addressed by EA. Otherwise, no store is per",
                "formed.",
                "If a reservation does not exist, no store is performed.",
                "CR Field 0 set ",
                "as follows. n is a 1-bit value that indicates whether the ",
                "store was performed, except that if, per the preceding ",
                "description, it is undefined whether the store is per",
                "formed, the value of n is undefined (and need not ",
                "reflect whether the store was performed).",
                "The reservation is cleared.",
                "EA must be a multiple of 4. If it is not, either the system ",
                "alignment error handler is invoked or the results are ",
                "boundedly undefined."
            ]
        },
        {
            "description": "Store Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stwx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "151"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. (RS)<sub>32:63</sub> are stored into the word in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Word with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stwu",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "37"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "(RS)<sub>32:63</sub> are stored into the word in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Word with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "stwux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "183"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. (RS)<sub>32:63</sub> are stored into the word in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Subtract From",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "subf",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subf.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subfo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subfo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "40"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + (RB) + 1"
            ],
            "body": [
                "The sum \u00ac(RA) + (RB) + 1 is placed into register RT.",
                "Example of extended mnemonics for Subtract From:"
            ]
        },
        {
            "description": "Subtract From Carrying",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "subfc",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfc.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfco",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfco.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + (RB) + 1"
            ],
            "body": [
                "The sum \u00ac(RA) + (RB) + 1 is placed into register RT.",
                "Example of extended mnemonics for Subtract From ",
                "Carrying:"
            ]
        },
        {
            "description": "Subtract From Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "subfe",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfe.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfeo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfeo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "136"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + (RB) + CA"
            ],
            "body": [
                "The sum \u00ac(RA) + (RB) + CA is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Immediate Carrying",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "subfic",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "8"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "RT := ~(RA) + EXTS(SI) + 1"
            ],
            "body": [
                "The sum \u00ac(RA) + SI + 1 is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Minus One Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "subfme",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfme.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfmeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfmeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "232"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + CA - 1"
            ],
            "body": [
                "The sum \u00ac(RA) + CA + 641 is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Zero Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "subfze",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfze.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfzeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfzeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "200"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + CA"
            ],
            "body": [
                "The sum \u00ac(RA) + CA is placed into register RT."
            ]
        },
        {
            "description": "Synchronize",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "sync",
                    "operands": [
                        "L",
                        "SC"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "L",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "SC",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "598"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if SC!=0 then switch(SC)",
                "     case(1): stncisync",
                "     case(2): stcisync",
                "     case(3): stsync",
                "else switch(L)"
            ],
            "body": [
                "The sync instruction creates a memory barrier (see ",
                "Section 1.7.1). The set of storage accesses and/or data ",
                "transfers that is ordered by the memory barrier ",
                "depends on the contents of the L and SC fields as fol",
                "lows.",
                "SC\u00b90",
                "",
                "SC=0",
                "The ordering done by the memory barrier is cumulative ",
                "(regardless of the L and SC values).",
                "If L=0 or L=4 (or L=2), the sync instruction has the fol",
                "lowing additional properties.",
                "The L values 3, 6, and 7 are reserved.",
                "The sync instruction may complete before storage ",
                "accesses associated with instructions preceding the ",
                "sync instruction have been performed.",
                "Figure5 shows the valid combinations of SC and L val",
                "ues.  Instructions that use any of these combinations ",
                "will execute correctly on processors that comply with ",
                "versions of the architecture that precede Version 3.1 (in ",
                "which versions the L field is two bits long, the SC field ",
                "does not exist, and bits 8 and 14:15 of the sync instruc",
                "tion are reserved) and on processors  that comply with ",
                "Version 3.1 and subsequent versions of the architec",
                "ture.  If any other combination is used, the instruction ",
                "form is invalid.",
                "  ",
                "  ",
                "  ",
                "Extended mnemonics for Synchronize: ",
                "Except in the sync instruction description in this sec",
                "tion, references to \u201csync\u201d in Books I-III imply L=0 ",
                "unless otherwise stated or obvious from context; the ",
                "appropriate extended mnemonics are used when other ",
                "L values are intended.  Throughout Books I-III, refer",
                "ences to the L field imply SC=0 unless otherwise stated ",
                "or obvious from context. The SC field is mentioned ",
                "explicitly, or the appropriate extended mnemonics are ",
                "used,  when non-zero SC values are intended.  Some ",
                "programming examples and recommendations assume ",
                "a programming model that does not include the ",
                "store-specific variants of sync.  Improved performance ",
                "may be achieved through the use of store-specific ",
                "memory barriers in some cases.",
                "  ",
                "  ",
                "  ",
                " "
            ]
        },
        {
            "description": "System Call",
            "form": "SC-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "sc",
                    "operands": [
                        "LEV"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "17"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "LEV",
                    "size": "7"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "System Call",
            "form": "SC-form",
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "sc",
                    "operands": [
                        "LEV"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "17"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "LEV",
                    "size": "7"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "SRR0 :=<sub>iea</sub> CIA + 4",
                "SRR1<sub>33:36 42:47</sub> := 0",
                "SRR1<sub>0:32 37:41 48:63</sub> := MSR<sub>0:32 37:41 48:63</sub>",
                "MSR := new_value (see below)",
                "NIA := 0x0000_0000_0000_0C00"
            ],
            "body": [
                "The effective address of the instruction following the ",
                "System Call instruction is placed into SRR0. Bits 0:32, ",
                "37:41, and 48:63 of the MSR are placed into the corre",
                "sponding bits of SRR1, and bits 33:36 and 42:47 of ",
                "SRR1 are set to zero.",
                "Then a System Call interrupt is generated. The inter",
                "rupt causes the MSR to be set as described in ",
                "Section7.5, \u201cInterrupt Definitions\u201d on page1296. The ",
                "setting of the MSR is affected by the contents of the ",
                "LEV field. LEV values greater than 2 are reserved. Bits ",
                "0:4 of the LEV field (instruction bits 20:24) are treated ",
                "as a reserved field.",
                "The interrupt causes the next instruction to be fetched ",
                "from effective address 0x0000_0000_0000_0C00.",
                "This instruction is context synchronizing.",
                "  ",
                "  ",
                ""
            ]
        },
        {
            "description": "System Call Vectored",
            "form": "SC-form",
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "scv",
                    "operands": [
                        "LEV"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "17"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "LEV",
                    "size": "7"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [],
            "body": [
                "These instructions call the system to perform a service. ",
                "A complete description of these instructions can be ",
                "found in Section4.3.1 of Book III.",
                "The first form of the instruction (sc) provides a single ",
                "system call. The second form of the instruction (scv) ",
                "provides the capability for 128 unique system calls.",
                "The use of the LEV field is described in Book III. In the ",
                "first form of the instruction the LEV values greater than ",
                "1 are reserved, and bits 0:5 of the LEV field (instruction ",
                "bits 20:25) are treated as a reserved field.",
                "When control is returned to the program that executed ",
                "the System Call or System Call Vectored instruction, ",
                "the contents of the registers will depend on the register ",
                "conventions used by the program providing the system ",
                "service.",
                "These instructions are context synchronizing (see Book ",
                "III).",
                "  ",
                "",
                ""
            ]
        },
        {
            "description": "System Call Vectored",
            "form": "SC-form",
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "scv",
                    "operands": [
                        "LEV"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "17"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "LEV",
                    "size": "7"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "1"
                }
            ],
            "code": [
                "LR := CIA + 4",
                "CTR<sub>33:36 42:47</sub> := undefined",
                "CTR<sub>0:32 37:41 48:63</sub> := MSR<sub>0:32 37:41 48:63</sub>",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "body": [
                "The effective address of the instruction following the ",
                "System Call Vectored instruction is placed into the Link ",
                "Register. Bits 0:32, 37:41, and 48:63 of the MSR are ",
                "placed into the corresponding bits of Count Register, ",
                "and bits 33:36 and 42:47 of Count Register are set to ",
                "undefined values.",
                "Then a System Call Vectored interrupt is generated. ",
                "The interrupt causes the MSR to be altered as ",
                "described in Section 7.5.",
                "The interrupt causes the next instruction to be fetched ",
                "",
                "",
                "as specified in LPCR<sub>AIL</sub> or ",
                "LPCR<sub>HAIL</sub> as appropriate (see Section 2.2)",
                ".",
                "The SRRs are not affected.",
                "This instruction is context synchronizing.",
                "",
                "",
                "",
                ""
            ]
        },
        {
            "description": "TLB Invalidate Entry",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "tlbie",
                    "operands": [
                        "RB",
                        "RS",
                        "RIC",
                        "PRS",
                        "R"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "RIC",
                    "size": "2"
                },
                {
                    "name": "PRS",
                    "size": "1"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "306"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "IS := (RB)<sub>52:53</sub>",
                "if MSR<sub>HV</sub>=1 then search_LPID=RS<sub>32:63</sub>",
                "else search_LPID=LPIDR<sub>LPID</sub>",
                "switch(IS)",
                "  case (0b00):",
                "    If RIC=0",
                "      if R=0 then",
                "        L := (RB)<sub>63</sub>",
                "        if L = 0",
                "          then",
                "            base_pg_size = 4K",
                "            actual_pg_size =  ",
                "              page size specified in (RB)<sub>56:58</sub>",
                "            i = 51",
                "          else",
                "            base_pg_size = ",
                "              base page size specified in (RB)<sub>44:51</sub>",
                "            actual_pg_size = ",
                "              actual page size specified in (RB)<sub>44:51</sub>",
                "            b := log_base_2(base_pg_size)",
                "            p := log_base_2(actual_pg_size)",
                "            i = max(min(43,63-b),63-p)",
                "        sg_size :=segment size specified in (RB)<sub>54:55</sub>",
                "        for each thread",
                "          for each TLB entry",
                "            if (entry_VA<sub>14:i+14</sub> = (RB)<sub>0:i</sub>) &amp;",
                "               (entry_sg_size = sg_size) &amp;",
                "               (entry_base_pg_size = base_pg_size) &amp;",
                "               (entry_actual_pg_size =",
                "                 actual_pg_size) &amp;",
                "               (entry_LPID = search_LPID) &amp;",
                "               (entry_process_scoped = 0) ",
                "            then",
                "              if ((L = 0)|(b \u00b3 20)) then",
                "                TLB entry := invalid",
                "              else",
                "                if (entry_VA<sub>58:77-b</sub> = (RB)<sub>56:75-b</sub>) then",
                "                  TLB entry := invalid",
                "      else",
                "        actual_pg_size =",
                "          page size specified in (RB)<sub>56:58</sub>",
                "        p := log_base_2(actual_pg_size)",
                "        i = 63-p",
                "        for each thread",
                "          for each TLB entry",
                "            if (entry_EA<sub>0:i</sub> = (RB)<sub>0:i</sub>) &amp;",
                "               (entry_actual_pg_size =",
                "                  actual_pg_size) &amp;",
                "               (entry_LPID = search_LPID) &amp;",
                "               (entry_process_scoped = PRS) &amp;",
                "               ((PRS = 0) |",
                "               (entry_PID = (RS)<sub>0:31</sub>))",
                "            then",
                "              TLB entry := invalid",
                "    else if RIC=3 then",
                "      sg_size := segment size specified in (RB)<sub>54:55</sub>",
                "      pg_size := f(GS)",
                "      number_of_pgs := g(GS)",
                "      p := log_base_2(pg_size)",
                "      n := log_base_2(number_of_pgs)",
                "      i := 63-p",
                "      va<sub>14:14+i</sub> := (RB)<sub>0:i-n</sub> || n0",
                "      do j=n0 to n1    # j=0 to 2n-1, in binary",
                "        for each thread",
                "          for each TLB entry",
                "            if (entry_VA<sub>14:14+i</sub> = (va<sub>14:14+i</sub>+j) &amp;",
                "            (entry_sg_size = sg_size) &amp;",
                "            (entry_base_pg_size = pg_size) &amp;",
                "            (entry_actual_pg_size = pg_size) &amp;",
                "            (entry_LPID = search_LPID) &amp;",
                "            (entry_process_scoped = 0)",
                "          then TLB entry := invalid",
                "  case (0b01):",
                "    if RIC=0 | RIC=2 then",
                "      for each TLB entry for each thread",
                "        if (entry_LPID=search_LPID)",
                "           &amp;(entry_PID=RS<sub>0:31</sub>)",
                "           &amp;(entry_PRS=1)",
                "          then TLB entry := invalid",
                "    if RIC=1 | RIC=2 then",
                "      for each thread",
                "        invalidate process-scoped radix page walk",
                "        caching associated with process RS<sub>0:31</sub> in",
                "        partition search_LPID",
                "    if (RIC=2)&amp;(PRS=1) then",
                "      for each thread",
                "        invalidate Process Table caching associated",
                "        with process RS<sub>0:31</sub> in partition search_LPID",
                "  case (0b10):",
                "    if RIC=0 | RIC=2 then",
                "      if (PRS=0)&amp;((MSR<sub>HV</sub>=1)|(R=0)) then",
                "        for each partition-scoped TLB entry for each",
                "        thread",
                "          if entry_LPID=search_LPID",
                "            then TLB entry := invalid",
                "      if PRS=1 then",
                "        for each process-scoped TLB entry for each",
                "        thread",
                "          if entry_LPID=search_LPID",
                "            then TLB entry := invalid",
                "    if RIC=1 | RIC=2 then",
                "      for each thread",
                "        if (PRS=0)&amp;(MSR<sub>HV</sub>=1) then",
                "          for each thread invalidate partition-",
                "          scoped page walk caching associated with",
                "          partition search_LPID",
                "        if PRS=1 then",
                "          for each thread invalidate process-scoped",
                "          page walk caching associated with",
                "          partition search_LPID",
                "    if RIC=2 then",
                "      if (PRS=0)&amp;(MSR<sub>HV</sub>=1) then",
                "        for each thread invalidate Partition Table",
                "        caching associated with partition",
                "        search_LPID",
                "      if PRS=1 then",
                "        for each thread invalidate Process Table",
                "        caching associated with partition ",
                "        search_LPID",
                "  case (0b11):",
                "    if RIC=0 | RIC=2 then",
                "      if MSR<sub>HV</sub> then",
                "        for all threads",
                "          if PRS=0 then",
                "            all partition-scoped TLB entries",
                "          :=invalid",
                "          else",
                "            all process-scoped TLB entries :=invalid",
                "      if (MSR<sub>HV</sub>=0)&amp;(PRS=1) then",
                "        for each process-scoped TLB entry for each",
                "        thread",
                "          if TLBE<sub>LPID</sub>=search_LPID",
                "            then TLB entry := invalid",
                "      if (MSR<sub>HV</sub>=0)&amp;(PRS=0)&amp;(R=0) then",
                "        for each partition-scoped TLB entry for",
                "        each thread",
                "          if TLBE<sub>LPID</sub>=search_LPID",
                "            then TLB entry := invalid",
                "    if RIC=1 | RIC=2 then",
                "      if MSR<sub>HV</sub> then",
                "        if PRS=0 then",
                "          for all threads",
                "            invalidate all partition-scoped",
                "            page walk caching",
                "        else",
                "          for all threads",
                "            invalidate all process-scoped",
                "            page walk caching",
                "      if (MSR<sub>HV</sub>=0) &amp; (PRS=1) then",
                "          for each thread invalidate process-scoped",
                "          page walk caching associated with",
                "          partition search_LPID",
                "    if RIC=2 then",
                "      if MSR<sub>HV</sub> then",
                "        if PRS=0 then",
                "          for each thread",
                "            invalidate all Partition Table caching",
                "        else",
                "          for each thread",
                "            invalidate all Process Table caching",
                "      if (MSR<sub>HV</sub>=0) &amp; (PRS=1) then",
                "        for each thread invalidate Process Table",
                "        caching associated with partition ",
                "        search_LPID",
                ""
            ],
            "body": [
                "",
                "The operation performed by this instruction is based on ",
                "the contents of registers RS and RB. The contents of ",
                "these registers are shown below, where IS is (RB)<sub>52:53</sub>   ",
                "and L is (RB)<sub>63</sub>.",
                "RS:",
                " ",
                "",
                "RB for R=1 and IS=0b00:",
                "RB for R=0, IS=0b00, RIC\u00b93, and L=0:",
                "RB for R=0, IS=0b00, RIC\u00b93, and L=1:",
                "RB for R=0, IS=0b00, and RIC=3:",
                "RB for IS=0b01, 0b10, or 0b11:",
                "If this instruction is executed in hypervisor state, ",
                "RS<sub>32:63</sub> contains the partiion ID (LPID) of the partition ",
                "for which one or more translations are being invali",
                "dated.  Otherwise, the value in LPIDR is used. The ",
                "supported (RS)<sub>32:63</sub> values are the same as the LPID ",
                "values supported in LPIDR. RS<sub>0:31</sub> contains a PID ",
                "value.  The supported values of RS<sub>0:31</sub> are the same as ",
                "the PID values supported in PIDR.",
                "The following forms are invalid.",
                "The following forms are treated as if the instruction ",
                "form were invalid.",
                "The results of an attempt to invalidate a translation out",
                "side of quadrant 0 for Radix Tree translation (R=1, ",
                "RIC=0, PRS=1,  IS=0, and EA<sub>0:1</sub>\u00b90b00) are boundedly ",
                "undefined.",
                "If RIC=0, this is a search for a single TLB entry.  The ",
                "following relationships must be true and tests and ",
                "actions are performed to search for an HPT translation.",
                "The following relationships must be true and tests and ",
                "actions are performed to search for a Radix Tree trans",
                "lation.  For a partition-scoped invalidation, references ",
                "to the effective address are understood to refer to the ",
                "guest real address.",
                "If RIC=3, then the TLB entries mapping an aligned ",
                "sequence of virtual pages are made invalid on all ",
                "threads.  The number of virtual pages in the sequence, ",
                "and their page size (base page size = actual page ",
                "size), are provided using an implementation-specific ",
                "encoding of the GS field of RB. The number of virtual ",
                "pages is a power of two.  The abbreviated virtual ",
                "address of the beginning of the sequence is provided ",
                "by the AVA field of RB with the appropriate number of ",
                "low-order bits treated as zero to cause the affected ",
                "region of VA space to be aligned at a multiple of its ",
                "size.  The effect is as if a tlbie instruction with ",
                "RIC=PRS=R=0 were executed for each virtual page in ",
                "the sequence, using the supplied contents of RS and ",
                "RB except using the AVA value corresponding to the ",
                "virtual page and using the base and actual page size ",
                "provided by GS.",
                "If RIC=0 or RIC=2, all partition-scoped TLB entries ",
                "when PRS=0 and either MSR<sub>HV</sub>=1 or R=0, or all pro",
                "cess-scoped TLB entries when PRS=1 on all threads ",
                "for which any of the following conditions are met for the ",
                "entry are made invalid.",
                "If RIC=1 or RIC=2, if the following conditions are met, ",
                "the respective partition-scoped contents when PRS=0 ",
                "and MSR<sub>HV</sub>=1 or process-scoped contents when ",
                "PRS=1 of the page walk cache are invalidated.  ",
                "If RIC=2, if the following conditions are met, the respec",
                "tive partition and Process Table caching are invalidated ",
                "for all threads.  ",
                "When i&gt;40, RB<sub>40:i-1</sub> may contain any value and are ",
                "ignored by the hardware.",
                "For all threads, any implementation specific lookaside ",
                "information that is based on any TLB entry that would ",
                "be invalidated by this instruction will also be invali",
                "dated.",
                "MSR<sub>SF</sub> must be 1 when this instruction is executed; ",
                "otherwise the results are undefined.",
                "If the value specified in RS<sub>0:31</sub>, RS<sub>32:63</sub>, RB<sub>54:55</sub> when ",
                "R=0, RB<sub>56:58</sub> when RB<sub>63</sub>=0, or RB<sub>44:51</sub> when RB<sub>63</sub>=1 ",
                "is not supported by the implementation, the instruction ",
                "is treated as if the instruction form were invalid.",
                "The operation performed by this instruction is ordered ",
                "by the eieio (or [p]hwsync or ptesync) instruction with ",
                "respect to a subsequent tlbsync instruction executed ",
                "by the thread executing the tlbie instruction. The oper",
                "ations caused by tlbie and tlbsync are ordered by ",
                "eieio as a fourth set of operations, which is indepen",
                "dent of the other four sets that eieio orders. ",
                "This instruction is privileged except when LPCR<sub>GTSE</sub>=0 ",
                "or when PRS=0 and HR=1, making it hypervisor privi",
                "leged.",
                "See Section6.10, \u201cTranslation Table Update Synchro",
                "nization Requirements\u201d for a description of other ",
                "requirements associated with the use of this instruction.",
                "None",
                "Extended mnemonic for tlbie::",
                "",
                "  ",
                "  ",
                "  ",
                "   ",
                "",
                "  ",
                "  ",
                "  ",
                " ",
                " "
            ]
        },
        {
            "description": "TLB Invalidate Entry Local",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "tlbiel",
                    "operands": [
                        "RB",
                        "RS",
                        "RIC",
                        "PRS",
                        "R"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "RIC",
                    "size": "2"
                },
                {
                    "name": "PRS",
                    "size": "1"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "274"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "IS := (RB)<sub>52:53</sub>",
                "search_LPID=LPIDR<sub>LPID</sub>",
                "switch(IS)",
                "  case (0b00):",
                "    If RIC=0",
                "      If R=0",
                "        L := (RB)<sub>63</sub>",
                "        if L = 0  then",
                "          base_pg_size = 4K",
                "          actual_pg_size =",
                "            page size specified in (RB)<sub>56:58</sub>",
                "          i = 51",
                "        else",
                "          base_pg_size = base page size specified",
                "            in (RB)<sub>44:51</sub>",
                "          actual_pg_size =",
                "            actual page size specified in (RB)<sub>44:51</sub>",
                "          b := log_base_2(base_pg_size)",
                "          p := log_base_2(actual_pg_size)",
                "          i = max(min(43,63-b),63-p)",
                "        sg_size:=segment size specified in (RB)<sub>54:55</sub>",
                "        for each TLB entry",
                "          if (entry_VA<sub>14:i+14</sub> = (RB)<sub>0:i</sub>) &amp;",
                "             (entry_sg_size = segment_size) &amp;",
                "             (entry_base_pg_size = base_pg_size) &amp;",
                "             (entry_actual_pg_size =actual_pg_size)&amp;",
                "             (TLBE<sub>LPID</sub>=search_LPID) &amp;",
                "             (entry_process_scoped=0)",
                "            then",
                "              if ((L = 0)|(b \u00b3 20)) then",
                "                  TLB entry := invalid",
                "              else",
                "                if (entry_VA<sub>58:77-b</sub> = (RB)<sub>56:75-b</sub>) then",
                "                   TLB entry := invalid",
                "      else",
                "        pg_size = page size specified in (RB)<sub>56:58</sub>",
                "        p := log_base_2(pg_size)",
                "        i = 63-p",
                "        for each TLB entry",
                "          if (entry_EA<sub>0:i</sub> = (RB)<sub>0:i</sub>) &amp;",
                "             (entry_pg_size = pg_size) &amp;",
                "             (entry_LPID = search_LPID) &amp;",
                "             (entry_process_scoped = PRS) &amp;",
                "             ((PRS = 0) |",
                "             (entry_PID = (RS)<sub>0:31</sub>))",
                "          then",
                "            TLB entry := invalid",
                "  case (0b01):",
                "    if SET=0 then",
                "      if RIC=0 | RIC=2 then",
                "        for each TLB entry",
                "          if (entry_LPID=search_LPID)",
                "             &amp;(entry_PID=RS<sub>0:31</sub>)",
                "             &amp;(entry_PRS=1)",
                "            then TLB entry := invalid",
                "      if RIC=1 | RIC=2 then",
                "        invalidate process-scoped radix page walk",
                "        caching associated with process RS<sub>0:31</sub> in",
                "        partition search_LPID",
                "      if (RIC=2)&amp;(PRS=1) then",
                "        invalidate Process Table caching associated",
                "        with process RS<sub>0:31</sub> in partition search_LPID",
                "  case (0b10):",
                "    if SET=0 then",
                "      if RIC=0 | RIC=2 then",
                "        if (PRS=0)&amp;((MSR<sub>HV</sub>=1)|(R=0)) then",
                "          for each partition-scoped TLB entry",
                "            if entry_LPID=search_LPID",
                "              then TLB entry := invalid",
                "        if PRS=1 then",
                "          for each process-scoped TLB entry",
                "            if entry_LPID=search_LPID",
                "              then TLB entry := invalid",
                "      if RIC=1 | RIC=2 then",
                "        if (PRS=0)&amp;(MSR<sub>HV</sub>=1) then",
                "          invalidate partition-scoped page walk",
                "          caching associated with partition",
                "          search_LPID",
                "        if PRS=1 then",
                "          invalidate process-scoped page walk ",
                "          caching associated with partition",
                "          search_LPID",
                "      if RIC=2 then",
                "        if (PRS=0)&amp;(MSR<sub>HV</sub>=1) then",
                "          invalidate Partition Table caching",
                "          associated with partition search_LPID",
                "        if PRS=1 then",
                "          invalidate Process Table caching ",
                "          associated with partition search_LPID",
                "  case (0b11):",
                "    if SET=0 then",
                "      if RIC=0 | RIC=2 then",
                "        if MSR<sub>HV</sub> then",
                "          if PRS=0 then",
                "            all partition-scoped TLB entries",
                "                          :=invalid",
                "          else",
                "            all process-scoped TLB entries :=invalid",
                "        if (MSR<sub>HV</sub>=0)&amp;(PRS=1) then",
                "          for each process-scoped TLB entry",
                "            if entry_LPID=search_LPID",
                "              then TLB entry := invalid",
                "        if (MSR<sub>HV</sub>=0)&amp;(PRS=0)&amp;(R=0) then",
                "          for each partition-scoped TLB entry",
                "            if entry_LPID=search_LPID",
                "              then TLB entry := invalid",
                "      if RIC=1 | RIC=2 then",
                "        if MSR<sub>HV</sub> then",
                "          if PRS=0 then",
                "            invalidate all partition-scoped",
                "            page walk caching",
                "          else",
                "            invalidate all process-scoped",
                "            page walk caching",
                "        if (MSR<sub>HV</sub>=0) &amp; (PRS=1) then",
                "            invalidate process-scoped page walk",
                "            caching associated with partition",
                "            search_LPID",
                "      if RIC=2 then",
                "        if MSR<sub>HV</sub> then",
                "          if PRS=0 then",
                "            invalidate all Partition Table caching",
                "          else",
                "            invalidate all Process Table caching",
                "        if (MSR<sub>HV</sub>=0) &amp; (PRS=1) then",
                "          invalidate Process Table caching ",
                "          associated with partition search_LPID"
            ],
            "body": [
                "The operation performed by this instruction is based on ",
                "the contents of registers RS and RB. The contents of ",
                "these registers are shown below, where IS is (RB)<sub>52:53</sub> ",
                "and L is (RB)<sub>63</sub>.",
                "RS:",
                " ",
                "",
                "RB for R=1 and IS=0b00:",
                "",
                "RB for R=0, IS=0b00, and L=0:",
                "",
                "RB for R=0, IS=0b00, and L=1:",
                "",
                "RB for IS=0b01, 0b10, or 0b11:",
                "",
                "   ",
                "LPIDR contains the partiion ID (LPID) of the partition ",
                "for which the translation is being invalidated.  RS<sub>0:31</sub> ",
                "contains a PID value.  The supported values of RS<sub>0:31</sub> ",
                "are the same as the PID values supported in PIDR.",
                "The following forms are invalid.",
                "The following forms are treated as though the instruc",
                "tion form was invalid.",
                "The results of an attempt to invalidate a translation out",
                "side of quadrant 0 for Radix Tree translation (R=1, ",
                "RIC=0, PRS=1,  IS=0, and EA<sub>0:1</sub>\u00b90b00) are boundedly ",
                "undefined.",
                "IS field in RB contains 0b00",
                "If RIC=0, this is a search for a single TLB entry.  The ",
                "following relationships must be true and tests and ",
                "actions are performed to search for an HPT translation.",
                "The following relationships must be true and tests and ",
                "actions are performed to search for a Radix Tree trans",
                "lation.  For a partition-scoped invalidation, references ",
                "to the effective address are understood to refer to the ",
                "guest real address.",
                "IS field in RB is non-zero",
                "When SET=0 is specified and either RIC=0 or RIC=2, ",
                "each partition-scoped entry when PRS=0 and either ",
                "MSR<sub>HV</sub>=1 or R=0, or each process-scoped entry when ",
                "PRS=1 is invalidated if any of the following conditions ",
                "are met for the entry.",
                " ",
                "When SET=0  is specified and either RIC=1 or RIC=2, ",
                "if the following conditions are met, the respective parti",
                "tion-scoped contents when PRS=0 and MSR<sub>HV</sub>=1 or ",
                "process-scoped contents when PRS=1 of the page ",
                "walk cache are invalidated.  ",
                "When SET=0 is specified and RIC=2, if the following ",
                "conditions are met, the respective partition and Pro",
                "cess Table caching are invalidated.  ",
                " ",
                "Any implementation specific lookaside information that ",
                "is based on any TLB entry that would be invalidated by ",
                "this instruction will also be invalidated.",
                "Depending on the variant of the instruction, RB<sub>0:39</sub>, ",
                "RB<sub>59:62</sub>, RB<sub>59:63</sub>, RB<sub>54:55</sub>, and RB<sub>54:63 </sub> are the equiva",
                "lent of reserved fields, should contain 0s, and are ",
                "ignored by the hardware.  RS<sub>32:63</sub> is always the equiva",
                "lent of a reserved field, should contain 0s, and is ",
                "ignored by the hardware.",
                "Only TLB entries, page walk caching, and process and ",
                "Segment Table caching on the thread executing the ",
                "tlbiel instruction are affected.",
                "MSR<sub>SF</sub> must be 1 when this instruction is executed; ",
                "otherwise the results are boundedly undefined.",
                "If the value specified in RS<sub>0:31</sub>, RB<sub>54:55</sub>, RB<sub>56:58</sub>, or ",
                "RB<sub>44:51</sub>, when it is needed to perform the specified ",
                "operation, is not supported by the implementation, the ",
                "instruction is treated as if the instruction form were ",
                "invalid.",
                "This instruction is privileged except when PRS=0 and ",
                "HR=1, making it hypervisor privileged.",
                "See Section6.10, \u201cTranslation Table Update Synchro",
                "nization Requirements\u201d on page1275 for a description ",
                "of other requirements associated with the use of this ",
                "instruction.",
                "Extended mnemonic for tlbiel::",
                "",
                "",
                "",
                "  ",
                "   ",
                "  ",
                "",
                " ",
                ""
            ]
        },
        {
            "description": "TLB Synchronize",
            "form": "X-form",
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "tlbsync",
                    "operands": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "566"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The tlbsync instruction provides an ordering function ",
                "for the effects of all tlbie instructions executed by the ",
                "thread executing the tlbsync instruction, with respect ",
                "to the memory barrier created by a subsequent pte",
                "sync instruction executed by the same thread. Execut",
                "ing a tlbsync instruction ensures that all of the ",
                "following will occur.",
                "The operation performed by this instruction is ordered ",
                "by the eieio (or [p]hwsync or ptesync) instruction with ",
                "respect to preceding tlbie instructions executed by the ",
                "thread executing the tlbsync instruction. The opera",
                "tions caused by tlbie and tlbsync are ordered by eieio ",
                "as a fourth set of operations, which is independent of ",
                "the other three sets that eieio orders.",
                "The tlbsync instruction may complete before opera",
                "tions caused by tlbie instructions preceding the tlb",
                "sync instruction have been performed.",
                "This instruction is privileged except when LPCR<sub>G</sub>",
                "TSE=0, making it hypervisor privileged.",
                "See Section6.10 for a description of other require",
                "ments associated with the use of this instruction.",
                "  ",
                "",
                "This section describes rules that software must follow ",
                "when updating the Translation Tables, and includes ",
                "suggested sequences of operations for some represen",
                "tative cases.  The sequences required for other cases ",
                "may be deduced from the sequences that are provided ",
                "and from this accompanying description.",
                "In the sequences of operations shown in the following ",
                "subsections, the Page Table Entry is assumed to be for ",
                "a virtual page for which the base page size is equal to ",
                "the actual page size. If these page sizes are different, ",
                "multiple tlbie instructions are needed, one for each ",
                "PTE corresponding to the virtual page.",
                "In the sequences of operations shown in the following ",
                "subsections, any alteration of a translation table entry  ",
                "that corresponds to a single line in the sequence is ",
                "assumed to be done using a Store instruction for which ",
                "the access is atomic. Appropriate modifications must ",
                "be made to these sequences if this assumption is not ",
                "satisfied (e.g., if a store doubleword operation is done ",
                "using two Store Word instructions).",
                "Two correctness-related considerations when choosing ",
                "translation table update sequences are to be safe for ",
                "multiple asynchronous sources of update (potentially ",
                "both hardware and software), and to avoid paradoxes ",
                "that in some cases could show up as multi-hits in the ",
                "various translation caches.  These considerations lead ",
                "to the simple, contiguous sequences for general case ",
                "updates that appear later in this section.  Good perfor",
                "mance is a third consideration that motivates deferring ",
                "and/or batching invalidations or even omitting synchro",
                "nization or invalidation from the general case.  The via",
                "bility of these techniques is determined by whether the ",
                "lack of a single clear state across the system has prob",
                "lematic repercussions.  The discussion of atomic Refer",
                "ence and Change bit updates alludes to one such ",
                "example.  (See Section6.7.12.)  Simpler optimizations ",
                "are illustrated below.",
                "The following are guidelines for safety when multiple ",
                "sources of asynchronous updates are possible.  To ",
                "interact correctly with hardware that atomically updates ",
                " bits (as well as with ",
                "updates from other software threads), software should ",
                "use atomic updates to modify valid PTEs.  Academi",
                "cally speaking, if hardware uses simple loads and ",
                "stores, software may either use locking and first invali",
                "date the PTE and cached translations, or may attempt ",
                "to optimize using atomic updates that don\u2019t change the ",
                "values of the bytes containing the ",
                " bits with the exception of potentially set",
                "ting those specific bits to 1 or the Reference bit to 0.  ",
                "When modifying only bytes not subject to hardware ",
                "modification, software may use either locking or atomic ",
                "updates, subject to the limitations and optimizations ",
                "described below.  The realities of  ",
                " bit placement may severely limit what opti",
                "mizations are possible when hardware uses normal ",
                "loads and stores to update those bits.",
                "To simplify verification and avoid paradoxes, ",
                "non-impactful limitations are placed on translation table ",
                "update sequence optimizations.  One limitation is that ",
                "software must not have two or more valid overlapping ",
                "translations at any level of the translation process with ",
                "different page or segment sizes.  This means that one ",
                "translation must be marked invalid in the translation ",
                "table and invalidated from any caches prior to instating ",
                "the second.  The other limitation is that software must ",
                "not have two or more valid translations with different ",
                "attributes (i.e. WIMG, ATT).  The example of I=1 and ",
                "I=0 is obvious, but in general there is not enough to be ",
                "gained to attempt to avoid invalidating one attribute set",
                "ting before establishing another.  In both of these ",
                "cases, the translation cache invalidation may lag indefi",
                "nitely behind the table entry invalidations and the cache ",
                "invalidations may be batched, but must precede ",
                "enabling the new attributes.",
                "To protect software\u2019s ability to have reasonable perfor",
                "mance, optimizations that hardware must support are ",
                "also identified.  (These optimizations are understood to ",
                "be limited by the techniques used for hardware and ",
                "software updates as described above, and by the prop",
                "erties of the table structure itself.  A convention for ",
                "atomic updates will yield more opportunity than locking.  ",
                "Hardware that does not use atomic updates may limit ",
                "or eliminate the opportunity for software to optimize.  ",
                "The table structure for Radix Tree translation will yield ",
                "more opportunity than the dual PTEG structure of HPT ",
                "translation.)  Access authority downgrades and setting ",
                "Change bits to zero may be done without first marking ",
                "the PTE invalid and invalidating the translation caches.  ",
                "The translation cache invalidation may lag the PTE ",
                "change indefinitely and be done in bulk.  Access ",
                "authority upgrades and setting Reference and Change ",
                "bits to 1 may be done without any PTE or translation ",
                "cache invalidation.  Software bits may be changed ",
                "without any PTE or translation cache invalidation.  ",
                "Finally, any complete change to the RPN (non-overlap",
                "ping with the original value) does not of itself require ",
                "synchronization (though other changes to the PTE ",
                "made at the same time might).",
                "In the following examples, when the same type of ",
                "sequence works for both types of translation, the HPT ",
                "PTE is shown because it is more complex.  In this ",
                "description, and in references in subsequent subsec",
                "tions to \u201csafe for multithreaded software,\u201d the safety is ",
                "with respect to the risk of one thread overwriting ",
                "another\u2019s update.  There may also be concern for the ",
                "creation of multiple matching translations, e.g. within a ",
                "PTEG or pair of PTEGs.  When the reservation granule ",
                "is equal to or larger in size than the structure on which ",
                "mutual exclusion must be ensured (e.g. PTE for Radix ",
                "Tree translation but PTEG for HPT translation), multiple ",
                "entries will also be prevented.  (Secondary hash ",
                "groups will generally not be covered by the same reser",
                "vation granule as primary hash groups.)",
                "Updates (by software) to the tables are performed only ",
                "when they are known to be required by the sequential ",
                "execution model (see Section 6.5).  Because address ",
                "translation for instructions preceding a given Store ",
                "instruction might cause an interrupt, and thereby pre",
                "vent the corresponding store from being required by ",
                "the sequential execution model, address translations ",
                "for instructions preceding the Store instruction must be ",
                "performed before the corresponding store is per",
                "formed.  As a result, an update to a translation table ",
                "need not be preceded by a context synchronizing ",
                "instruction.",
                "All of the sequences require a context synchronizing ",
                "operation after the sequence if the new contents of the ",
                "translation table are to be used for address translations ",
                "associated with subsequent instructions.",
                "As noted in the description of the Synchronize instruc",
                "tion in Section4.6.3 of Book II, address translation ",
                "associated with instructions which occur in program ",
                "order subsequent to the Synchronize (and this includes ",
                "the ptesync variant) may be performed prior to the ",
                "completion of the Synchronize. To ensure that these ",
                "instructions and data which may have been specula",
                "tively fetched are discarded, a context synchronizing ",
                "operation is required.",
                "  ",
                "Translation table entries must not be changed in a ",
                "manner that causes an implicit branch."
            ]
        },
        {
            "description": "Trap Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "td",
                    "operands": [
                        "TO",
                        "RA",
                        "RB"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "68"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "a := (RA)",
                "b := (RB)",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "if (a &lt; b) &amp; TO<sub>0</sub>",
                "",
                " then TRAP",
                "if (a &gt; b) &amp; TO<sub>1</sub>",
                "",
                "",
                " then TRAP",
                "if (a = b) &amp; TO<sub>2</sub>",
                "",
                "",
                " then TRAP",
                "if (a &lt;<sup>u</sup> b) &amp; TO<sub>3</sub> then TRAP",
                "if (a &gt;<sup>u</sup> b) &amp; TO<sub>4</sub> ",
                " then TRAP"
            ],
            "body": [
                "The contents of register RA are compared with the con",
                "tents of register RB. ",
                "",
                " any bit in the TO field is set to 1 and its corre",
                "sponding condition is met by the result of the compari",
                "son, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "Examples of extended mnemonics for Trap Double",
                "word:"
            ]
        },
        {
            "description": "Trap Doubleword Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "tdi",
                    "operands": [
                        "TO",
                        "RA",
                        "SI"
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "2"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "a := (RA)",
                "b := EXTS(SI)",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "if (a &lt; b) &amp; TO<sub>0</sub>",
                "",
                " then TRAP",
                "if (a &gt; b) &amp; TO<sub>1</sub>",
                "",
                "",
                " then TRAP",
                "if (a = b) &amp; TO<sub>2</sub>",
                "",
                "",
                " then TRAP",
                "if (a &lt;<sup>u</sup> b) &amp; TO<sub>3</sub> then TRAP",
                "if (a &gt;<sup>u</sup> b) &amp; TO<sub>4</sub> ",
                " then TRAP"
            ],
            "body": [
                "The contents of register RA are compared with the ",
                "sign-extended value of the SI field. ",
                "",
                "any bit in the TO field is set to 1 ",
                "and its corresponding condition is met by the result of ",
                "the comparison, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "Examples of extended mnemonics for Trap Double",
                "word Immediate:"
            ]
        },
        {
            "description": "Trap Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "tw",
                    "operands": [
                        "TO",
                        "RA",
                        "RB"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "4"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "a := EXTS((RA)<sub>32:63</sub>)",
                "b := EXTS((RB)<sub>32:63</sub>)",
                "if (a &lt; b) &amp; TO<sub>0</sub> then TRAP",
                "if (a &gt; b) &amp; TO<sub>1</sub> then TRAP",
                "if (a = b) &amp; TO<sub>2</sub> then TRAP",
                "if (a &lt;<sup>u</sup> b) &amp; TO<sub>3</sub> then TRAP",
                "if (a &gt;<sup>u</sup> b) &amp; TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "The contents of RA<sub>32:63</sub> are compared with the contents ",
                "of RB<sub>32:63</sub>. If any bit in the TO field is set to 1 and its cor",
                "responding condition is met by the result of the compar",
                "ison, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "Examples of extended mnemonics for Trap Word:"
            ]
        },
        {
            "description": "Trap Word Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "twi",
                    "operands": [
                        "TO",
                        "RA",
                        "SI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "3"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "a := EXTS((RA)<sub>32:63</sub>)",
                "if (a &lt; EXTS(SI)) &amp; TO<sub>0</sub>  then TRAP",
                "if (a &gt; EXTS(SI)) &amp; TO<sub>1</sub>  then TRAP",
                "if (a = EXTS(SI)) &amp; TO<sub>2</sub>  then TRAP",
                "if (a &lt;<sup>u</sup> EXTS(SI)) &amp; TO<sub>3</sub> then TRAP",
                "if (a &gt;<sup>u</sup> EXTS(SI)) &amp; TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "The contents of RA<sub>32:63</sub> are compared with the ",
                "sign-extended value of the SI field. If any bit in the TO ",
                "field is set to 1 and its corresponding condition is met ",
                "by the result of the comparison, the system trap han",
                "dler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "Examples of extended mnemonics for Trap Word ",
                "Immediate:"
            ]
        },
        {
            "description": "Ultravisor Return From Interrupt Doubleword",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "urfid",
                    "operands": [],
                    "release": "v3.0C"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "306"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "",
                "",
                "",
                "",
                "MSR<sub>48</sub> := USRR1<sub>48</sub> | USRR1<sub>49</sub>",
                "MSR<sub>58</sub> := (USRR1<sub>58</sub> | USRR1<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(USRR1<sub>41 </sub><sub>&amp; USRR1</sub><sub>3 </sub><sub>&amp; (</sub>~USRR1<sub>49</sub><sub>))</sub>",
                "MSR<sub>59</sub> := (USRR1<sub>59</sub> | USRR1<sub>49</sub><sub>)</sub>",
                "<sub>    &amp; </sub>~(USRR1<sub>41 </sub><sub>&amp; USRR1</sub><sub>3 </sub><sub>&amp; (</sub>~USRR1<sub>49</sub><sub>))</sub>",
                "",
                "NIA :=<sub>iea</sub> USRR0<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "",
                "",
                "",
                "",
                "",
                " The result of ",
                "ORing bits 48 and 49 of USRR1 is placed into MSR<sub>48</sub>.  ",
                "The result of ANDing bit 41 of USRR1 with bit 3 of ",
                "USRR1 and with the complement of bit 49 of USRR1 is ",
                "complemented and then ANDed with the result of ",
                "ORing bits 58 and 49 of USRR1 and placed into ",
                "MSR<sub>58</sub>. The result of ANDing bit 41 of USRR1 with bit 3 ",
                "of USRR1 and with the complement of bit 49 of USRR1 ",
                "is complemented and then ANDed with the result of ",
                "ORing bits 59 and 49 of USRR1 and placed into ",
                "MSR<sub>59</sub>. ",
                "",
                ".",
                "If the new MSR value does not enable any pending ",
                "exceptions, then the next instruction is fetched, under ",
                "control of the new MSR value, from the address ",
                "USRR0<sub>0:61</sub> || 0b00 (when SF=1 in the new MSR value) ",
                "or <sup>32</sup>0 || USRR0<sub>32:61</sub> || 0b00 (when SF=0 in the new ",
                "MSR value). If the new MSR value enables one or ",
                "more pending exceptions, the interrupt associated with ",
                "the highest priority pending exception is generated; in ",
                "this case the value placed into SRR0, HSRR0, or ",
                "USRR0 by the interrupt processing mechanism (see ",
                "Section 7.4.3) is the address of the instruction that ",
                "would have been executed next had the interrupt not ",
                "occurred.",
                "This instruction is ultravisor privileged and context syn",
                "chronizing.",
                "Special Registers Altered:",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Move From Accumulator",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxmfacc",
                    "operands": [
                        "AS"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "AS",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "177"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[4\u00d7AS]   := ACC[AS][0]",
                "VSR[4\u00d7AS+1] := ACC[AS][1]",
                "VSR[4\u00d7AS+2] := ACC[AS][2]",
                "VSR[4\u00d7AS+3] := ACC[AS][3]"
            ],
            "body": [
                "For each integer value i from 0 to 3, the contents of ",
                "row i of ACC[AS] are placed into VSR[4\u00d7AS+i]."
            ]
        },
        {
            "description": "VSX Move To Accumulator",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxmtacc",
                    "operands": [
                        "AT"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "177"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ACC[AT][0] := VSR[4\u00d7AT]",
                "ACC[AT][1] := VSR[4\u00d7AT+1]",
                "ACC[AT][2] := VSR[4\u00d7AT+2]",
                "ACC[AT][3] := VSR[4\u00d7AT+3]"
            ],
            "body": [
                "For each integer value i from 0 to 3, the contents of ",
                "VSR[4\u00d7AT+i] are placed into row i of ACC[AT]."
            ]
        },
        {
            "description": "VSX Scalar Absolute Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "345"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32\u00d7BX+B].dword[0]",
                "VSR[32\u00d7TX+T].dword[0] := bfp64_NEGATIVE_ABSOLUTE(src)",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The absolute value of the double-precision ",
                "floating-point operand in doubleword element 0 of ",
                "VSR[XB] is placed into doubleword element 0 of VSR[XT] ",
                "in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                " "
            ]
        },
        {
            "description": "VSX Scalar Absolute Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsabsqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "804"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATIVE_ABSOLUTE(VSR[VRB+32])"
            ],
            "body": [
                "Let XT be the value VRT + 32.",
                "The absolute value of the quadprecision floating-point ",
                "value in VSR[XB] is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Scalar Add Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsadddp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "32"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[VRA+32].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v      := bfp_ADD(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is added to src1, producing a sum having ",
                "unbounded range and precision.",
                "The sum is normalized.",
                "See Table61, \u201cActions for xsadddp,\u201d on page674.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Add Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsaddqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "4"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_ADD(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "if ox_flag=1     then SetFX(FPSCR.OX)",
                "if ux_flag=1     then SetFX(FPSCR.UX)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1.",
                "If src1 and src2 are Infinity values having opposite ",
                "signs, an Invalid Operation exception occurs and VXISI ",
                "is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 and src2 are Infinity values having ",
                "opposite signs, the result is the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Add Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsaddsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "0"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[VRA+32].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v        := bfp_ADD(src1, src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is added to src1, producing a sum having ",
                "unbounded range and precision.",
                "The sum is normalized.",
                "See Table64, \u201cActions for xsaddsp,\u201d on page679.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Compare Equal Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpeqdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "3"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "",
                "if vex_flag=0 then do",
                "   if src1=src2 then",
                "      VSR[32\u00d7TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "      VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "   else do",
                "      VSR[32\u00d7TX+T].dword[0] := 0x0000_0000_0000_0000",
                "      VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, equal.",
                "The contents of doubleword 0 of VSR[XT] are set to ",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is equal to src2, and are ",
                "set to 0x0000_0000_0000_0000 otherwise.",
                "The contents of doubleword 1 of VSR[XT] are set to ",
                "0x0000_0000_0000_0000.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Compare Equal Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpeqqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "68"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, equal.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "equal to src2, and are set to all 0s otherwise.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Compare Exponents Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpexpdp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "59"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 ~ VSR[32\u00d7AX+A].dword[0]",
                "src2 ~ VSR[32\u00d7BX+B].dword[0]",
                "",
                "src1.exponent ~ EXTZ(src1.bit[1:11])",
                "src2.exponent ~ EXTZ(src2.bit[1:11])",
                "src1.fraction ~ EXTZ(src1.bit[12:63])",
                "src2.fraction ~ EXTZ(src2.bit[12:63])",
                "",
                "src1.class.NaN ~ (src1.exponent = 2047) &amp; (src1.fraction != 0)",
                "src2.class.NaN ~ (src2.exponent = 2047) &amp; (src2.fraction != 0)",
                "",
                "lt_flag ~ (src1.exponent &lt; src2.exponent)",
                "gt_flag ~ (src1.exponent &gt; src2.exponent)",
                "eq_flag ~ (src1.exponent = src2.exponent)",
                "uo_flag ~ src1.class.NaN | src2.class.NaN",
                "",
                "CR.bit[4\u00d7BF+32] ~ FPSCR.FL ~ !uo_flag &amp; lt_flag",
                "CR.bit[4\u00d7BF+33] ~ FPSCR.FG ~ !uo_flag &amp; gt_flag",
                "CR.bit[4\u00d7BF+34] ~ FPSCR.FE ~ !uo_flag &amp; eq_flag",
                "CR.bit[4\u00d7BF+35] ~ FPSCR.FU ~  uo_flag"
            ],
            "body": [
                "Let XA be the sum 32\u00d7AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The exponent of src1 is compared with the exponent of ",
                "src2. The result of the compare is placed into FPCC and ",
                "CR field BF."
            ]
        },
        {
            "description": "VSX Scalar Compare Exponents Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpexpqp",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "164"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src1           := VSR[VRA+32]",
                "src2           := VSR[VRB+32]",
                "",
                "src1.exponent  := EXTZ(src1.bit[1:15])",
                "src2.exponent  := EXTZ(src2.bit[1:15])",
                "src1.fraction  := EXTZ(src1.bit[16:127])",
                "src2.fraction  := EXTZ(src2.bit[16:127])",
                "",
                "src1.class.NaN := (src1.exponent = 32767) &amp;",
                "                   (src1.fraction != 0)",
                "src2.class.NaN := (src2.exponent = 32767) &amp;",
                "                   (src2.fraction != 0)",
                "",
                "lt_flag := (src1.exponent &lt; src2.exponent)",
                "gt_flag := (src1.exponent &gt; src2.exponent)",
                "eq_flag := (src1.exponent = src2.exponent)",
                "uo_flag := src1.class.NaN | src2.class.NaN",
                "",
                "CR.bit[4\u00d7BF+32] := FPSCR.FL := !uo_flag &amp; lt_flag",
                "CR.bit[4\u00d7BF+33] := FPSCR.FG := !uo_flag &amp; gt_flag",
                "CR.bit[4\u00d7BF+34] := FPSCR.FE := !uo_flag &amp; eq_flag",
                "CR.bit[4\u00d7BF+35] := FPSCR.FU :=  uo_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "The exponent of src1 is compared with the exponent of ",
                "src2 as unsigned integer values. The result of the ",
                "compare is placed into FPCC and CR field BF."
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgtdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "11"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "vex_flag := FPSCR.VE &amp; (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "   if src1 &gt; src2 then",
                "      VSR[32\u00d7TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "      VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "   else do",
                "      VSR[32\u00d7TX+T].dword[0] := 0x0000_0000_0000_0000",
                "      VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than.",
                "The contents of doubleword 0 of VSR[VRT] are set to ",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is greater than src2, and ",
                "are set to 0x0000_0000_0000_0000 otherwise.",
                "The contents of doubleword 1 of VSR[VRT] are set to ",
                "0x0000_0000_0000_0000.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgtqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "228"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than src2, and are set to all 0s otherwise.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than or Equal Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgedp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "19"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN)",
                "",
                "vex_flag := FPSCR.VE &amp; (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1 SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "   if src1 &gt;= src2 then",
                "      VSR[32\u00d7TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "      VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "   else do",
                "      VSR[32\u00d7TX+T].dword[0] := 0x0000_0000_0000_0000",
                "      VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than or ",
                "equal.",
                "The contents of doubleword 0 of VSR[XT] are set to ",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is greater than or equal ",
                "to src2, and are set to 0x0000_0000_0000_0000 ",
                "otherwise.",
                "The contents of doubleword 1 of VSR[XT] are set to ",
                "0x0000_0000_0000_0000.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than or Equal Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgeqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "196"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than or ",
                "equal.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than or equal to src2, and are set to all 0s ",
                "otherwise.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Compare Ordered Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpodp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "43"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "CR.bit[4\u00d7BF+32] := FPSCR.FL := src1 &lt; src2",
                "CR.bit[4\u00d7BF+33] := FPSCR.FG := src1 &gt; src2",
                "CR.bit[4\u00d7BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4\u00d7BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                               src1.class.QNaN |",
                "                               src2.class.SNaN |",
                "                               src2.class.QNaN"
            ],
            "body": [
                "Let XA be the value 32\u00d7AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal.",
                "Infinities of same signs compare equal.",
                "See Table66, \u201cActions for xscmpodp - Part 1: ",
                "Compare Ordered,\u201d on page691.",
                "The result of the compare is placed into CR field BF ",
                "and the FPCC.",
                "If either of the operands is a NaN, either quiet or ",
                "signaling, CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling ",
                "NaN, VXSNAN is set, and Invalid Operation is disabled ",
                "(VE=0), VXVC is set. If neither operand is a Signaling ",
                "NaN but at least one operand is a Quiet NaN, VXVC is ",
                "set.",
                "See Table67, \u201cActions for xscmpodp - Part 2: Result,\u201d ",
                "on page691."
            ]
        },
        {
            "description": "VSX Scalar Compare Ordered Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpoqp",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "132"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "CR.bit[4\u00d7BF+32] := FPSCR.FL := src1 &lt; src2",
                "CR.bit[4\u00d7BF+33] := FPSCR.FG := src1 &gt; src2",
                "CR.bit[4\u00d7BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4\u00d7BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                               src1.class.QNaN |",
                "                               src2.class.SNaN |",
                "                               src2.class.QNaN"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal. ",
                "Infinities of same signs compare equal.",
                "Bit 0 of CR field BF and FL are set to indicate if src1 is ",
                "less than src2.",
                "Bit 1 of CR field BF and FG are set to indicate if src1 is ",
                "greater than src2.",
                "Bit 2 of CR field BF and FE are set to indicate if src1 is ",
                "equal to src2.",
                "Bit 3 of CR field BF and FU are set to indicate unordered ",
                "(i.e., src1 or src2 is a NaN).",
                "If either of the operands is a NaN, either quiet or ",
                "signaling, CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling ",
                "NaN, an Invalid Operation exception occurs and ",
                "VXSNAN is set, and if Invalid Operation exceptions are ",
                "disabled (VE=0), VXVC is set. If neither operand is a ",
                "Signaling NaN but at least one operand is a Quiet ",
                "NaN, an Invalid Operation exception occurs and VXVC ",
                "is set."
            ]
        },
        {
            "description": "VSX Scalar Compare Unordered Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpudp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "35"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "CR.bit[4\u00d7BF+32] := FPSCR.FL := src1 &lt; src2",
                "CR.bit[4\u00d7BF+33] := FPSCR.FG := src1 &gt; src2",
                "CR.bit[4\u00d7BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4\u00d7BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                               src1.class.QNaN |",
                "                               src2.class.SNaN |",
                "                               src2.class.QNaN"
            ],
            "body": [
                "Let XA be the value 32\u00d7AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal equal.",
                "Infinities of same signs compare equal.",
                "See Table68, \u201cActions for xscmpudp - Part 1: ",
                "Compare Unordered,\u201d on page694.",
                "The result of the compare is placed into CR field BF ",
                "and the FPCC.",
                "If either of the operands is a NaN, either quiet or ",
                "signaling, CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling ",
                "NaN, VXSNAN is set.",
                "See Table69, \u201cActions for xscmpudp - Part 2: Result,\u201d ",
                "on page694."
            ]
        },
        {
            "description": "VSX Scalar Compare Unordered Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscmpuqp",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "644"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal. ",
                "Infinities of same signs compare equal.",
                "Bit 0 of CR field BF and FL are set to indicate if src1 is ",
                "less than src2.",
                "Bit 1 of CR field BF and FG are set to indicate if src1 is ",
                "greater than src2.",
                "Bit 2 of CR field BF and FE are set to indicate if src1 is ",
                "equal to src2.",
                "Bit 3 of CR field BF and FU are set to indicate unordered ",
                "(i.e., src1 or src2 is a NaN).",
                "If either of the operands is a Signaling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1."
            ]
        },
        {
            "description": "VSX Scalar Convert Double-Precision to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "22"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "",
                "if src.class.SNaN then",
                "   result := bfp128_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "else",
                "   result := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "vxsnan_flag := src.class.SNaN",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := 0",
                "FPSCR.FI := 0"
            ],
            "body": [
                "Let src be the floating-point value in doubleword ",
                "element 0 of VSR[VRB+32] represented in ",
                "doubleprecision format.",
                "src is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN is set to 1.",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[XT] and FPRF are not modified."
            ]
        },
        {
            "description": "VSX Scalar Convert Half-Precision to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvhpdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "16"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "347"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src ~ bfp_CONVERT_FROM_BFP16(VSR[BX\u00d732+B].hword[3])",
                "",
                "if src.class.SNaN=1 then",
                "   result ~ bfp64_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "else",
                "   result ~ bfp64_CONVERT_FROM_BFP(src)",
                "",
                "vxsnan_flag ~ src.class.SNaN",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag ~ FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[TX\u00d732+T].dword[0] ~ result",
                "   VSR[TX\u00d732+T].dword[1] ~ 0x0000_0000_0000_0000",
                "   FPSCR.FPRF ~ fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR ~ 0",
                "FPSCR.FI ~ 0"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the half-precision floating-point value in the ",
                "rightmost halfword of doubleword element 0 of VSR[XB].",
                "If src is an SNaN, the result is the double-precision ",
                "representation of that SNaN converted to a QNaN.",
                "Otherwise, if src is a QNaN, the result is the ",
                "double-precision representation of that QNaN.",
                "Otherwise, if src is an Infinity, the result is the ",
                "double-precision representation of Infinity with the ",
                "same sign as src.",
                "Otherwise, if src is a Zero, the result is the ",
                "double-precision representation of Zero with the same ",
                "sign as src.",
                "Otherwise, if src is a denormal value, the result is the ",
                "normalized double-precision representation of src.",
                "Otherwise, the result is the double-precision ",
                "representation of src.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in double-precision format.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified.",
                "FR is set to 0. FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Scalar Single-Precision to Vector Single - Precision format Non-signalling",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpspn",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "267"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "result := bfp32_CONVERT_FROM_BFP(src)",
                "",
                "VSR[32\u00d7TX+T].word[0] := result",
                "VSR[32\u00d7TX+T].word[1] := result",
                "VSR[32\u00d7TX+T].word[2] := 0x0000_0000",
                "VSR[32\u00d7TX+T].word[3] := 0x0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the single-precision floating-point value in ",
                "doubleword element 0 of VSR[XB] represented in ",
                "double-precision format.",
                "src is placed into word elements 0 and 1 of VSR[XT] in ",
                "single-precision format.",
                "The contents of word elements 2 and 3 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Signed Doubleword to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvsdqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "10"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src         := bfp_CONVERT_FROM_SI64(VSR[VRB+32].dword[0])",
                "result      := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := 0",
                "FPSCR.FI    := 0"
            ],
            "body": [
                "Let src be the signed integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "src is placed into VSR[VRT+32] in quadprecision ",
                "floating-point format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Single-Precision to Double - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvspdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "329"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[0])",
                "vxsnan_flag := src.class.SNaN",
                "result := bfp64_CONVERT_FROM_BFP(src)",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the single-precision floating-point value in ",
                "word element 0 of VSR[XB].",
                "If src is a SNaN, the result is src, converted to a ",
                "QNaN (i.e., bit 9 of src set to 1). VXSNAN is set to 1.",
                "Otherwise, the result is src.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] is not modified, FPRF is not modified, FR is set ",
                "to 0, and FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Single-Precision to Double - Precision format Non-signalling",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvspdpn",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "331"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[0])",
                "result := bfp64_CONVERT_FROM_BFP(src)",
                "VSR[32\u00d7TX+T].dword[0] := result",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the single-precision floating-point value in ",
                "word element 0 of VSR[XB].",
                "src is placed into doubleword element 0 of VSR[XT] in ",
                "double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Unsigned Doubleword to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvudqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src         := bfp_CONVERT_FROM_UI64(VSR[VRB+32].dword[0])",
                "result      := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := 0",
                "FPSCR.FI    := 0"
            ],
            "body": [
                "Let src be the unsigned integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "src is placed into VSR[VRT+32] in quadprecision ",
                "floating-point format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Double-Precision to Half-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdphp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "17"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "347"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src    ~ bfp_CONVERT_FROM_BFP64(VSR[BX\u00d732+B].dword[0])",
                "rnd    ~ bfp_ROUND_TO_BFP16(FPSCR.RN,src)",
                "result ~ bfp16_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag ~ FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[TX\u00d732+T].hword[0:2] ~ 0x0000_0000_0000",
                "   VSR[TX\u00d732+T].hword[3]   ~ result",
                "   VSR[TX\u00d732+T].dword[1]   ~ 0x0000_0000_0000_0000",
                "   FPSCR.FPRF              ~ fprf_CLASS_BFP16(result)",
                "end",
                "FPSCR.FR ~ (vex_flag=0) &amp; inc_flag",
                "FPSCR.FI ~ (vex_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is an SNaN, the result is the half-precision ",
                "representation of that SNaN converted to a QNaN.",
                "Otherwise, if src is a QNaN, the result is the ",
                "half-precision representation of that QNaN.",
                "Otherwise, if src is an Infinity, the result is the ",
                "half-precision representation of Infinity with the same ",
                "sign as src.",
                "Otherwise, if src is a Zero, the result is the ",
                "half-precision representation of Zero with the same ",
                "sign as src.",
                "Otherwise, the result is the half-precision ",
                "representation of src rounded to half-precision using ",
                "the rounding mode specified by RN.",
                "The result is zero-extended and placed into ",
                "doubleword element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in half-precision. FR is set to indicate if the ",
                "result was incremented when rounded. FI is set to ",
                "indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Convert with round Double-Precision to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "265"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "result := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].word[0] := result",
                "   VSR[32\u00d7TX+T].word[1] := result",
                "   VSR[32\u00d7TX+T].word[2] := 0x0000_0000",
                "   VSR[32\u00d7TX+T].word[3] := 0x0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a SNaN, the result is src converted to a QNaN ",
                "(i.e., bit 12 of src is set to 1). VXSNAN is set to 1.",
                "Otherwise, if src is a QNaN, an Infinity, or a Zero, the ",
                "result is src.",
                "Otherwise, the result is src rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into word elements 0 and 1 of ",
                "VSR[XT] in single-precision format.",
                "The contents of word elements 2 and 3 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Quad-Precision to Double-Precision format [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpdp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "20"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP64(RO,FPSCR.RN,src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := (vxsnan_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vxsnan_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN is set to 1.",
                "If src is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to the Signalling NaN, with the ",
                "significand truncated to the rounding precision.",
                "Otherwise, if src is a Quiet NaN, then the result is src ",
                "with the significand truncated to double-precision.",
                "Otherwise, if src is an Infinity or a Zero, the result is ",
                "src.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in doubleprecision format. The contents ",
                "of doubleword element 1 of VSR[VRT+32] are set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in double-precision format. FR is set to ",
                "indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Signed Doubleword to Double - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvsxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "376"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_SI64(VSR[32\u00d7BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32\u00d7TX+T].dword[0] := result",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the signed integer value in doubleword ",
                "element 0 of VSR[XB].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to double-precision ",
                "using the rounding mode specified by RN. ",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Convert with round Signed Doubleword to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvsxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "312"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_SI64(VSR[32\u00d7BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32\u00d7TX+T].dword[0] := result64",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the two\u2019s-complement integer value in ",
                "doubleword element 0 of VSR[XB].",
                "src is converted to floating-point format, and rounded ",
                "to single-precision using the rounding mode specified ",
                "by RN. ",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Signed Quadword to Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvsqqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "11"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_SI128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP128(0,FPSCR.RN,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(XX)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := inc_flag",
                "FPSCR.FI    := xx_flag"
            ],
            "body": [
                "Let src be the 128-bit signed integer value in ",
                "VSR[VRB+32].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to quad-precision ",
                "using the rounding mode specified by RN.",
                "The result is placed into VSR[VRT+32] in quad-precision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Unsigned Doubleword to Double - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvuxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "360"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_UI64(VSR[32\u00d7BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32\u00d7TX+T].dword[0] := result",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the unsigned integer value in doubleword ",
                "element 0 of VSR[XB].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Unsigned Doubleword to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvuxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "296"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_UI64(VSR[32\u00d7BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32\u00d7TX+T].dword[0] := result64",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the unsigned-integer value in doubleword ",
                "element 0 of VSR[XB].",
                "src is converted to floating-point format, and rounded ",
                "to single-precision using the rounding mode specified ",
                "by RN. ",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Convert with round Unsigned Quadword to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvuqqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "3"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_UI128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP128(0b0,FPSCR.RN,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(XX)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := inc_flag",
                "FPSCR.FI    := xx_flag"
            ],
            "body": [
                "Let src be the 128-bit unsigned integer value in ",
                "VSR[VRB+32].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to quad-precision ",
                "using the rounding mode specified by RN.",
                "The result is placed into VSR[VRT+32] in quad-precision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Double-Precision to Signed Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpsxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "344"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[1] := result",
                "   VSR[32\u00d7TX+T].dword[2] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value ",
                "0x8000_0000_0000_0000 and VXCVI is set to 1. If src is ",
                "an SNaN, VXSNAN is also set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 263-1, the result is ",
                "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 263, the ",
                "result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit signed-integer format, and if the result is inexact ",
                "(i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 70.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Double-Precision to Signed Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpsxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "88"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].word[0] := result",
                "   VSR[32\u00d7TX+T].word[1] := result",
                "   VSR[32\u00d7TX+T].word[2] := 0x0000_0000",
                "   VSR[32\u00d7TX+T].word[3] := 0x0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value 0x8000_0000 and ",
                "VXCVI is set to 1. If src is an SNaN, VXSNAN is also set ",
                "to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 231-1, the result is ",
                "0x7FFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 231, the ",
                "result is 0x8000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit signed-integer format, and if the result is inexact ",
                "(i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 71."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Double-Precision to Unsigned Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpuxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "328"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[1] := result",
                "   VSR[32\u00d7TX+T].dword[2] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value ",
                "0x0000_0000_0000_0000 and VXCVI is set to 1. If src is ",
                "an SNaN, VXSNAN is also set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 264-1, the result is ",
                "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 0, the ",
                "result is 0x0000_0000_0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit unsigned-integer format, and if the result is ",
                "inexact (i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 72."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Double-Precision to Unsigned Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpuxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "72"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].word[0] := result",
                "   VSR[32\u00d7TX+T].word[1] := result",
                "   VSR[32\u00d7TX+T].word[2] := 0x0000_0000",
                "   VSR[32\u00d7TX+T].word[3] := 0x0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value 0x0000_0000 and ",
                "VXCVI is set to 1. If src is an SNaN, VXSNAN is also set ",
                "to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 232-1, the result is ",
                "0xFFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 0, the ",
                "result is 0x0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit unsigned-integer format, and if the result is ",
                "inexact (i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 73."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Signed Doubleword format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpsdz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "25"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN | src.class.SNaN then do",
                "   result := 0x8000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity then do",
                "   vxcvi_flag := 1",
                "   if src.sign = 0 then",
                "      result := 0x7FFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x8000_0000_0000_0000",
                "end",
                "else if src.class.Zero then",
                "   result := 0x0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +263-1) then do",
                "      result := 0x7FFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, -263) then do",
                "      result := 0x8000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0x8000_0000_0000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is +Infinity, the result is ",
                "0x7FFF_FFFF_FFFF_FFFF.",
                "Otherwise, if src is -Infinity, the result is ",
                "0x8000_0000_0000_0000.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in signed integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table70, \u201cActions for xscvdpsxds,\u201d on page702."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Signed Quadword",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpsqz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "8"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign = 0 then",
                "      result := 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000_0000_0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +2127-1) then do",
                "      result := 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, -2127) then do",
                "      result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si128_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is -2127.",
                "Otherwise, if src is a Zero, the result is 0.",
                "Otherwise, if src is +Infinity, the result is 2127-1.",
                "Otherwise, if src is -Infinity, the result is -2127.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in signed integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table75, \u201cActions for xscvqpsqz,\u201d on page714."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Signed Word format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpswz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "9"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0xFFFF_FFFF_8000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0x0000_0000_7FFF_FFFF",
                "   else",
                "      result := 0xFFFF_FFFF_8000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +231-1) then do",
                "      result := 0x0000_0000_7FFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, -231) then do",
                "      result := 0xFFFF_FFFF_8000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := 0",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0xFFFF_FFFF_8000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is a +Infinity, the result is ",
                "0x0000_0000_7FFF_FFFF.",
                "Otherwise, if src is a -Infinity, the result is ",
                "0xFFFF_FFFF_8000_0000.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in signed integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table76, \u201cActions for xscvqpswz,\u201d on page716."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Doubleword format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpudz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "17"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x0000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0xFFFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x0000_0000_0000_0000",
                "end",
                "else if src.class.Zero then result := 0x0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +264-1) then do",
                "      result := 0xFFFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, 0) then do",
                "      result := 0x0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := ui64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0x0000_0000_0000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is a positive Infinity, the result is ",
                "0xFFFF_FFFF_FFFF_FFFF.",
                "Otherwise, if src is a negative Infinity, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in unsigned integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table77, \u201cActions for xscvqpudz,\u201d on page718."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpuqz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSypX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +2128-1) then do",
                "      result := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, 0) then do",
                "      result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si128_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0.",
                "Otherwise, if src is a Zero, the result is 0.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in unsigned ",
                "integer format.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table77, \u201cActions for xscvqpudz,\u201d on page718."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Word format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpuwz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "836"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0x0000_0000_FFFF_FFFF",
                "   else",
                "      result := 0x0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +232-1) then do",
                "      result := 0x0000_0000_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, bfp_ZERO) then do",
                "      result := 0x0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := ui64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0x0000_0000_0000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is a positive Infinity, the result is ",
                "0x0000_0000_FFFF_FFFF.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in unsigned integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table79, \u201cActions for xscvqpuwz,\u201d on page722."
            ]
        },
        {
            "description": "VSX Scalar Copy Sign Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscpsgndp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "176"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[32\u00d7AX+A].dword[0] &amp; 0x8000_0000_0000_0000",
                "src2 := VSR[32\u00d7BX+B].dword[0] &amp; 0x7FFF_FFFF_FFFF_FFFF",
                "VSR[32\u00d7TX+T].dword[0] := src1 | src2",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Bit 0 of VSR[XT] is set to the contents of bit 0 of ",
                "VSR[XA].",
                "Bits 1:63 of VSR[XT] are set to the contents of bits 1:63 ",
                "of VSR[XB].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Copy Sign Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xscpsgnqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "100"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[VRA+32] &amp; 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "src2 := VSR[VRB+32] &amp; 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "",
                "VSR[VRT+32] := src1 | src2"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quad-precision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quad-precision format.",
                "src2 is placed into VSR[VRT+32] with the sign of src1."
            ]
        },
        {
            "description": "VSX Scalar Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsdivdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "56"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v      := bfp_DIVIDE(src1,src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "zex_flag := FPSCR.ZE &amp; zx_flag",
                "",
                "if vex_flag=0 &amp; zex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is divided by src2, producing a quotient having ",
                "unbounded range and precision.",
                "The quotient is normalized.",
                "See Actions for xsdivdp (p. 732).",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified, and FR and FI are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Divide Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsdivqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "548"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_DIVIDE(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "zex_flag := FPSCR.ZE &amp; zx_flag",
                "",
                "if vex_flag=0 &amp; zex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; (zx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; (zx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1",
                "If src1 and src2 are Infinity values, an Invalid ",
                "Operation exception occurs and VXIDI is set to 1.",
                "If src1 and src2 are Zero values, an Invalid Operation ",
                "exception occurs and VXZDZ is set to 1.",
                "If src1 is a finite value and src2 is a Zero value, an ",
                "Zero Divide exception occurs and ZX is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 and src2 are Infinity values, or if ",
                "src1 and src2 are Zero values, the result is the default ",
                "Quiet NaN.",
                "Otherwise, if src1 is a non-zero value and src2 is a ",
                "Zero value, the result is an Infinity.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-disabled Zero Divide exception occurs, FR and ",
                "FI are set to 0.",
                "If a trap-enabled Invalid Operation exception or a ",
                "trap-enabled Zero Divide exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Divide Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsdivsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "24"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v        := bfp_DIVIDE(src1,src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "zex_flag := FPSCR.ZE &amp; zx_flag",
                "",
                "if vex_flag=0 &amp; zex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is divided by src2, producing a quotient having ",
                "unbounded range and precision.",
                "The quotient is normalized.",
                "See Table82, \u201cActions for xsdivsp,\u201d on page736.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified, and FR and FI are set to 0.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Extract Exponent Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsxexpdp",
                    "operands": [
                        "RT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "347"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src ~ VSR[32\u00d7BX+B].dword[0]",
                "",
                "GPR[RT] ~ (src &gt;&gt; 52) &amp; 0x0000_0000_0000_07FF"
            ],
            "body": [
                "Let XB be the sum 32\u00d7BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The value of the exponent field in src is placed into ",
                "GPR[RT] in unsigned integer format."
            ]
        },
        {
            "description": "VSX Scalar Extract Exponent Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsxexpqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "804"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[VRB+32]",
                "VSR[VRT+32].dword[0] := EXTZ64(src.bit[1:15]), 64)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "The contents of the exponent field of src (bits 1:15) are ",
                "zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "VSX Scalar Extract Significand Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsxsigdp",
                    "operands": [
                        "RT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "347"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "exponent ~ VSR[32\u00d7BX+B].bit[1:11]",
                "fraction ~ EXTZ64(VSR[32\u00d7BX+B].bit[12:63])",
                "",
                "if (exponent != 0) &amp; (exponent != 2047) then",
                "   significand ~ fraction | 0x0010_0000_0000_0000",
                "else",
                "   significand ~ fraction",
                "",
                "GPR[RT] ~ significand"
            ],
            "body": [
                "Let XB be the sum 32\u00d7BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The significand of src is placed into GPR[RT] in ",
                "unsigned integer format. If src is a normal value, the ",
                "implicit leading bit is set to 1."
            ]
        },
        {
            "description": "VSX Scalar Extract Significand Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsxsigqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "18"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "804"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src      := VSR[VRB+32]",
                "exponent := EXTZ(src.bit[1:15])",
                "fraction := EXTZ128(src.bit[16:127])",
                "",
                "if (exponent != 0) &amp;  (exponent != 32767) then",
                "   VSR[VRT+32] := fraction |",
                "                    0x0001_0000_0000_0000_0000_0000_0000_0000",
                "else",
                "   VSR[VRT+32] := fraction"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "The significand of src is placed into VSR[VRT+32].",
                "If the value of the exponent field of src is equal to ",
                "0b000_0000_0000_0000 (i.e., Zero or Denormal value) or ",
                "0b111_1111_1111_1111 (i.e., Infinity or NaN), 0b0 is ",
                "placed into bit 15 of VSR[VRT+32]. Otherwise (i.e., ",
                "Normal value), 0b1 is placed into bit 15 of VSR[VRT+32]. ",
                "The contents of bits 0:14 of VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "VSX Scalar Insert Exponent Double - Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsiexpdp",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "918"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 ~ GPR[RA]",
                "src2 ~ GPR[RB]",
                "",
                "VSR[32\u00d7TX+T].dword[0].bit[0]     ~ src1.bit[0]",
                "VSR[32\u00d7TX+T].dword[0].bit[1:11]  ~ src2.bit[53:63]",
                "VSR[32\u00d7TX+T].dword[0].bit[12:63] ~ src1.bit[12:63]",
                "VSR[32\u00d7TX+T].dword[1]            ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "Let src1 be the unsigned integer value in GPR[RA].",
                "The contents of bit 0 of src1 are placed into bit 0 of ",
                "VSR[XT].",
                "The contents of bits 53:63 of src2 are placed into bits ",
                "1:11 of VSR[XT].",
                "The contents of bits 12:63 of src1 are placed into bits ",
                "12:63 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Insert Exponent Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsiexpqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "868"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32].bit[0]      := VSR[VRA+32].bit[0]",
                "VSR[VRT+32].bit[1:15]   := VSR[VRB+32].dword[0].bit[49:63]",
                "VSR[VRT+32].bit[16:127] := VSR[VRA+32].bit[16:127]"
            ],
            "body": [
                "The contents of bit 0 of VSR[VRA+32] are placed into bit ",
                "0 of VSR[VRT+32].",
                "The contents of bit 49:63 of doubleword element 0 of ",
                "VSR[VRB+32] are placed into bits 1:15 of VSR[VRT+32].",
                "The contents of bit 16:127 of VSR[VRA+32] are placed ",
                "into bits 16:127 of VSR[VRT+32]."
            ]
        },
        {
            "description": "VSX Scalar Maximum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "160"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32\u00d7AX+A].dword[0]",
                "src2   := VSR[32\u00d7BX+B].dword[0]",
                "result := bfp64_MAXIMUM(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src1 is greater than src2, src1 is placed into ",
                "doubleword element 0 of VSR[XT]. Otherwise, src2 is ",
                "placed into doubleword element 0 of VSR[XT] in ",
                "double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "The maximum of +0 and -0 is +0. The maximum of a ",
                "QNaN and any value is that value. The maximum of ",
                "any value and an SNaN is that SNaN converted to a ",
                "QNaN.",
                "FPRF, FR and FI are not modified.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] is not modified.",
                "See Table 86."
            ]
        },
        {
            "description": "VSX Scalar Maximum Type-C Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxcdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "128"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32\u00d7AX+A].dword[0]",
                "src2   := VSR[32\u00d7BX+B].dword[0]",
                "result := bfp64_MAXIMUM_TYPE_C(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is greater than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Maximum Type-C Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxcqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "676"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is greater than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of VSR[VRT+32] are set to the value ",
                "result.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Maximum Type-J Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxjdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "144"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32\u00d7AX+A].dword[0]",
                "src2   := VSR[32\u00d7BX+B].dword[0]",
                "result := bfp64_MAXIMUM_TYPE_J(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If src1 is a NaN, result is src1.",
                "Otherwise, if src2 is a NaN, result is src2.",
                "Otherwise, if src1 is a Zero and src2 is a Zero and ",
                "either src1 or src2 is a +Zero, the result is +Zero.",
                "Otherwise, if src1 is a -Zero and src2 is a -Zero, the ",
                "result is -Zero.",
                "Otherwise, if src1 is greater than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Minimum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmindp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "168"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32\u00d7AX+A].dword[0]",
                "src2   := VSR[32\u00d7BX+B].dword[0]",
                "result := bfp64_MINIMUM(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src1 is less than src2, src1 is placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "Otherwise, src2 is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "The minimum of +0 and \u20130 is \u20130. The minimum of a ",
                "QNaN and any value is that value. The minimum of ",
                "any value and an SNaN is that SNaN converted to a ",
                "QNaN.",
                "FPRF, FR and FI are not modified.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] is not modified.",
                "See Table 90.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Minimum Type-C Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmincdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "136"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32\u00d7AX+A].dword[0]",
                "src2   := VSR[32\u00d7BX+B].dword[0]",
                "result := bfp64_MINIMUM_TYPE_C(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is less than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Minimum Type-C Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmincqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "740"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is less than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of VSR[VRT+32] are set to the value ",
                "result.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Minimum Type-J Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsminjdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "152"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32\u00d7AX+A].dword[0]",
                "src2   := VSR[32\u00d7BX+B].dword[0]",
                "result := bfp64_MINIMUM_TYPE_J(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If src1 is a NaN, result is src1.",
                "Otherwise, if src2 is a NaN, result is src2.",
                "Otherwise, if src1 is a Zero and src2 is a Zero and ",
                "either src1 or src2 is a -Zero, the result is -Zero.",
                "Otherwise, if src1 is a +Zero and src2 is a +Zero, the ",
                "result is +Zero.",
                "Otherwise, if src1 is less than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Multiply - Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Multiply - Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "9"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsmaddasp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsmaddmsp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For xsmaddasp, do the following.",
                "For xsmaddmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table84, \u201cActions for xsmadd(a|m)sp,\u201d ",
                "on page744.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table84, \u201cActions for xsmadd(a|m)sp,\u201d ",
                "on page744.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Multiply - Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "17"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Multiply - Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "25"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsmsubasp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsmsubmsp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For xsmsubasp, do the following.",
                "For xsmsubmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table95, \u201cActions for xsmsub(a|m)sp\u201d.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision. ",
                "The result, having unbounded range and precision, is ",
                "normalized. ",
                "See part 2 of Table95, \u201cActions for xsmsub(a|m)sp\u201d.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmuldp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "48"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v      := bfp_MULTIPLY(src1,src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is multiplied by src2, producing a product ",
                "having unbounded range and precision.",
                "The product is normalized.",
                "See Table 97.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Multiply Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmulqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "36"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1.",
                "If src1 is an Infinity value and src2 is a Zero value, or if ",
                "src1 is a Zero value and src2 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 is an Infinity value and src2 is a Zero ",
                "value, or if src1 is a Zero value and src2 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmulsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "16"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v        := bfp_MULTIPLY(src1,src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is multiplied by src2, producing a product ",
                "having unbounded range and precision.",
                "The product is normalized.",
                "See Table99, \u201cActions for xsmulsp,\u201d on page776.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Multiply-Add Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "388"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1  then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "if ox_flag=1     then SetFX(FPSCR.OX)",
                "if ux_flag=1     then SetFX(FPSCR.UX)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "ex_flag  := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having opposite signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having opposite signs, the result is ",
                "the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "33"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "41"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsmaddadp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsmaddmdp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "For xsmaddadp, do the following.",
                "For xsmaddmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 83.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table 83.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply-Subtract Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "420"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having same signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having same signs, the result is the ",
                "default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "49"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "57"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsmsubadp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsmsubmdp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For xsmsubadp, do the following.",
                "For xsmsubmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 94.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision.",
                "The result, having unbounded range and precision, is ",
                "normalized.",
                "See part 2 of Table 94.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is ",
                "set to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Negate Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnegdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "377"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32\u00d7BX+B].dword[0]",
                "VSR[32\u00d7TX+T].dword[0] := bfp64_NEGATE(src)",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of doubleword element 0 of VSR[XB], with ",
                "bit 0 complemented, is placed into doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Negate Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnegqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "16"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "804"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATE(VSR[VRB+32])"
            ],
            "body": [
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "src is negated and placed into VSR[VRT+32] in ",
                "quadprecision format."
            ]
        },
        {
            "description": "VSX Scalar Negative Absolute Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "361"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32\u00d7BX+B].dword[0]",
                "VSR[32\u00d7TX+T].dword[0] := bfp64_NEGATIVE_ABSOLUTE(src)",
                "VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of doubleword element 0 of VSR[XB], with ",
                "bit 0 set to 1, is placed into doubleword element 0 of ",
                "VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. "
            ]
        },
        {
            "description": "VSX Scalar Negative Absolute Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnabsqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "8"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "804"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATIVE_ABSOLUTE(VSR[VRB+32])"
            ],
            "body": [
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "The negative absolute value of src is placed into ",
                "VSR[VRT+32] in quadprecision format."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply - Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "129"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Negative Multiply - Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "137"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsnmaddasp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsnmaddmsp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd      := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN, v))",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For xsnmaddasp, do the following.",
                "For xsnmaddmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table102, \u201cActions for xsnmadd(a|m)sp,\u201d ",
                "on page786.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table102, \u201cActions for xsnmadd(a|m)sp,\u201d ",
                "on page786.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, \u201cScalar Floating-Point Final Result with ",
                "Negation,\u201d on page782."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply - Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "145"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Negative Multiply - Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "153"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsnmsubasp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsnmsubmsp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd      := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN, v))",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For xsnmsubasp, do the following.",
                "For xsnmsubmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table105, \u201cActions for xsnmsub(a|m)sp,\u201d ",
                "on page795.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table105, \u201cActions for xsnmsub(a|m)sp,\u201d ",
                "on page795.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, \u201cScalar Floating-Point Final Result with ",
                "Negation,\u201d on page782."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Add Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "452"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v))",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having opposite signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having opposite signs, the result is ",
                "the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is negated and placed into VSR[VRT+32] in ",
                "quadprecision format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "161"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Negative Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "169"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsnmaddadp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsnmaddmdp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v))",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "For xsnmaddadp, do the following.",
                "For xsnmaddmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 100.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table 100.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, \u201cScalar Floating-Point Final Result with ",
                "Negation,\u201d on page782."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Subtract Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "484"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v))",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "ex_flag  := FPSCR.VE &amp; vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having same signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having same signs, the result is the ",
                "default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is negated and placed into VSR[VRT+32] in ",
                "quadprecision format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "177"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Scalar Negative Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "185"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \u201cxsnmsubadp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "end",
                "if \u201cxsnmsubmdp\u201d then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32\u00d7TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v))",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "For xsnmsubadp, do the following.",
                "For xsnmsubmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 104.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table 104.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, \u201cScalar Floating-Point Final Result with ",
                "Negation,\u201d on page782."
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsredp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "90"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v      := bfp_RECIPROCAL_ESTIMATE(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "zex_flag := FPSCR.ZE &amp; zx_flag",
                "",
                "if vex_flag=0 &amp; zex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A double-precision floating-point estimate of the ",
                "reciprocal of src is placed into doubleword element 0 ",
                "of VSR[XT] in double-precision format.",
                "Unless the reciprocal of src would be a zero, an ",
                "infinity, or a QNaN, the estimate has a relative error in ",
                "precision no greater than one part in 16384 of the ",
                "reciprocal of src. That is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to an undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsresp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "26"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v        := bfp_RECIPROCAL_ESTIMATE(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if 0bU then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "zex_flag := FPSCR.ZE &amp; zx_flag",
                "",
                "if vex_flag=0 &amp; zex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A single-precision floating-point estimate of the ",
                "reciprocal of src is placed into doubleword element 0 ",
                "of VSR[XT] in double-precision format.",
                "Unless the reciprocal of src would be a zero, an ",
                "infinity, the result of a trap-disabled Overflow ",
                "exception, or a QNaN, the estimate has a relative error ",
                "in precision no greater than one part in 16384 of the ",
                "reciprocal of src. That is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to an ",
                "undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Square Root Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrsqrtedp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "74"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v      := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "zex_flag := FPSCR.ZE &amp; zx_flag",
                "",
                "if vex_flag=0 &amp; zex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A double-precision floating-point  estimate of the ",
                "reciprocal square root of src is placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format.",
                "Unless the reciprocal of the square root of src would ",
                "be a zero, an infinity, or a QNaN, the estimate has a ",
                "relative error in precision no greater than one part in ",
                "16384 of the reciprocal of the square root of src. That ",
                "is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to an undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Square Root Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrsqrtesp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "10"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v        := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if 0bU then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "zex_flag := FPSCR.ZE &amp; zx_flag",
                "",
                "if vex_flag=0 &amp; zex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A single-precision floating-point  estimate of the ",
                "reciprocal square root of src is placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format.",
                "Unless the reciprocal of the square root of src would ",
                "be a zero, an infinity, or a QNaN, the estimate has a ",
                "relative error in precision no greater than one part in ",
                "16384 of the reciprocal of the square root of src. That ",
                "is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to an ",
                "undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Scalar Round Quad-Precision to Double-Extended-Precision",
            "form": "Z23-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrqpxp",
                    "operands": [
                        "R",
                        "VRT",
                        "VRB",
                        "RMC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "37"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if R=0 then do",
                "   if RMC=0b00 then           // Round to Nearest Away",
                "      rmode := 0b100",
                "   if RMC=0b11 then do",
                "      if FPSCR.RN=0b00 then   // Round to Nearest Even",
                "         rmode := 0b000",
                "      if FPSCR.RN=0b01 then   // Round towards Zero",
                "         rmode := 0b001",
                "      if FPSCR.RN=0b10 then   // Round towards +Infinity",
                "         rmode := 0b010",
                "      if FPSCR.RN=0b11 then   // Round towards -Infinity",
                "         rmode := 0b011",
                "   end",
                "end",
                "else do // R=1",
                "   if RMC=0b00 then           // Round to Nearest Even",
                "      rmode := 0b000",
                "   if RMC=0b01 then           // Round towards Zero",
                "      rmode := 0b001",
                "   if RMC=0b10 then           // Round towards +Infinity",
                "      rmode := 0b010",
                "   if RMC=0b11 then           // Round towards -Infinity",
                "      rmode := 0b011",
                "end",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP80(rmode,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vxsnan_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vxsnan_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let R and RMC specify the rounding mode as follows.",
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs, VXSNAN is set to 1, and the result is ",
                "the Quiet NaN corresponding to the Signalling NaN, ",
                "with the significand truncated to ",
                "double-extended-precision.",
                "Otherwise, if src is a Quiet NaN, then the result is src ",
                "with the significand truncated to ",
                "double-extended-precision.",
                "Otherwise, if src is an Infinity or a Zero, the result is ",
                "src.",
                "Otherwise, src is rounded to double-extended ",
                "precision (i.e., 15-bit exponent range and 64-bit ",
                "significand precision) using the specified rounding ",
                "mode.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value, and FR and FI are set ",
                "to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer exact using Current rounding mode",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpic",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "107"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "",
                "if FPSCR.RN=0b00 then",
                "   rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "if FPSCR.RN=0b01 then",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "if FPSCR.RN=0b10 then",
                "   rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "if FPSCR.RN=0b11 then",
                "   rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "specified by RN.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round to Nearest Away",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpi",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "73"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round to Nearest Away.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round toward +Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpip",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "105"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round toward +Infinity.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round toward -Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpim",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "121"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round toward Infinity.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round toward Zero",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpiz",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "89"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round toward Zero.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Quad-Precision Integer [ with Inexact ]",
            "form": "Z23-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrqpi",
                    "operands": [
                        "R",
                        "VRT",
                        "VRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "EX",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "5"
                },
                {
                    "name": "EX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if R=0 then do",
                "   if RMC=0b00 then           // Round to Nearest Away",
                "      rmode := 0b100",
                "   if RMC=0b11 then do",
                "      if FPSCR.RN=0b00 then   // Round to Nearest Even",
                "         rmode := 0b000",
                "      if FPSCR.RN=0b01 then   // Round towards Zero",
                "         rmode := 0b001",
                "      if FPSCR.RN=0b10 then   // Round towards +Infinity",
                "         rmode := 0b010",
                "      if FPSCR.RN=0b11 then   // Round towards -Infinity",
                "         rmode := 0b011",
                "   end",
                "end",
                "else do // R=1",
                "   if RMC=0b00 then           // Round to Nearest Even",
                "      rmode := 0b000",
                "   if RMC=0b01 then           // Round towards Zero",
                "      rmode := 0b001",
                "   if RMC=0b10 then           // Round towards +Infinity",
                "      rmode := 0b010",
                "   if RMC=0b11 then           // Round towards -Infinity",
                "      rmode := 0b011",
                "end",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.SNaN then do",
                "   result := bfp128_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "   vxsnan_flag := 1",
                "end",
                "else if src.class.QNaN     |",
                "        src.class.Infinity |",
                "        src.class.Zero  then",
                "   result := bfp128_CONVERT_FROM_BFP(src)",
                "else do",
                "   rnd    := bfp_ROUND_TO_INTEGER(rmode, src)",
                "   result := bfp128_CONVERT_FROM_BFP(rnd)",
                "end",
                "",
                "if vxsnan_flag=1  then SetFX(FPSCR.VXSNAN)",
                "if xx_flag &amp; EX then SetFX(FPSCR.XX)",
                "",
                "vex_flag  := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := EX &amp; (vxsnan_flag=0) &amp; inc_flag",
                "FPSCR.FI := EX &amp; (vxsnan_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let R and RMC specify the rounding mode as follows.",
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs, VXSNAN is set to 1, and the result is ",
                "the Quiet NaN corresponding to the Signalling NaN.",
                "Otherwise, if src is a Quiet NaN, an Infinity, or a Zero, ",
                "then the result is src.",
                "Otherwise, src is rounded to an integer using the ",
                "rounding mode rmode.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result.",
                "For xsrqpi, FR is set to 0, FI is set to 0, and XX is not ",
                "set by an Inexact exception.",
                "For xsrqpix, FR is set to indicate if the result was ",
                "incremented when rounded, FI is set to indicate the ",
                "result is inexact, and XX is set by an Inexact exception.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified."
            ]
        },
        {
            "description": "VSX Scalar Round to Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xsrsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "281"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE &amp; vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to single-precision using the rounding ",
                "mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified."
            ]
        },
        {
            "description": "VSX Scalar Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xssqrtdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "75"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v      := bfp_SQUARE_ROOT(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The unbounded-precision square root of src is ",
                "produced.",
                "See Table 107.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN. ",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Square Root Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xssqrtqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "27"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "804"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_SQUARE_ROOT(src)",
                "rnd    := bfp_ROUND_TO_BFP128(RO,FPSCR.RN,v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN is set to 1.",
                "If src is a negative, non-zero value, an Invalid ",
                "Operation exception occurs and VXSQRT is set to 1.",
                "If src is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src.",
                "Otherwise, if src is a Quiet NaN, the result is src.",
                "Otherwise, if src is a negative value, the result is the ",
                "default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value, and FR and FI are set ",
                "to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Square Root Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xssqrtsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "11"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v        := bfp_SQUARE_ROOT(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The unbounded-precision square root of src is ",
                "produced.",
                "See Table 107.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN. ",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Subtract Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xssubdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "40"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v      := bfp_ADD(src1,bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is negated and added to src1, producing a sum ",
                "having unbounded range and precision.",
                "See Table 110.",
                "The sum is normalized.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT]. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Subtract Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xssubqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "516"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_ADD(src1, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP128(RO,FPSCR.RN,v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) &amp; inc_flag",
                "FPSCR.FI := (vx_flag=0) &amp; xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1.",
                "If src1 and src2 are Infinity values having same signs, ",
                "an Invalid Operation exception occurs and VXISI is set ",
                "to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 and src2 are Infinity values having ",
                "same signs, the result is the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value, and FR and FI are set ",
                "to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676."
            ]
        },
        {
            "description": "VSX Scalar Subtract Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xssubsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "8"
                },
                {
                    "name": "AX",
                    "size": "0"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[0])",
                "v        := bfp_ADD(src1,bfp_NEGATE(src2))",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE &amp; vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32\u00d7TX+T].dword[0] := result64",
                "   VSR[32\u00d7TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is negated and added to src1, producing the ",
                "sum, v, having unbounded range and precision. ",
                "See Table112, \u201cActions for xssubsp,\u201d on page826.",
                "v is normalized and rounded to single-precision ",
                "using the rounding mode specified by RN. ",
                "See Table62, \u201cScalar Floating-Point Intermediate ",
                "Result Handling,\u201d on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT]. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, \u201cVSX Scalar Floating-Point Final ",
                "Result,\u201d on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Test Data Class Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xststdcdp",
                    "operands": [
                        "BF",
                        "XB",
                        "DCMX"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "DCMX",
                    "size": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "362"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            ~ VSR[32\u00d7BX+B].dword[0]",
                "exponent       ~ src.bit[1:11]",
                "fraction       ~ src.bit[12:63]",
                "",
                "class.Infinity ~ (exponent = 0x7FF) &amp; (fraction  = 0)",
                "class.NaN      ~ (exponent = 0x7FF) &amp; (fraction != 0)",
                "class.Zero     ~ (exponent = 0x000) &amp; (fraction  = 0)",
                "class.Denormal ~ (exponent = 0x000) &amp; (fraction != 0)",
                "",
                "match          ~ (DCMX.bit[0] &amp; class.NaN)              |",
                "                (DCMX.bit[1] &amp; class.Infinity &amp; !sign) |",
                "                (DCMX.bit[2] &amp; class.Infinity &amp;  sign) |",
                "                (DCMX.bit[3] &amp; class.Zero     &amp; !sign) |",
                "                (DCMX.bit[4] &amp; class.Zero     &amp;  sign) |",
                "                (DCMX.bit[5] &amp; class.Denormal &amp; !sign) |",
                "                (DCMX.bit[6] &amp; class.Denormal &amp;  sign)",
                "",
                "CR.bit[4\u00d7BF+32] ~ FPSCR.FL ~ src.sign",
                "CR.bit[4\u00d7BF+33] ~ FPSCR.FG ~ 0b0",
                "CR.bit[4\u00d7BF+34] ~ FPSCR.FE ~ match",
                "CR.bit[4\u00d7BF+35] ~ FPSCR.FU ~ 0b0"
            ],
            "body": [
                "Let XB be the sum 32\u00d7BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign ",
                "bit of src.",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate ",
                "whether the data class of src, as represented in ",
                "double-precision format, matches any of the data ",
                "classes specified by DCMX (Data Class Mask). ",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0."
            ]
        },
        {
            "description": "VSX Scalar Test Data Class Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xststdcqp",
                    "operands": [
                        "BF",
                        "VRB",
                        "DCMX"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "DCMX",
                    "size": "7"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "708"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            := VSR[VRB+32]",
                "exponent       := src.bit[1:15]",
                "fraction       := src.bit[16:127]",
                "",
                "class.Infinity := (exponent = 0x7FFF) &amp; (fraction  = 0)",
                "class.NaN      := (exponent = 0x7FFF) &amp; (fraction != 0)",
                "class.Zero     := (exponent = 0x0000) &amp; (fraction  = 0)",
                "class.Denormal := (exponent = 0x0000) &amp; (fraction != 0)",
                "",
                "match          := (DCMX.bit[0] &amp; class.NaN)              |",
                "                (DCMX.bit[1] &amp; class.Infinity &amp; !sign) |",
                "                (DCMX.bit[2] &amp; class.Infinity &amp;  sign) |",
                "                (DCMX.bit[3] &amp; class.Zero     &amp; !sign) |",
                "                (DCMX.bit[4] &amp; class.Zero     &amp;  sign) |",
                "                (DCMX.bit[5] &amp; class.Denormal &amp; !sign) |",
                "                (DCMX.bit[6] &amp; class.Denormal &amp;  sign)",
                "",
                "CR.bit[4\u00d7BF+32] ~ FPSCR.FL ~ src.sign",
                "CR.bit[4\u00d7BF+33] ~ FPSCR.FG ~ 0b0",
                "CR.bit[4\u00d7BF+34] ~ FPSCR.FE ~ match",
                "CR.bit[4\u00d7BF+35] ~ FPSCR.FU ~ 0b0"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "Let the DCMX (Data Class Mask) field specify one or ",
                "more of the 7 possible data classes, where each bit ",
                "corresponds to a specific data class.",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign ",
                "of src.",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate ",
                "whether the data class of src, as represented in ",
                "quadprecision format, matches any of the data ",
                "classes specified by DCM.",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0."
            ]
        },
        {
            "description": "VSX Scalar Test Data Class Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xststdcsp",
                    "operands": [
                        "BF",
                        "XB",
                        "DCMX"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "DCMX",
                    "size": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "298"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            ~ VSR[32\u00d7BX+B].dword[0]",
                "exponent       ~ src.bit[1:11]",
                "fraction       ~ src.bit[12:63]",
                "",
                "class.Infinity ~ (exponent = 0x7FF) &amp; (fraction  = 0)",
                "class.NaN      ~ (exponent = 0x7FF) &amp; (fraction != 0)",
                "class.Zero     ~ (exponent = 0x000) &amp; (fraction  = 0)",
                "class.Denormal ~ (exponent = 0x000) &amp; (fraction != 0) |",
                "                (exponent &gt; 0x000) &amp; (exponent &lt; 0x381)",
                "",
                "match          ~ (DCMX.bit[0] &amp; class.NaN)              |",
                "                (DCMX.bit[1] &amp; class.Infinity &amp; !sign) |",
                "                (DCMX.bit[2] &amp; class.Infinity &amp;  sign) |",
                "                (DCMX.bit[3] &amp; class.Zero     &amp; !sign) |",
                "                (DCMX.bit[4] &amp; class.Zero     &amp;  sign) |",
                "                (DCMX.bit[5] &amp; class.Denormal &amp; !sign) |",
                "                (DCMX.bit[6] &amp; class.Denormal &amp;  sign)",
                "",
                "not_SP_value   ~ (src != Convert_SPtoDP(Convert_DPtoSP(src)))",
                "",
                "CR.bit[4\u00d7BF]   ~ FPSCR.FL ~ src.sign",
                "CR.bit[4\u00d7BF+1] ~ FPSCR.FG ~ 0b0",
                "CR.bit[4\u00d7BF+2] ~ FPSCR.FE ~ match",
                "CR.bit[4\u00d7BF+3] ~ FPSCR.FU ~ not_SP_value"
            ],
            "body": [
                "Let XB be the sum 32\u00d7BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign ",
                "bit of src.",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate ",
                "whether the data class of src, as represented in ",
                "single-precision format, matches any of the data ",
                "classes specified by DCMX (Data Class Mask).",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to indicate if ",
                "src is not representable in single-precision format."
            ]
        },
        {
            "description": "VSX Scalar Test for software Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xstdivdp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "61"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1    ~ VSR[32\u00d7AX+A].dword[0]",
                "src2    ~ VSR[32\u00d7BX+B].dword[0]",
                "e_a     := src1.bit[1:11] - 1023",
                "e_b     := src2.bit[1:11] - 1023",
                "fe_flag := IsNaN(src1) | IsInf(src1) |",
                "           IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "           ( e_b &lt;= -1022 ) |",
                "           ( e_b &gt;=  1021 ) |",
                "           ( !IsZero(src1) &amp; ( (e_a - e_b) &gt;=  1023 ) ) |",
                "           ( !IsZero(src1) &amp; ( (e_a - e_b) &lt;= -1021 ) ) |",
                "           ( !IsZero(src1) &amp; ( e_a &lt;= -970 ) )",
                "fg_flag := IsInf(src1) | IsInf(src2) |",
                "           IsZero(src2) | IsDen(src2)",
                "fl_flag := xsredp_error() &lt;= 2-14",
                "CR[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XA be the value 32\u00d7AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Let e_a be the unbiased exponent of src1.",
                "fe_flag is set to 1 for any of the following conditions.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 for any of the following conditions.",
                "Otherwise fg_flag is set to 0.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Scalar Test for software Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xstsqrtdp",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "106"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src     ~ VSR[32\u00d7BX+B].dword[0]",
                "e_b     := src.bit[1:11] - 1023",
                "fe_flag := IsNaN(src) | IsInf(src) | IsZero(src) |",
                "           IsNeg(src) | ( e_b &lt;= -970 )",
                "fg_flag := IsInf(src) | IsZero(src) | IsDen(src)",
                "fl_flag := xsrsqrtedp_error() &lt;= 2-14",
                "",
                "CR.field[BF] := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XB be the value 32\u00d7BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Let e_b be the unbiased exponent of src.",
                "fe_flag is set to 1 for any of the following conditions.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 for any of the following conditions.",
                "Otherwise fg_flag is set to 0.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Set Accumulator to Zero",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxsetaccz",
                    "operands": [
                        "AT"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "3"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "177"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ACC[AT][0] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][1] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][2] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][3] := 0x0000_0000_0000_0000_0000_0000_0000_0000"
            ],
            "body": [
                "For each integer value i from 0 to 3, the contents of ",
                "row i of ACC[AT] are set to 0."
            ]
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "19"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "210"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "82"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "146"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "18"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "75"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "107"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2s",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "43"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "42"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf32ger",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "27"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gernn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "218"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gernp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "90"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gerpn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "154"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gerpp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "26"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 4-bit Signed Integer GER ( rank-8 update )",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi4ger8",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "35"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 4-bit Signed Integer GER ( rank-8 update ) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi4ger8pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "34"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update )",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf64ger",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "59"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gernn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "250"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gernp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "122"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gerpn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "186"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gerpp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "58"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi8ger4",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "3"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi8ger4pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "2"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturate Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvi8ger4spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "99"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Absolute Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "473"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[32\u00d7BX+B].dword[i]",
                "   VSR[32\u00d7TX+T].dword[i] := bfp64_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Absolute Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvabssp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "409"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[32\u00d7BX+B].word[i]",
                "   VSR[32\u00d7TX+T].word[i] := bfp32_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Add Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvadddp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "96"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   v    := bfp_ADD(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Add Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvaddsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "64"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   v    := bfp_ADD(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Byte",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvb",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "33"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 15",
                "   if VSR[32\u00d7CX+C].byte[i].bit[0]=0 then",
                "      VSR[32\u00d7TX+T].byte[i] := VSR[32*AX+A].byte[i]",
                "   else",
                "      VSR[32\u00d7TX+T].byte[i] := VSR[32*BX+B].byte[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Doubleword",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvd",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "33"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 1",
                "   if VSR[32\u00d7CX+C].dword[i].bit[0]=0 then",
                "      VSR[32\u00d7TX+T].dword[i] := VSR[32\u00d7AX+A].dword[i]",
                "   else",
                "      VSR[32\u00d7TX+T].dword[i] := VSR[32\u00d7BX+B].dword[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Halfword",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvh",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "33"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 7",
                "   if VSR[32\u00d7CX+C].hword[i].bit[0]=0 then",
                "      VSR[32\u00d7TX+T].hword[i] := VSR[32\u00d7AX+A].hword[i]",
                "   else",
                "      VSR[32\u00d7TX+T].hword[i] := VSR[32\u00d7BX+B].hword[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Word",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvw",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "18"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "33"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 3",
                "   if VSR[32\u00d7CX+C].word[i].bit[0]=0 then",
                "      VSR[32\u00d7TX+T].word[i] := VSR[32\u00d7AX+A].word[i]",
                "   else",
                "      VSR[32\u00d7TX+T].word[i] := VSR[32\u00d7BX+B].word[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Doubleword",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxbrd",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "23"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   vsrc ~ VSR[32\u00d7BX+B].dword[i]",
                "   do j = 0 to 7",
                "      VSR[32\u00d7TX+T].dword[i].byte[j] ~ vsrc.byte[7-j]",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Halfword",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxbrh",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 7",
                "   vsrc ~ VSR[32\u00d7BX+B].hword[i]",
                "   do j = 0 to 1",
                "      VSR[32\u00d7TX+T].hword[i].byte[j] ~ vsrc.byte[1-j]",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Quadword",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxbrq",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "31"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 15",
                "   VSR[32\u00d7TX+T].byte[i] ~ VSR[32\u00d7BX+B].byte[15-i]",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxbrw",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "15"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   vsrc ~ VSR[32\u00d7BX+B].word[i]",
                "   do j = 0 to 3",
                "      VSR[32\u00d7TX+T].word[i].byte[j] ~ vsrc.byte[3-j]",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Compare Equal To Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpeqdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "7",
                    "value": "99"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "",
                "   vxsnan_flag := IsSNaN(src1) | IsSNaN(src2)",
                "",
                "   if src1 = src2 then do",
                "      vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false        := 0b0",
                "   end",
                "   else do",
                "      vresult.dword[i] := 0x0000_0000_0000_0000",
                "      all_true         := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Equal To Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpeqsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "7",
                    "value": "67"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "",
                "   vxsnan_flag := IsSNaN(src1) | IsSNaN(src2)",
                "",
                "   if src1 = src2 then do",
                "      vresult.word[i] := 0xFFFF_FFFF",
                "      all_false       := 0b0",
                "   end",
                "   else do",
                "      vresult.word[i] := 0x0000_0000",
                "      all_true        := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgtdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "7",
                    "value": "107"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "",
                "   if src1.class.SNaN | src2.class.SNaN then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "   if src1 &gt; src2 then do",
                "      vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false        := 0b0",
                "   end",
                "   else do",
                "      vresult.dword[i] := 0x0000_0000_0000_0000",
                "      all_true         := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgtsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "7",
                    "value": "75"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "",
                "   if IsSNaN(src1)=1 | IsSNaN(src2)=1 then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else",
                "      vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "   if src1 &gt; src2 then do",
                "      vresult.word[i] := 0xFFFF_FFFF",
                "      all_false       := 0b0",
                "   end",
                "   else do",
                "      vresult.word[i] := 0x0000_0000",
                "      all_true        := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than or Equal To Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgedp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "7",
                    "value": "115"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "",
                "   if src1.class.SNaN | src2.class.SNaN then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "   if src1 &gt;= src2 then do",
                "      vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false        := 0b0",
                "   end",
                "   else do",
                "      vresult.dword[i] := 0x0000_0000_0000_0000",
                "      all_true         := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than or Equal To Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgesp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "7",
                    "value": "83"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i=0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "",
                "   if src1.class.SNaN | src2.class.SNaN then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "   if src1 &gt;= src2 then do",
                "      vresult.word[i] := 0xFFFF_FFFF",
                "      all_false       := 0b0",
                "   end",
                "   else do",
                "      vresult.word[i] := 0x0000_0000",
                "      all_true        := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Convert Signed Word to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxwdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "248"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := bfp_CONVERT_FROM_SI32(VSR[32\u00d7BX+B].dword[i].word[0])",
                "   VSR[32\u00d7TX+T].dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Convert Single-Precision to Double - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "457"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src ~ bfp_CONVERT_FROM_BFP32(VSR[BX\u00d732+B].dword[i].word[0])",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert Unsigned Word to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxwdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "232"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := bfp_CONVERT_FROM_UI32(VSR[32\u00d7BX+B].dword[i].word[0])",
                "   VSR[32\u00d7TX+T].dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Convert bfloat16 to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvbf16sp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "16"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "   VSR[32\u00d7TX+T].word[i].hword[0] := VSR[32\u00d7BX+B].word[i].hword[1]",
                "   VSR[32\u00d7TX+T].word[i].hword[1] := 0x0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Convert bfloat16 to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvhpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "24"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "   src ~ bfp_CONVERT_FROM_BFP16(VSR[BX\u00d732+B].word[i].hword[1])",
                "",
                "   if src.class.SNaN=1 then",
                "      vresult.word[i] ~ bfp32_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "   else",
                "      vresult.word[i] ~ bfp32_CONVERT_FROM_BFP(src)",
                "",
                "   vxsnan_flag ~ src.class.SNaN",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   ex_flag ~ ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs, VSR[XT] is not ",
                "modified."
            ]
        },
        {
            "description": "VSX Vector Convert with round Double-Precision to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "393"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "   vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[XT] := result"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                ""
            ]
        },
        {
            "description": "VSX Vector Convert with round Signed Doubleword to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "504"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_SI64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Signed Doubleword to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "440"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_SI64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Signed Word to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxwsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "184"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_SI32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Single - Precision to bfloat16 format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspbf16",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "17"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   reset_flags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_BFLOAT16_NO_TRAP(src)",
                "   result.word[i].hword[0] := 0x0000",
                "   result.word[i].hword[1] := bfloat16_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "           :=         | (FPSCR.OE &amp; ox_flag)",
                "           :=         | (FPSCR.UE &amp; ux_flag)",
                "           :=         | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs, VSR[XT] is not ",
                "modified."
            ]
        },
        {
            "description": "VSX Vector Convert with round Single-Precision to bfloat16 format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsphp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "25"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "   src ~ bfp_CONVERT_FROM_BFP32(VSR[BX\u00d732+B].word[i])",
                "   rnd ~ bfp_ROUND_TO_BFP16(FPSCR.RN,rnd)",
                "",
                "   vresult.word[i].hword[0] ~ 0x0000",
                "   vresult.word[i].hword[1] ~ bfp16_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag ~ ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "           ~         | (FPSCR.OE &amp; ox_flag)",
                "           ~         | (FPSCR.UE &amp; ux_flag)",
                "           ~         | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs, VSR[XT] is not ",
                "modified."
            ]
        },
        {
            "description": "VSX Vector Convert with round Unsigned Doubleword to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "488"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_UI64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Unsigned Doubleword to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "424"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_UI64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "   vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Unsigned Word to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxwsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "168"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_UI32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Double-Precision to Signed Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpsxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "472"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[XT] := result"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Double-Precision to Signed Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpsxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "216"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i].word[0] := si32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " ",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Double-Precision to Unsigned Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpuxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "456"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Double-Precision to Unsigned Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpuxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "200"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i].word[0] := ui32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " ",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Signed Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspsxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "408"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].dword[i].word[0])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Signed Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspsxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "152"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.word[i] := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Unsigned Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspuxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "392"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].dword[i].word[0])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Unsigned Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspuxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "136"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.word[i] := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE &amp; vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Copy Sign Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcpsgndp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "240"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[32\u00d7AX+A].dword[i] &amp; 0x8000_0000_0000_0000",
                "   src2 := VSR[32\u00d7BX+B].dword[i] &amp; 0x7FFF_FFFF_FFFF_FFFF",
                "   VSR[32\u00d7TX+T].dword[i] := src1 | src2",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "Extended mnemonic for VSX Vector Copy Sign Dou",
                "ble-Precision:"
            ]
        },
        {
            "description": "VSX Vector Copy Sign Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvcpsgnsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "208"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[32\u00d7AX+A].word[i] &amp; 0x8000_0000",
                "   src2 := VSR[32\u00d7BX+B].word[i] &amp; 0x7FFF_FFFF",
                "   VSR[32\u00d7TX+T].word[i] := src1 | src2",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "Extended mnemonic for VSX Vector Copy Sign Sin",
                "gle-Precision:"
            ]
        },
        {
            "description": "VSX Vector Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvdivdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "120"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   v    := bfp_DIVIDE(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXZDZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxidi_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxzdz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE &amp; zx_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Divide Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvdivsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "88"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   v    := bfp_DIVIDE(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXZDZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxidi_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxzdz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE &amp; zx_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Evaluate",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxeval",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC",
                        "IMM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "IMM",
                    "size": "8"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "34"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "src1 := VSR[32xAX+A]",
                "src2 := VSR[32xBX+B]",
                "src3 := VSR[32xCX+C]",
                "result := (~src1&amp;~src2&amp;~src3 &amp; qword_bit_splat(IMM.bit[0]) |",
                "         (~src1&amp;~src2&amp; src3 &amp; qword_bit_splat(IMM.bit[1]) |",
                "         (~src1&amp; src2&amp;~src3 &amp; qword_bit_splat(IMM.bit[2]) |",
                "         (~src1&amp; src2&amp; src3 &amp; qword_bit_splat(IMM.bit[3]) |",
                "         ( src1&amp;~src2&amp;~src3 &amp; qword_bit_splat(IMM.bit[4]) |",
                "         ( src1&amp;~src2&amp; src3 &amp; qword_bit_splat(IMM.bit[5]) |",
                "         ( src1&amp; src2&amp;~src3 &amp; qword_bit_splat(IMM.bit[6]) |",
                "         ( src1&amp; src2&amp; src3 &amp; qword_bit_splat(IMM.bit[7])",
                "VSR[32xTX+T] := result"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "For each integer value i, 0 to 127, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Exponent Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvxexpdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src ~ VSR[32\u00d7BX+B].dword[i]",
                "   VSR[32\u00d7TX+T].dword[i] ~ EXTZ64(src.bit[1:11])",
                "end"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Exponent Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvxexpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "8"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src ~ VSR[32\u00d7BX+B].word[i]",
                "   VSR[32\u00d7TX+T].word[i] ~ EXTZ32(src.bit[1:8])",
                "end"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Significand Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvxsigdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src ~ VSR[32\u00d7BX+B].dword[i]",
                "   exponent ~ EXTZ(src.bit[1:11])",
                "   fraction ~ EXTZ64(src.bit[12:63])",
                "",
                "   if (exponent != 0) &amp;  (exponent != 2047) then",
                "      fraction ~ fraction | 0x0010_0000_0000_0000",
                "",
                "   VSR[32\u00d7TX+T].dword[i] ~ fraction",
                "end"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Significand Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvxsigsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "9"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src ~ VSR[32\u00d7BX+B].word[i]",
                "   exponent ~ EXTZ(src.bit[1:8])",
                "   fraction ~ EXTZ32(src.bit[9:31])",
                "",
                "   if (exponent != 0) &amp;  (exponent != 255) then",
                "      fraction ~ fraction | 0x0080_0000",
                "",
                "   VSR[32\u00d7TX+T].word[i] ~ fraction",
                "end"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Unsigned Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxextractuw",
                    "operands": [
                        "XT",
                        "XB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "165"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src ~ VSR[32\u00d7BX+B].byte[UIM:UIM+3]",
                "",
                "VSR[32\u00d7TX+T].dword[0] ~ EXTZ64(src)",
                "VSR[32\u00d7TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of byte elements UIM:UIM+3 of VSR[XB]  ",
                "are placed into word element 1 of VSR[XT]. The ",
                "contents of the remaining word elements of VSR[XT] ",
                "are set to 0.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Byte Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvbm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "916"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[i].bit[0]=1 then do",
                "         VSR[XT].byte[i] := j",
                "         j := j + 1",
                "      end",
                "      else",
                "         VSR[XT].byte[i] := i + 0x10",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[i].bit[0]=1 then do",
                "         VSR[XT].byte[j] = i",
                "         j = j + 1",
                "      end",
                "   end",
                "   do i = j to 15",
                "      VSR[XT].byte[i] = 0xUU",
                "   end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0;",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[15-i].bit[0]=1 then do",
                "         VSR[XT].byte[15-i] := j",
                "         j := j + 1",
                "      end",
                "      else",
                "         VSR[XT].byte[15-i] := i + 0x10",
                "   end",
                "end",
                "",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[15-i].bit[0]=1 then do",
                "         VSR[XT].byte[15-j] := i",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 15",
                "         VSR[XT].byte[15-i] := 0xUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "byte elements of a source vector into the byte ",
                "elements of a result vector specified by the ",
                "byte-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement a compression of the sparse ",
                "byte elements in a source vector specified by the ",
                "byte-element mask in VSR[VRB+32] into the leftmost ",
                "byte elements of a result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "byte elements of a source vector into the byte ",
                "elements of a result vector specified by the ",
                "byte-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "byte elements in a source vector specified by the ",
                "byte-element mask in VSR[VRB+32] into the rightmost ",
                "byte elements of a result vector.",
                "pcv is placed into VSR[XT].",
                "Unused values of IMM are reserved."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Doubleword Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvdm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "949"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[i].bit[0]=1 then do",
                "         VSR[XT].dword[i].byte[0] := 8\u00d7j + 0x00",
                "         VSR[XT].dword[i].byte[1] := 8\u00d7j + 0x01",
                "         VSR[XT].dword[i].byte[2] := 8\u00d7j + 0x02",
                "         VSR[XT].dword[i].byte[3] := 8\u00d7j + 0x03",
                "         VSR[XT].dword[i].byte[4] := 8\u00d7j + 0x04",
                "         VSR[XT].dword[i].byte[5] := 8\u00d7j + 0x05",
                "         VSR[XT].dword[i].byte[6] := 8\u00d7j + 0x06",
                "         VSR[XT].dword[i].byte[7] := 8\u00d7j + 0x07",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].dword[i].byte[0] := 8\u00d7i + 0x10",
                "         VSR[XT].dword[i].byte[1] := 8\u00d7i + 0x11",
                "         VSR[XT].dword[i].byte[2] := 8\u00d7i + 0x12",
                "         VSR[XT].dword[i].byte[3] := 8\u00d7i + 0x13",
                "         VSR[XT].dword[i].byte[4] := 8\u00d7i + 0x14",
                "         VSR[XT].dword[i].byte[5] := 8\u00d7i + 0x15",
                "         VSR[XT].dword[i].byte[6] := 8\u00d7i + 0x16",
                "         VSR[XT].dword[i].byte[7] := 8\u00d7i + 0x17",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[i].bit[0]=1 then do",
                "         VSR[XT].dword[j].byte[0] := 8\u00d7i + 0x00",
                "         VSR[XT].dword[j].byte[1] := 8\u00d7i + 0x01",
                "         VSR[XT].dword[j].byte[2] := 8\u00d7i + 0x02",
                "         VSR[XT].dword[j].byte[3] := 8\u00d7i + 0x03",
                "         VSR[XT].dword[j].byte[4] := 8\u00d7i + 0x04",
                "         VSR[XT].dword[j].byte[5] := 8\u00d7i + 0x05",
                "         VSR[XT].dword[j].byte[6] := 8\u00d7i + 0x06",
                "         VSR[XT].dword[j].byte[7] := 8\u00d7i + 0x07",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 1",
                "      VSR[XT].dword[i] := 0xUUUU_UUUU_UUUU_UUUU",
                "   end",
                "end",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[1-i].bit[0]=1 then do",
                "         VSR[XT].dword[1-i].byte[7] := 8\u00d7j + 0x00",
                "         VSR[XT].dword[1-i].byte[6] := 8\u00d7j + 0x01",
                "         VSR[XT].dword[1-i].byte[5] := 8\u00d7j + 0x02",
                "         VSR[XT].dword[1-i].byte[4] := 8\u00d7j + 0x03",
                "         VSR[XT].dword[1-i].byte[3] := 8\u00d7j + 0x04",
                "         VSR[XT].dword[1-i].byte[2] := 8\u00d7j + 0x05",
                "         VSR[XT].dword[1-i].byte[1] := 8\u00d7j + 0x06",
                "         VSR[XT].dword[1-i].byte[0] := 8\u00d7j + 0x07",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].dword[1-i].byte[7] := 8\u00d7i + 0x10",
                "         VSR[XT].dword[1-i].byte[6] := 8\u00d7i + 0x11",
                "         VSR[XT].dword[1-i].byte[5] := 8\u00d7i + 0x12",
                "         VSR[XT].dword[1-i].byte[4] := 8\u00d7i + 0x13",
                "         VSR[XT].dword[1-i].byte[3] := 8\u00d7i + 0x14",
                "         VSR[XT].dword[1-i].byte[2] := 8\u00d7i + 0x15",
                "         VSR[XT].dword[1-i].byte[1] := 8\u00d7i + 0x16",
                "         VSR[XT].dword[1-i].byte[0] := 8\u00d7i + 0x17",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[1-i].bit[0]=1 then do",
                "         VSR[XT].dword[1-j].byte[7] := 8\u00d7i + 0x00",
                "         VSR[XT].dword[1-j].byte[6] := 8\u00d7i + 0x01",
                "         VSR[XT].dword[1-j].byte[5] := 8\u00d7i + 0x02",
                "         VSR[XT].dword[1-j].byte[4] := 8\u00d7i + 0x03",
                "         VSR[XT].dword[1-j].byte[3] := 8\u00d7i + 0x04",
                "         VSR[XT].dword[1-j].byte[2] := 8\u00d7i + 0x05",
                "         VSR[XT].dword[1-j].byte[1] := 8\u00d7i + 0x06",
                "         VSR[XT].dword[1-j].byte[0] := 8\u00d7i + 0x07",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 1",
                "         VSR[XT].dword[1-i] := 0xUUUU_UUUU_UUUU_UUUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "doubleword elements of a source vector into the ",
                "doubleword elements of a result vector specified by ",
                "the doubleword-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the the permute control ",
                "vector required to enable a left-indexed permute ",
                "(vperm or xxperm) to implement a compression of the ",
                "sparse doubleword elements in a source vector ",
                "specified by the doubleword-element mask in ",
                "VSR[VRB+32] into the leftmost doubleword elements of a ",
                "result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "doubleword elements of a source vector into the ",
                "doubleword elements of a result vector specified by ",
                "the doubleword-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "doubleword elements in a source vector specified by ",
                "the doubleword-element mask in VSR[VRB+32] into the ",
                "rightmost doubleword elements of a result vector.",
                "pcv is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Halfword Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvhm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "917"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[i].bit[0]=1 then do",
                "         VSR[XT].hword[i].byte[0] := 2\u00d7j + 0x00",
                "         VSR[XT].hword[i].byte[1] := 2\u00d7j + 0x01",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].hword[i].byte[0] := 2\u00d7i + 0x10",
                "         VSR[XT].hword[i].byte[1] := 2\u00d7i + 0x11",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[i].bit[0]=1 then do",
                "         VSR[XT].hword[j].byte[0] := 2\u00d7i + 0x00",
                "         VSR[XT].hword[j].byte[1] := 2\u00d7i + 0x01",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 7",
                "      VSR[XT].hword[i] := 0xUUUU",
                "   end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[7-i].bit[0]=1 then do",
                "         VSR[XT].hword[7-i].byte[1] := 2\u00d7j + 0x00",
                "         VSR[XT].hword[7-i].byte[0] := 2\u00d7j + 0x01",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].hword[7-i].byte[1] := 2\u00d7i + 0x10",
                "         VSR[XT].hword[7-i].byte[0] := 2\u00d7i + 0x11",
                "      end",
                "   end",
                "end",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[7-i].bit[0]=1 then do",
                "         VSR[XT].hword[7-j].byte[1] := 2\u00d7i + 0x00",
                "         VSR[XT].hword[7-j].byte[0] := 2\u00d7i + 0x01",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 7",
                "         VSR[XT].hword[7-i] := 0xUUUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "halfword elements of a source vector into the halfword ",
                "elements of a result vector specified by the ",
                "halfword-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement a compression of the sparse ",
                "halfword elements in a source vector specified by the ",
                "halfword-element mask in VSR[VRB+32] into the leftmost ",
                "halfword elements of a result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "halfword elements of a source vector into the halfword ",
                "elements of a result vector specified by the ",
                "halfword-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "halfword elements in a source vector specified by the ",
                "halfword-element mask in VSR[VRB+32] into the ",
                "rightmost halfword elements of a result vector.",
                "pcv is placed into VSR[XT].",
                "Unused values of IMM are reserved."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Word Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvwm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "948"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[i].bit[0]=1 then do",
                "         VSR[XT].word[i].byte[0] := 4\u00d7j + 0x00",
                "         VSR[XT].word[i].byte[1] := 4\u00d7j + 0x01",
                "         VSR[XT].word[i].byte[2] := 4\u00d7j + 0x02",
                "         VSR[XT].word[i].byte[3] := 4\u00d7j + 0x03",
                "         j = j + 1",
                "      end",
                "      else do",
                "         VSR[XT].word[i].byte[0] := 4\u00d7i + 0x10",
                "         VSR[XT].word[i].byte[1] := 4\u00d7i + 0x11",
                "         VSR[XT].word[i].byte[2] := 4\u00d7i + 0x12",
                "         VSR[XT].word[i].byte[3] := 4\u00d7i + 0x13",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[i].bit[0]=1 then do",
                "         VSR[XT].word[j].byte[0] := 4\u00d7i + 0x00",
                "         VSR[XT].word[j].byte[1] := 4\u00d7i + 0x01",
                "         VSR[XT].word[j].byte[2] := 4\u00d7i + 0x02",
                "         VSR[XT].word[j].byte[3] := 4\u00d7i + 0x03",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 3",
                "      VSR[XT].word[i] := 0xUUUU_UUUU",
                "   end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[3-i].bit[0]=1 then do",
                "         VSR[XT].word[3-i].byte[3] := 4\u00d7j + 0x00",
                "         VSR[XT].word[3-i].byte[2] := 4\u00d7j + 0x01",
                "         VSR[XT].word[3-i].byte[1] := 4\u00d7j + 0x02",
                "         VSR[XT].word[3-i].byte[0] := 4\u00d7j + 0x03",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].word[3-i].byte[3] := 4\u00d7i + 0x10",
                "         VSR[XT].word[3-i].byte[2] := 4\u00d7i + 0x11",
                "         VSR[XT].word[3-i].byte[1] := 4\u00d7i + 0x12",
                "         VSR[XT].word[3-i].byte[0] := 4\u00d7i + 0x13",
                "      end",
                "   end",
                "end",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[3-i].bit[0]=1 then do",
                "         VSR[XT].word[3-j].byte[3] := 4\u00d7i + 0x00",
                "         VSR[XT].word[3-j].byte[2] := 4\u00d7i + 0x01",
                "         VSR[XT].word[3-j].byte[1] := 4\u00d7i + 0x02",
                "         VSR[XT].word[3-j].byte[0] := 4\u00d7i + 0x03",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 3",
                "         VSR[XT].word[3-i] := 0xUUUU_UUUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "word elements of a source vector into the word ",
                "elements of a result vector specified by the ",
                "word-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement a compression of the sparse ",
                "word elements in a source vector specified by the ",
                "word-element mask in VSR[VRB+32] into the leftmost ",
                "word elements of a result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "word elements of a source vector into the word ",
                "elements of a result vector specified by the ",
                "word-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "word elements in a source vector specified by the ",
                "word-element mask in VSR[VRB+32] into the rightmost ",
                "word elements of a result vector.",
                "pcv is placed into VSR[XT].",
                "Unused values of IMM are reserved."
            ]
        },
        {
            "description": "VSX Vector Insert Exponent Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xviexpdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "248"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 ~ VSR[32\u00d7AX+A].dword[i]",
                "   src2 ~ VSR[32\u00d7BX+B].dword[i]",
                "",
                "   VSR[32\u00d7TX+T].dword[i].bit[0]     ~ src1.bit[0]",
                "   VSR[32\u00d7TX+T].dword[i].bit[1:11]  ~ src2.bit[53:63]",
                "   VSR[32\u00d7TX+T].dword[i].bit[12:63] ~ src1.bit[12:63]",
                "end"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Insert Exponent Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xviexpsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "216"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 ~ VSR[32\u00d7AX+A].word[i]",
                "   src2 ~ VSR[32\u00d7BX+B].word[i]",
                "",
                "   VSR[32\u00d7TX+T].word[i].bit[0]    ~ src1.bit[0]",
                "   VSR[32\u00d7TX+T].word[i].bit[1:8]  ~ src2.bit[24:31]",
                "   VSR[32\u00d7TX+T].word[i].bit[9:31] ~ src1.bit[9:31]",
                "end"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Insert Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxinsertw",
                    "operands": [
                        "XT",
                        "XB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "181"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].byte[UIM:UIM+3] ~ VSR[32\u00d7BX+B].bit[32:63]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of word element 1 of VSR[XB] are placed ",
                "into byte elements UIM:UIM+3 of VSR[XT]. The contents ",
                "of the remaining byte elements of VSR[XT] are not ",
                "modified.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "VSX Vector Logical AND",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxland",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "130"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := VSR[32\u00d7AX+A] &amp; VSR[32\u00d7BX+B]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are ANDed with the contents ",
                "of VSR[XB] and the result is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical AND with Complement",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxlandc",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "138"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := VSR[32\u00d7AX+A] &amp; ~VSR[32\u00d7BX+B]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are ANDed with the ",
                "complement of the contents of VSR[XB] and the result is ",
                "placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical Equivalence",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxleqv",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "186"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := VSR[32\u00d7AX+A] == VSR[32\u00d7BX+B]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are exclusive-ORed with the ",
                "contents of VSR[XB] and the complemented result is ",
                "placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical NAND",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxlnand",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "178"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := ~( VSR[32\u00d7AX+A] &amp; VSR[32\u00d7BX+B] )"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are ANDed with the contents ",
                "of VSR[XB] and the complemented result is placed into ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical NOR",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxlnor",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "162"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := ~( VSR[32\u00d7AX+A] | VSR[32\u00d7BX+B] )"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are ORed with the contents of ",
                "VSR[XB] and the complemented result is placed into ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical OR",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxlor",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "146"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := VSR[32\u00d7AX+A] | VSR[32\u00d7BX+B]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are ORed with the contents of ",
                "VSR[XB] and the result is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical OR with Complement",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxlorc",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "170"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := VSR[32\u00d7AX+A] | ~VSR[32\u00d7BX+B]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are ORed with the ",
                "complement of the contents of VSR[XB] and the result is ",
                "placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical XOR",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxlxor",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "154"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T] := VSR[32\u00d7AX+A] ^ VSR[32\u00d7BX+B]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of VSR[XA] are exclusive-ORed with the ",
                "contents of VSR[XB] and the result is placed into ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Maximum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmaxdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "224"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32\u00d7AX+A].dword[i]",
                "   src2 := VSR[32\u00d7BX+B].dword[i]",
                "   vresult.dword[i] := bfp64_MAXIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Maximum Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmaxsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "192"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32\u00d7AX+A].word[i]",
                "   src2 := VSR[32\u00d7BX+B].word[i]",
                "   vresult.word[i] := bfp32_MAXIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Merge High Word",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxmrghw",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "18"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].word[0] := VSR[32\u00d7AX+A].word[0]",
                "VSR[32\u00d7TX+T].word[1] := VSR[32\u00d7BX+B].word[0]",
                "VSR[32\u00d7TX+T].word[2] := VSR[32\u00d7AX+A].word[1]",
                "VSR[32\u00d7TX+T].word[3] := VSR[32\u00d7BX+B].word[1]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of word element 0 of VSR[XA] are placed ",
                "into word element 0 of VSR[XT].",
                "The contents of word element 0 of VSR[XB] are placed ",
                "into word element 1 of VSR[XT].",
                "The contents of word element 1 of VSR[XA] are placed ",
                "into word element 2 of VSR[XT].",
                "The contents of word element 1 of VSR[XB] are placed ",
                "into word element 3 of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Merge Low Word",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxmrglw",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "50"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].word[0] := VSR[32\u00d7AX+A].word[2]",
                "VSR[32\u00d7TX+T].word[1] := VSR[32\u00d7BX+B].word[2]",
                "VSR[32\u00d7TX+T].word[2] := VSR[32\u00d7AX+A].word[3]",
                "VSR[32\u00d7TX+T].word[3] := VSR[32\u00d7BX+B].word[3]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of word element 2 of VSR[XA] are placed ",
                "into word element 0 of VSR[XT].",
                "The contents of word element 2 of VSR[XB] are placed ",
                "into word element 1 of VSR[XT].",
                "The contents of word element 3 of VSR[XA] are placed ",
                "into word element 2 of VSR[XT].",
                "The contents of word element 3 of VSR[XB] are placed ",
                "into word element 3 of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Minimum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmindp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "232"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32\u00d7AX+A].dword[i]",
                "   src2 := VSR[32\u00d7BX+B].dword[i]",
                "   vresult.dword[i] := bfp64_MINIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Minimum Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvminsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "200"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32\u00d7AX+A].word[i]",
                "   src2 := VSR[32\u00d7BX+B].word[i]",
                "   vresult.word[i] := bfp32_MINIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmuldp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "112"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "   src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   v    := bfp_MULTIPLY(src1,src3)",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmulsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "80"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "   src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   v    := bfp_MULTIPLY(src1,src3)",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "97"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Multiply-Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "65"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "105"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if \u201cxvmaddadp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "73"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if \u201cxvmaddasp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "113"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "81"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "121"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if \u201cxvmsubadp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "89"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if \u201cxvmsubasp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negate Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnegdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "505"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[32\u00d7BX+B].dword[i]",
                "   VSR[32\u00d7TX+T].dword[i] := bfp64_NEGATE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Negate Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnegsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "441"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[32\u00d7BX+B].word[i]",
                "   VSR[32\u00d7TX+T].word[i] := bfp32_NEGATE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Negative Absolute Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "489"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[32\u00d7BX+B].dword[i]",
                "   VSR[32\u00d7TX+T].dword[i] := bfp64_NEGATIVE_ABSOLUTE(src)"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Negative Absolute Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnabssp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "425"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[32\u00d7BX+B].word[i]",
                "   VSR[32\u00d7TX+T].word[i] := bfp32_NEGATIVE_ABSOLUTE(src)"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "225"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "193"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "233"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if \u201cxvnmaddadp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP64(FPSCR.RN,v))",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "201"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if \u201cxvnmaddasp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN,v))",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP32(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "241"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "209"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "249"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if \u201cxvnmsubadp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP64(FPSCR.RN,v))",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "217"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if \u201cxvnmsubasp\u201d then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN,v))",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP32(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Permute",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxperm",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "26"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.byte[0:15]  ~ VSR[32\u00d7AX+A]",
                "src.byte[16:31] ~ VSR[32\u00d7TX+T]",
                "pcv.byte[0:15]  ~ VSR[32\u00d7BX+B]",
                "",
                "do i = 0 to 15",
                "   idx ~ pcv.byte[i].bit[3:7]",
                "   VSR[32\u00d7TX+T].byte[i] ~ src.byte[idx]",
                "end"
            ],
            "body": [
                "Let XA be the value 32\u00d7AX + A.",
                "Let bytes 0:15 of src be the contents of VSR[XA].",
                "Let the permute control vector pcv be the contents of ",
                "VSR[XB].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Permute Doubleword Immediate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxpermdi",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "DM"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "DM",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "10"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].dword[0] := VSR[32\u00d7AX+A].dword[DM.bit[0]]",
                "VSR[32\u00d7TX+T].dword[1] := VSR[32\u00d7BX+B].dword[DM.bit[1]]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "If DM.bit[0]=0, the contents of doubleword element 0 ",
                "of VSR[XA] are placed into doubleword element 0 of ",
                "VSR[XT]. Otherwise the contents of doubleword ",
                "element 1 of VSR[XA] are placed into doubleword ",
                "element 0 of VSR[XT].",
                "If DM.bit[1]=0, the contents of doubleword element 0 ",
                "of VSR[XB] are placed into doubleword element 1 of ",
                "VSR[XT]. Otherwise the contents of doubleword ",
                "element 1 of VSR[XB] are placed into doubleword ",
                "element 1 of VSR[XT].",
                "Extended mnemonics for VSX Vector Permute Double",
                "word Immediate:"
            ]
        },
        {
            "description": "VSX Vector Permute Extended",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxpermx",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC",
                        "UIM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "UIM",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "34"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.qword[0] := VSR[32\u00d7AX+A]",
                "src.qword[1] := VSR[32\u00d7BX+B]",
                "do i = 0 to 15",
                "   section := VSR[32\u00d7CX+C].byte[i].bit[0:2]",
                "   eidx    := VSR[32\u00d7CX+C].byte[i].bit[3:7]",
                "   if section=UIM then",
                "      VSR[32\u00d7TX+T].byte[i] := src.byte[eidx]",
                "   else ",
                "      VSR[32\u00d7TX+T].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "Let UIM specify which 32-byte section of the long vector ",
                "that src contains.",
                "Let src be the concatenation VSR[XA] and VSR[XB], ",
                "comprising a 32-byte section of up to a 128-byte ",
                "vector.",
                "For each integer value i from 0 to 15, do the following.",
                " ",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Vector Permute Right-indexed",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxpermr",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "58"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.byte[0:15]  ~ VSR[32\u00d7AX+A]",
                "src.byte[16:31] ~ VSR[32\u00d7TX+T]",
                "pcv.byte[0:15]  ~ VSR[32\u00d7BX+B]",
                "",
                "do i = 0 to 15",
                "   idx ~ pcv.byte[i].bit[3:7]",
                "   VSR[32\u00d7TX+T].byte[i] ~ src.byte[31-idx]",
                "end"
            ],
            "body": [
                "Let XA be the value 32\u00d7AX + A.",
                "Let bytes 0:15 of src be the contents of VSR[XA].",
                "Let the permute control vector pcv be the contents of ",
                "VSR[XB].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvredp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "218"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   v   := bfp_RECIPROCAL_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE &amp; zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvresp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "154"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   v   := bfp_RECIPROCAL_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE &amp; zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Square Root Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrsqrtedp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "202"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   v   := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE &amp; zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Square Root Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrsqrtesp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "138"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   v   := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE &amp; zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                " ",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer Exact using Current rounding mode",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpic",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "235"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "",
                "   if FPSCR.RN=0b00 then",
                "      rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "   if FPSCR.RN=0b01 then",
                "      rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "   if FPSCR.RN=0b10 then",
                "      rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "   if FPSCR.RN=0b11 then",
                "      rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round to Nearest Away",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpi",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "201"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round toward +Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpip",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "233"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round toward -Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpim",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "249"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round toward Zero",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpiz",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "217"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer Exact using Current rounding mode",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrspic",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "171"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   if FPSCR.RN=0b00 then",
                "      rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "   if FPSCR.RN=0b01 then",
                "      rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "   if FPSCR.RN=0b10 then",
                "      rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "   if FPSCR.RN=0b11 then",
                "      rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round to Nearest Away",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrspi",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "137"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round toward +Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrspip",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "169"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round toward -Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrspim",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "185"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round toward Zero",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvrspiz",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "153"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Select",
            "form": "XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxsel",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "3"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[32\u00d7AX+A]",
                "src2 := VSR[32\u00d7BX+B]",
                "mask := VSR[32\u00d7CX+C]",
                "",
                "VSR[32\u00d7TX+T] := (src1 &amp; ~mask) | (src2 &amp; mask)"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let src1 be the contents of VSR[XA].",
                "The value, (src1&amp;~mask)|(src2&amp;mask), is placed ",
                "into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Shift Left Double by Word Immediate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxsldwi",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "SHW"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "1",
                    "value": "0"
                },
                {
                    "name": "SHW",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "source.qword[0] := VSR[32\u00d7AX+A]",
                "source.qword[1] := VSR[32\u00d7BX+B]",
                "VSR[32\u00d7TX+T] := source.word[SHW:SHW+3]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[XA] followed by the contents of VSR[XB].",
                "Words SHW:SHW+3 of vsrc are placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate Byte",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxspltib",
                    "operands": [
                        "XT",
                        "IMM8"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "IMM8",
                    "size": "8"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "360"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 &amp; MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 &amp; MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   VSR[32\u00d7TX+T].byte[i] ~ UIM8",
                "end"
            ],
            "body": [
                "Let XT be the sum 32\u00d7TX + T.",
                "The value IMM8 is copied into each byte element of ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate Double - Precision",
            "form": "8RR:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxspltidp",
                    "operands": [
                        "XT",
                        "IMM32"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "imm0",
                    "size": "16"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "32"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "2"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "imm1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "IMM32 ~ imm0&lt;&lt;16 | imm1;",
                "",
                "temp ~ bfp_CONVERT_FROM_BFP32(IMM32);",
                "",
                "VSR[32\u00d7TX+T].dword[0] ~ bfp64_CONVERT_FROM_BFP(IMM32);",
                "VSR[32\u00d7TX+T].dword[1] ~ bfp64_CONVERT_FROM_BFP(IMM32);"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let IMM32 be the concatenation of imm0 and imm1, ",
                "representing a single-precision value.",
                "IMM32 is converted to double-precision format and ",
                "placed into each doubleword element of VSR[XT].",
                "If IMM32 specifies a single-precision denormal value ",
                "(i.e., bits 1:8 equal to 0 and bits 9:31 not equal to 0), ",
                "the result is undefined."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate Word",
            "form": "8RR:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxspltiw",
                    "operands": [
                        "XT",
                        "IMM32"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "imm0",
                    "size": "16"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "32"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "3"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "imm1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "IMM32 := imm0&lt;&lt;16 | imm1",
                "",
                "do i = 0 to 3",
                "   VSR[32\u00d7TX+T].word[i] := IMM32",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "IMM32 is placed into each word element of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate32 Doubleword Indexed",
            "form": "8RR:D-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxsplti32dx",
                    "operands": [
                        "XT",
                        "IX",
                        "IMM32"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "0"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "imm0",
                    "size": "16"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "32"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "0"
                },
                {
                    "name": "IX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "imm1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "IMM32 := imm0&lt;&lt;16 | imm1",
                "",
                "VSR[32\u00d7TX+T].dword[0].word[IX] := IMM32",
                "VSR[32\u00d7TX+T].dword[1].word[IX] := IMM32"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32\u00d7TX + T.",
                "IMM32 is placed into word element IX of each ",
                "doubleword element of VSR[XT]. The contents of the ",
                "remaining word elements are not modified."
            ]
        },
        {
            "description": "VSX Vector Splat Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xxspltw",
                    "operands": [
                        "XT",
                        "XB",
                        "UIM"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "UIM",
                    "size": "2"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "164"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32\u00d7TX+T].word[0] := VSR[32\u00d7BX+B].word[UIM]",
                "VSR[32\u00d7TX+T].word[1] := VSR[32\u00d7BX+B].word[UIM]",
                "VSR[32\u00d7TX+T].word[2] := VSR[32\u00d7BX+B].word[UIM]",
                "VSR[32\u00d7TX+T].word[3] := VSR[32\u00d7BX+B].word[UIM]"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "The contents of word element UIM of VSR[XB] are ",
                "replicated in each word element of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvsqrtdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "203"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   v   := bfp_SQUARE_ROOT(src)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Square Root Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvsqrtsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "139"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].word[i])",
                "   v   := bfp_SQUARE_ROOT(src)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Subtract Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvsubdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "104"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32\u00d7BX+B].dword[i])",
                "   v    := bfp_ADD(src1,bfp_NEGATE(src2))",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Subtract Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvsubsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "72"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32\u00d7BX+B].word[i])",
                "   v    := bfp_ADD(src1,bfp_NEGATE(src2))",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1     then SetFX(FPSCR.OX)",
                "   if ux_flag=1     then SetFX(FPSCR.UX)",
                "   if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE &amp; vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE &amp; ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE &amp; ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE &amp; xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32\u00d7TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32\u00d7TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Test Data Class Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvtstdcdp",
                    "operands": [
                        "XT",
                        "XB",
                        "DCMX"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "dx",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "15"
                },
                {
                    "name": "dx",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "5"
                },
                {
                    "name": "dm",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "DCMX ~ dc || dm || dx",
                "",
                "do i = 0 to 1",
                "   src            ~ VSR[32\u00d7BX+B].dword[i]",
                "   sign           ~ src.bit[0]",
                "   exponent       ~ src.bit[1:11]",
                "   fraction       ~ src.bit[12:63]",
                "",
                "   class.Infinity ~ (exponent = 0x7FF) &amp; (fraction  = 0)",
                "   class.NaN      ~ (exponent = 0x7FF) &amp; (fraction != 0)",
                "   class.Zero     ~ (exponent = 0x000) &amp; (fraction  = 0)",
                "   class.Denormal ~ (exponent = 0x000) &amp; (fraction != 0)",
                "",
                "   match          ~ (DCMX.bit[0] &amp; class.NaN)              |",
                "                   (DCMX.bit[1] &amp; class.Infinity &amp; !sign) |",
                "                   (DCMX.bit[2] &amp; class.Infinity &amp;  sign) |",
                "                   (DCMX.bit[3] &amp; class.Zero     &amp; !sign) |",
                "                   (DCMX.bit[4] &amp; class.Zero     &amp;  sign) |",
                "                   (DCMX.bit[5] &amp; class.Denormal &amp; !sign) |",
                "                   (DCMX.bit[6] &amp; class.Denormal &amp;  sign)",
                "",
                "   if match = 1 then",
                "      VSR[32\u00d7TX+T].dword[i] ~ 0xFFFF_FFFF_FFFF_FFFF",
                "   else",
                "      VSR[32\u00d7TX+T].dword[i] ~ 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XB be the sum 32\u00d7BX + B.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Test Data Class Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvtstdcsp",
                    "operands": [
                        "XT",
                        "XB",
                        "DCMX"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "dx",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "13"
                },
                {
                    "name": "dx",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "3",
                    "value": "5"
                },
                {
                    "name": "dm",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "DCMX ~ dc || dm || dx",
                "",
                "do i = 0 to 3",
                "   src            ~ VSR[32\u00d7BX+B].word[i]",
                "   sign           ~ src.bit[0]",
                "   exponent       ~ src.bit[1:8]",
                "   fraction       ~ src.bit[9:31]",
                "",
                "   class.Infinity ~ (exponent = 0xFF) &amp; (fraction  = 0)",
                "   class.NaN      ~ (exponent = 0xFF) &amp; (fraction != 0)",
                "   class.Zero     ~ (exponent = 0x00) &amp; (fraction  = 0)",
                "   class.Denormal ~ (exponent = 0x00) &amp; (fraction != 0)",
                "",
                "   match          ~ (DCMX.bit[0] &amp; class.NaN)              |",
                "                   (DCMX.bit[1] &amp; class.Infinity &amp; !sign) |",
                "                   (DCMX.bit[2] &amp; class.Infinity &amp;  sign) |",
                "                   (DCMX.bit[3] &amp; class.Zero     &amp; !sign) |",
                "                   (DCMX.bit[4] &amp; class.Zero     &amp;  sign) |",
                "                   (DCMX.bit[5] &amp; class.Denormal &amp; !sign) |",
                "                   (DCMX.bit[6] &amp; class.Denormal &amp;  sign)",
                "",
                "   if match = 1 then",
                "      VSR[32\u00d7TX+T].dword[i] ~ 0xFFFF_FFFF",
                "   else",
                "      VSR[32\u00d7TX+T].dword[i] ~ 0x0000_0000",
                "end"
            ],
            "body": [
                "Let XB be the sum 32\u00d7BX + B.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Test Least-Significant Bit by Byte",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvtlsbb",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "475"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ALL_TRUE  := 1 ",
                "ALL_FALSE := 1",
                "",
                "do i = 0 to 15",
                "   ALL_TRUE  := ALL_TRUE  &amp; (VSR[XB].byte[i].bit[7]=1)",
                "   ALL_FALSE := ALL_FALSE &amp; (VSR[XB].byte[i].bit[7]=0)",
                "end",
                "",
                "CR.field_WRITE(BF, ALL_TRUE, 0, ALL_FALSE, 0);"
            ],
            "body": [
                "Set CR field BF to indicate if bit 7 of every byte element in VSR[XB] is equal to 1 (ALL_TRUE) or equal to 0 (ALL_FALSE)."
            ]
        },
        {
            "description": "VSX Vector Test for software Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvtdivdp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "125"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "eq_flag := 0b0",
                "gt_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   src1    := VSR[32\u00d7AX+A].dword[i]",
                "   src2    := VSR[32\u00d7BX+B].dword[i]",
                "   e_a     := src1.bit[1:11] - 1023",
                "   e_b     := src2.bit[1:11] - 1023",
                "   fe_flag := fe_flag | IsNaN(src1) | IsInf(src1) |",
                "              IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "              ( e_b &lt;= -1022 ) |",
                "              ( e_b &gt;=  1021 ) |",
                "              ( !IsZero(src1) &amp; ( (e_a - e_b) &gt;=  1023 ) ) |",
                "              ( !IsZero(src1) &amp; ( (e_a - e_b) &lt;= -1021 ) ) |",
                "              ( !IsZero(src1) &amp; ( e_a &lt;= -970 ) )",
                "   fg_flag := fg_flag | IsInf(src1) | IsInf(src2) |",
                "              IsZero(src2) | IsDen(src2)",
                "end"
            ],
            "body": [
                "Let XA be the value 32\u00d7AX + A.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 1, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector Test for software Divide Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvtdivsp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "93"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "eq_flag := 0b0",
                "gt_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   src1    := VSR[32\u00d7AX+A].word[i]",
                "   src2    := VSR[32\u00d7BX+B].word[i]",
                "   e_a     := src1.bit[1:8] - 127",
                "   e_b     := src2.bit[1:8] - 127",
                "   fe_flag := fe_flag | IsNaN(src1) | IsInf(src1) |",
                "              IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "              ( e_b &lt;= -126 ) |",
                "              ( e_b &gt;=  125 ) |",
                "              ( !IsZero(src1) &amp; ( (e_a - e_b) &gt;=  127 ) ) |",
                "              ( !IsZero(src1) &amp; ( (e_a - e_b) &lt;= -125 ) ) |",
                "              ( !IsZero(src1) &amp; ( e_a &lt;= -103 ) )",
                "   fg_flag := fg_flag | IsInf(src1) | IsInf(src2) |",
                "              IsZero(src2) | IsDen(src2)",
                "end",
                "",
                "fl_flag := xvredp_error() &lt;= 2-14",
                "CR.field[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XA be the value 32\u00d7AX + A.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 3, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector Test for software Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvtsqrtdp",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "234"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "fe_flag := 0b0",
                "fg_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   src     := VSR[32\u00d7BX+B].dword[i]",
                "   e_b     := src2.bit[1:11] - 1023",
                "   fe_flag := fe_flag | IsNaN(src) | IsInf(src)  |",
                "              IsZero(src) | IsNeg(src) | ( e_a &lt;= -970 )",
                "   fg_flag := fg_flag | IsInf(src) | IsZero(src) |",
                "              IsDen(src)",
                "end",
                "",
                "fl_flag := xvrsqrtedp_error() &lt;= 2-14",
                "CR.field[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XB be the value 32\u00d7BX + B.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 1, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector Test for software Square Root Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvtsqrtsp",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "9",
                    "value": "170"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "fe_flag := 0b0",
                "fg_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   src     := VSR[32\u00d7BX+B].word[i]",
                "   e_b     := src2.bit[1:8] - 127",
                "   fe_flag := fe_flag | IsNaN(src) | IsInf(src) |",
                "              IsZero(src) | IsNeg(src) | ( e_a &lt;= -103 )",
                "   fg_flag := fg_flag | IsInf(src) | IsZero(src) |",
                "              IsDen(src)",
                "end",
                "",
                "fl_flag = xvrsqrtesp_error() &lt;= 2-14",
                "CR.field[BF]  = 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XB be the value 32\u00d7BX + B.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 3, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "51"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "242"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "114"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "178"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "8",
                    "value": "50"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": []
        },
        {
            "description": "Vector 2 Raised to the Exponent Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vexptefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "394"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_POWER2_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Let x be any single-precision floating-point input value. ",
                "Unless x &lt; -146 or the single-precision floating-point ",
                "result of computing 2 raised to the power x would be a ",
                "zero, an infinity, or a QNaN, the estimate has a relative ",
                "error in precision no greater than one part in 16. The ",
                "most significant 12 bits of the estimate\u2019s significand ",
                "are monotonic. An integral input value returns an ",
                "integral value when the result is representable.",
                "The result for various special cases of the source ",
                "value is given below. "
            ]
        },
        {
            "description": "Vector AES Cipher",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcipher",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1288"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := SubBytes(State)",
                "vtemp2   := ShiftRows(vtemp1)",
                "vtemp3   := MixColumns(vtemp2)",
                "VSR[VRT+32]  := vtemp3 ^ RoundKey"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "One round of an AES cipher operation is performed on ",
                "the intermediate State array, sequentially applying the ",
                "transforms, SubBytes(), ShiftRows(), MixColumns(), ",
                "and AddRoundKey(), as defined in FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "new intermediate state of the cipher operation."
            ]
        },
        {
            "description": "Vector AES Cipher Last",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcipherlast",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1289"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := SubBytes(State)",
                "vtemp2   := ShiftRows(vtemp1)",
                "VSR[VRT+32]  := vtemp2 ^ RoundKey"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "The final round in an AES cipher operation is ",
                "performed on the intermediate State array, ",
                "sequentially applying the transforms, SubBytes(), ",
                "ShiftRows(), AddRoundKey(), as defined in FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "final state of the cipher operation."
            ]
        },
        {
            "description": "Vector AES Inverse Cipher",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vncipher",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1352"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := InvShiftRows(State)",
                "vtemp2   := InvSubBytes(vtemp1)",
                "vtemp3   := vtemp2 ^ RoundKey",
                "VSR[VRT+32]  := InvMixColumns(vtemp3)"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES inverse cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "One round of an AES inverse cipher operation is ",
                "performed on the intermediate State array, ",
                "sequentially applying the transforms, InvShiftRows(), ",
                "InvSubBytes(), AddRoundKey(), and InvMixColumns(), ",
                "as defined in FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "new intermediate state of the inverse cipher operation."
            ]
        },
        {
            "description": "Vector AES Inverse Cipher Last",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vncipherlast",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1353"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := InvShiftRows(State)",
                "vtemp2   := InvSubBytes(vtemp1)",
                "VSR[VRT+32]  := vtemp2 ^ RoundKey"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES inverse cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "The final round in an AES inverse cipher operation is ",
                "performed on the intermediate State array, ",
                "sequentially applying the transforms, InvShiftRows(), ",
                "InvSubBytes(), and AddRoundKey(), as defined in ",
                "FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "final state of the inverse cipher operation."
            ]
        },
        {
            "description": "Vector AES SubBytes",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsbox",
                    "operands": [
                        "VRT",
                        "VRA"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1480"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State   := VSR[VRA+32]",
                "VSR[VRT+32] := SubBytes(State)"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES cipher ",
                "operation.",
                "The result of applying the transform, SubBytes() on ",
                "State, as defined in FIPS-197, is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Absolute Difference Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vabsdub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1027"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "   if src1 &gt; src2 then ",
                "      VSR[VRT+32].byte[i] := CHOP8(src1 + ~src2 + 1)",
                "   else",
                "      VSR[VRT+32].byte[i] := CHOP8(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Absolute Difference Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vabsduh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1091"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "   if src1 &gt; src2 then ",
                "      VSR[VRT+32].hword[i] := CHOP16(src1 + ~src2 + 1)",
                "   else",
                "      VSR[VRT+32].hword[i] := CHOP16(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Absolute Difference Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vabsduw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1155"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   if src1 &gt; src2 then",
                "      VSR[VRT+32].word[i] := CHOP32(src1 + ~src2 + 1)",
                "   else",
                "      VSR[VRT+32].word[i] := CHOP32(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add & Write Carry-out Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddcuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "384"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "src1 := EXTZ(VSR[VRA+32].word[i])",
                "src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := CHOP32((src1 + src2) &gt;&gt; 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddcuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "320"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "sum  := EXTZ(src1) + EXTZ(src2)",
                "",
                "VSR[VRT+32] := EXTZ128((src1 + src2) &gt;&gt; 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1 and src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Extended & write Carry-out Unsigned Quadword",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddecuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "61"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := EXTZ128((src1 + src2 + cin) &gt;&gt; 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1, src2, and cin  are ",
                "placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Extended Unsigned Quadword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddeuqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "60"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + cin)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1, src2, and cin  ",
                "are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ADD(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add Signed Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddsbs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "768"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "src1 := EXTS(VSR[VRA+32].byte[i])",
                "src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := si8_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Add Signed Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "832"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "src1 := EXTS(VSR[VRA+32].hword[i])",
                "src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := si16_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Add Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddsws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "896"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA].word[i])",
                "   src2 := EXTS(VSR[VRB].word[i])",
                "",
                "   VSR[VRT+32].word[i] := si32_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add Unsigned Byte Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddubm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "0"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "src1 := EXTZ(VSR[VRA+32].byte[i])",
                "src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := CHOP8(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddubs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "512"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := ui8_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Add Unsigned Doubleword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vaddudm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "192"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "VSR[VRT+32].dword[i] := CHOP64(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Halfword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vadduhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "64"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := CHOP16(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vadduhs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "576"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := ui16_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Add Unsigned Quadword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vadduqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "256"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1 and src2 are ",
                "placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Unsigned Word Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vadduwm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "128"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := CHOP32(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vadduws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "640"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := ui32_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Average Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vavgsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1282"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTS(VSR[VRA+32].byte[i])",
                "   src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "   VSR[VRT+32].byte[i] := CHOP8((src1 + src2 + 1) &gt;&gt; 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Average Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vavgsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1346"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16((src1 + src2 + 1) &gt;&gt; 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Average Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vavgsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1410"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := Chop32((src1 + src2 + 1) &gt;&gt; 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Average Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vavgub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1026"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "   VSR[VRT+32].byte[i] := CHOP8((src1 + src2 + 1) &gt;&gt; 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Average Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vavguh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1090"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16((src1 + src2 + 1) &gt;&gt; 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Average Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vavguw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1154"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := Chop32((src1 + src2 + 1) &gt;&gt; 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Bit Permute Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vbpermd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1484"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   do j = 0 to 7 ",
                "      index := VSR[VRB+32].dword[i].byte[j]",
                "      if index &lt; 64 then",
                "         perm.bit[j] := VSR[VRA+32].dword[i].bit[index]",
                "      else",
                "         perm.bit[j] := 0",
                "   end",
                "   VSR[VRT+32].dword[i] := EXTZ64(perm)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, and for each ",
                "integer value j from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Bit Permute Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vbpermq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1356"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   index := VSR[VRB+32].byte[i]",
                "   if index &lt; 128 then",
                "      perm.bit[i] := VSR[VRA+32].bit[index]",
                "   else",
                "      perm.bit[i] := 0",
                "end",
                "VSR[VRT+32].dword[0] := CHOP64(EXTZ(perm))",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "The contents of bits 0:47 of VSR[VRT+32] are set to 0. ",
                "The contents of bits 64:127 of VSR[VRT+32] are set to 0. ",
                "  "
            ]
        },
        {
            "description": "Vector Centrifuge Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcfuged",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1357"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   ptr0 := 0",
                "   ptr1 := 0",
                "   do j = 0 to 63",
                "      if VSR[VRB+32].dword[i].bit[j]=0b0 then do",
                "         result.bit[ptr0] := VSR[VRA+32].dword[i].bit[j]",
                "         ptr0 := ptr0 + 1",
                "      end",
                "      if VSR[VRB+32].dword[i].bit[63-j]=1 then do",
                "         result.bit[63-ptr1] := VSR[VRA+32].dword[i].bit[63-j]",
                "         ptr1 := ptr1 + 1",
                "      end",
                "   end",
                "   VSR[VRT+32].dword[i] := result",
                "end"
            ],
            "body": [
                "For each doubleword element i of VSR[VRA+32], the ",
                "bits whose corresponding bits in the mask in ",
                "doubleword element i of VSR[VRB+32] equal 1 are ",
                "placed in the rightmost bits in doubleword element i of ",
                "VSR[VRT+32], maintaining their original relative order.  ",
                "The other bits in doubleword element i of VSR[VRA+32] ",
                "are placed in the leftmost bits in doubleword element i ",
                "of VSR[VRT+32], maintaining their original relative order."
            ]
        },
        {
            "description": "Vector Clear Leftmost Bytes",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclrlb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "397"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "N := (GPR[RB] &gt; 15) ? 16: GPR[RB]",
                "",
                "do i = 0 to N-1",
                "   VSR[VRT+32].byte[15-i] := VSR[VRA+32].byte[15-i]",
                "end",
                "",
                "do i = N to 15",
                "   VSR[VRT+32].byte[15-i] := 0x00",
                "end"
            ],
            "body": [
                "Let N be the integer value in GPR[RB], or the integer ",
                "value 16 if the integer value in GPR[RB] is greater than ",
                "15.",
                "The contents of VSR[VRA+32] are placed into ",
                "VSR[VRT+32] with the leftmost 16-N bytes of VSR[VRT+32] ",
                "set to 0."
            ]
        },
        {
            "description": "Vector Clear Rightmost Bytes",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclrrb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "461"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "N := (GPR[RB] &gt; 15) ? 16: GPR[RB]",
                "do i = 0 to N-1",
                "   VSR[VRT+32].byte[i] := VSR[VRA+32].byte[i]",
                "end",
                "",
                "do i = N to 15",
                "   VSR[VRT+32].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "Let N be the integer value in GPR[RB], or the integer ",
                "value 16 if the integer value in GPR[RB] is greater than ",
                "15.",
                "The contents of VSR[VRA+32] are placed into ",
                "VSR[VRT+32] with the rightmost 16-N bytes of ",
                "VSR[VRT+32] set to 0.",
                "A valid encoding of a packed decimal integer value ",
                "requires the following properties.",
                "Source operands with sign codes of 0b1010, 0b1100, ",
                "0b1110, and 0b1111 are interpreted as positive values.",
                "Source operands with sign codes of 0b1011 and 0b1101 ",
                "are interpreted as negative values.",
                "Positive and zero results are encoded with a either ",
                "sign code of 0b1100 or 0b1111, depending on the ",
                "preferred sign (indicated as an immediate operand).",
                "Negative results are encoded with a sign code of ",
                "0b1101."
            ]
        },
        {
            "description": "Vector Compare Bounds Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpbfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpbfp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "966"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   le := bool_COMPARE_LE_BFP32(src1,src2)",
                "   ge := bool_COMPARE_GE_BFP32(src1,src2)",
                "   VSR[VRT+32].word[i] := ~le || ~ge || 300",
                "end",
                "if Rc=1 then do",
                "   ib := (VSR[VRT+32]=0)",
                "   CR6 := 0b00 || ib || 0b0",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set as follows.",
                " "
            ]
        },
        {
            "description": "Vector Compare Equal Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpeqfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpeqfp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "198"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if bool_COMPARE_EQ_BFP32(src1,src2)=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   else",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Quadword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "mnemonic": "vcmpequq.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "455"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32]",
                "",
                "if src1 = src2 then do",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   all_false := 0",
                "end",
                "else do",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "If src1 is equal to src2, set VSR[VRT+32] to all 1s. ",
                "Otherwise, set VSR[VRT+32] to all 0s."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpequb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Doubleword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "mnemonic": "vcmpequd.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "199"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpequh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "70"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpequw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "134"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtfp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "710"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if bool_COMPARE_GT_BFP32(src1,src2)=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   else",
                "      all_true := 0",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtsb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "774"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := EXTS(VSR[VRA+32].byte[i])",
                "   src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Doubleword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "mnemonic": "vcmpgtsd.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "967"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].dword[i])",
                "   src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtsh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "838"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Quadword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "mnemonic": "vcmpgtsq.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "903"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := EXTS(VSR[VRA+32])",
                "src2 := EXTS(VSR[VRB+32])",
                "",
                "if src1 &gt; src2 then do",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   all_false := 0",
                "end",
                "else do",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "src1 is compared to src2.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than src2, and are set to all 0s otherwise.",
                "If Rc=1, CR field 6 is set to indicate if src1 is greater ",
                "than src2 or if src1 is not greater than src2."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtsw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "902"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtub.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "518"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Doubleword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "mnemonic": "vcmpgtud.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "711"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtuh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "582"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Quadword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "mnemonic": "vcmpgtuq.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "647"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "if src1 &gt; src2 then do",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   all_false := 0",
                "end",
                "else do",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "src1 is compared to src2.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than src2, and are set to all 0s otherwise.",
                "If Rc=1, CR field 6 is set to indicate if src1 is greater ",
                "than src2 or if src1 is not greater than src2."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtuw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "646"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   if src1 &gt; src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than or Equal Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgefp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgefp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "454"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if bool_COMPARE_GE_BFP32(src1,src2)=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   else",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpneb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpneb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "7"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   if src1 != src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpneh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpneh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "71"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   if src1 != src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnew",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnew.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "135"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   if src1 != src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal or Zero Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnezb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnezb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "263"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal or Zero Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnezh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnezh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "327"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal or Zero Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnezw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnezw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "391"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true&lt;&lt;3) + (all_false&lt;&lt;1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpsq",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "321"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTS(VSR[VRA+32])",
                "src2 := EXTS(VSR[VRB+32])",
                "",
                "lt_flag := src1 &lt; src2",
                "gt_flag := src1 &gt; src2",
                "eq_flag := src1 = src2",
                "",
                "CR.field[BF] := lt_flag&lt;&lt;3 | gt_flag&lt;&lt;2 | eq_flag&lt;&lt;1"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "Compare src1 with src2, place the comparison flags ",
                "into CR field BF."
            ]
        },
        {
            "description": "Vector Compare Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcmpuq",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "257"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "lt_flag := src1 &lt; src2",
                "gt_flag := src1 &gt; src2",
                "eq_flag := src1 = src2",
                "",
                "CR.field[BF] := lt_flag&lt;&lt;3 | gt_flag&lt;&lt;2 | eq_flag&lt;&lt;1"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "Compare src1 with src2, place the comparison flags ",
                "into CR field BF."
            ]
        },
        {
            "description": "Vector Convert with round to nearest From Signed Word to floating-point format",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcfsx",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "842"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_CONVERT_FROM_SI32(src,UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Convert with round to nearest From Unsigned Word to floating-point format",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcfux",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "778"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_CONVERT_FROM_UI32(src,UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                ""
            ]
        },
        {
            "description": "Vector Convert with round to zero from floating-point  To Unsigned Word format Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctuxs",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "906"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := ui32_CONVERT_FROM_BFP32(src, UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Convert with round to zero from floating-point To Signed Word format Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctsxs",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "970"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := si32_CONVERT_FROM_BFP32(src, UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zero Least-Significant Bits Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclzlsbb",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count := 0",
                "do while count &lt; 16",
                "   if VSR[VRB+32].byte[count].bit[7]=1 break",
                "   count := count + 1",
                "end",
                "GPR[RT] := EXTZ64(count)"
            ],
            "body": [
                "Let count be the number of contiguous leading byte ",
                "elements in VSR[VRB+32] having a zero least-significant ",
                "bit.",
                "count is placed into GPR[RT]."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclzb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1794"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   n := 0",
                "   do while n &lt; 8",
                "      if VSR[VRB+32].byte[i].bit[n] = 0b1 then leave ",
                "      n := n + 1",
                "   end",
                "   VSR[VRT+32].byte[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclzd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1986"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   n := 0",
                "   do while (n&lt;64) &amp; (VSR[VRB+32].dword[i].bit[n]=0b0)",
                "      n := n + 1",
                "   end",
                "   VSR[VRT+32].dword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Doubleword under bit Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclzdm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1924"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   count := 0",
                "   do j = 0 to 63",
                "      if VSR[VRB+32].dword[i].bit[j]=1 then do",
                "         if VSR[VRA+32].dword[i].bit[i]=1 then break",
                "         count := count + 1",
                "      end",
                "   end",
                "   VSR[VRT+32].dword[i] := EXTZ64(count)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, starting on the ",
                "left, count the number of consecutive 0 bits in ",
                "doubleword element i of VSR[VRA+32] corresponding to ",
                "1 bits in doubleword element i of VSR[VRB+32]. Place ",
                "count in doubleword element i of VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclzh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1858"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   n  := 0",
                "   do while n &lt; 16",
                "      if VSR[VRB+32].hword[i].bit[n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].hword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vclzw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1922"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   n  := 0",
                "   do while n &lt; 32",
                "      if VSR[VRB+32].word[i].bit[n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].word[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Count Mask Bits Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbb",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "12"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 15",
                "   count := count + EXTZ8(VSR[VRB+32].byte[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count &lt;&lt; 56"
            ],
            "body": [
                "The number of byte elements having bit 0 set to the ",
                "value MP in VSR[VRB+32] is placed into bits 0:7 of ",
                "GPR[RT]. Bits 8:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Mask Bits Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbd",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "15"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 1",
                "   count := count + EXTZ64(VSR[VRB+32].dword[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count &lt;&lt; 59"
            ],
            "body": [
                "The number of doubleword elements having bit 0 set ",
                "to the value MP in VSR[VRB+32] is placed into bits 0:4 of ",
                "GPR[RT]. Bits 5:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Mask Bits Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbh",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "13"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 7",
                "   count := count + EXTZ64(VSR[VRB+32].hword[i].bit[0]=MP)",
                "",
                "GPR[RT] := count &lt;&lt; 57"
            ],
            "body": [
                "The number of halfword elements having bit 0 set to ",
                "the value MP in VSR[VRB+32] is placed into bits 0:6 of ",
                "GPR[RT]. Bits 7:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Mask Bits Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbw",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "4",
                    "value": "14"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 3",
                "   count := count + EXTZ64(VSR[VRB+32].word[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count &lt;&lt; 58"
            ],
            "body": [
                "The number of word elements having bit 0 set to the ",
                "value MP in VSR[VRB+32] is placed into bits 0:5 of ",
                "GPR[RT]. Bits 6:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Trailing Zero Least-Significant Bits Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctzlsbb",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count := 0",
                "do while count &lt; 16",
                "   if VSR[VRB+32].byte[15-count].bit[7]=1 break",
                "   count := count + 1",
                "end",
                "GPR[RT] := EXTZ64(count)"
            ],
            "body": [
                "Let count be the number of contiguous trailing byte ",
                "elements of VSR[VRB+32] having a zero least-significant ",
                "bit.",
                "count is placed into GPR[RT]."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctzb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "28"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   n := 0",
                "   do while n &lt; 8",
                "      if VSR[VRB+32].byte[i].bit[7-n] = 0b1 then leave ",
                "      n := n + 1",
                "   end",
                "   VSR[VRT+32].byte[i] := CHOP8(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctzd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "31"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   n  := 0",
                "   do while n &lt; 64",
                "      if VSR[VRB+32].dword[i].bit[63-n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Doubleword under bit Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctzdm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1988"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   count := 0",
                "   do j = 0 to 63",
                "      if VSR[VRB+32].dword[i].bit[63-j]=1 then do",
                "         if VSR[VRA+32].dword[i].bit[63-i]=1 then break",
                "         count := count + 1",
                "      end",
                "   end",
                "   VSR[VRT+32].dword[i] := EXTZ64(count)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, starting on the ",
                "right, count the number of consecutive 0 bits in ",
                "doubleword element i of VSR[VRA+32] corresponding to ",
                "1 bits in doubleword element i of VSR[VRB+32]. Place ",
                "count in doubleword element i of VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctzh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "29"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   n  := 0",
                "   do while n &lt; 16",
                "      if VSR[VRB+32].hword[i].bit[15-n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].hword[i] := CHOP16(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vctzw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "30"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   n  := 0",
                "   do while n &lt; 32",
                "      if VSR[VRB+32].word[i].bit[31-n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivesd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "971"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTS(VSR[VRA+32].dword[i]) &lt;&lt; 64",
                "   divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivesq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "779"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32]) &lt;&lt; 128",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend \u00f7 divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32] ",
                "concatenated with 128 0s.",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique signed integer that satisfies",
                "where 0 \u00a3 r &lt; |divisor| if dividend is nonnegative, ",
                "and |divisor| &lt; r \u00a3 0 if dividend is negative.",
                "If the quotient cannot be represented in 128 bits, or if ",
                "an attempt is made to perform the division ",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Extended Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivesw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "907"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTS(VSR[VRA+32].word[i]) &lt;&lt; 32",
                "   divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdiveud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "715"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTZ(VSR[VRA+32].dword[i]) &lt;&lt; 64",
                "   divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdiveuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "523"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32]) &lt;&lt; 128",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend \u00f7 divisor)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32] ",
                "concatenated with 128 0s.",
                "Let src2 be the unsigned integer value in VSR[VRB+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique unsigned integer that ",
                "satisfies",
                "where 0 \u00a3 r &lt; divisor.",
                "If the quotient cannot be represented in 128 bits, or if ",
                "an attempt is made to perform the division",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Extended Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdiveuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "651"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTZ(VSR[VRA+32].word[i]) &lt;&lt; 32",
                "   divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "459"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTS(VSR[VRA+32].dword[i])",
                "   divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivsq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "267"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32])",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend \u00f7 divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique signed integer that satisfies",
                "where 0\u00a3r&lt;|divisor| if the dividend is ",
                "nonnegative, and -|divisor|&lt;r\u00a30 if the dividend is ",
                "negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "395"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTS(VSR[VRA+32].word[i])",
                "   divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "203"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTZ(VSR[VRA+32].dword[i])",
                "   divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32])",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend \u00f7 divisor)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique unsigned integer that ",
                "satisfies",
                "where 0\u00a3r&lt;divisor.",
                "If an attempt is made to perform the division",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vdivuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "139"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTZ(VSR[VRA+32].word[i])",
                "   divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend \u00f7 divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Expand Byte Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vexpandbm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   if VSR[VRB+32].byte[i].bit[0]=1 then",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "   end",
                "      VSR[VRT+32].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Expand Doubleword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vexpanddm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "3"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   if VSR[VRB+32].dword[i].bit[0]=1 then",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "   else",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Expand Halfword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vexpandhm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   if VSR[VRB+32].hword[i].bit[0]=1 then",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "   else",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Expand Quadword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vexpandqm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if VSR[VRB+32].bit[0]=1 then",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "else",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000"
            ],
            "body": [
                "Let bmi be the contents of bit 0 of VSR[VRB+32].",
                "The contents of VSR[VRT+32] are set to all 0s if bmi is ",
                "equal to 0.",
                "The contents of VSR[VRT+32] are set to all 1s if bmi is ",
                "equal to 1."
            ]
        },
        {
            "description": "Vector Expand Word Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vexpandwm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   if VSR[VRB+32].word[i].bit[0]=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "   else",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Byte To Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextsb2d",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "24"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[VRB+32].dword[i].bit[56:63]",
                "",
                "   VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Byte To Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextsb2w",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "16"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i].bit[24:31]",
                "",
                "   VSR[VRT+32].word[i] := EXTS32(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Doubleword to Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextsd2q",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "27"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := EXTS128(VSR[VRB+32].bit[64:127])"
            ],
            "body": [
                "The signed integer in bits 64:127 of VSR[VRB+32] is ",
                "signed extended to 128 bits and placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Extend Sign Halfword To Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextsh2d",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "25"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[VRB+32].dword[i].bit[48:63]",
                "",
                "   VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Halfword To Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextsh2w",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "17"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i].bit[16:31]",
                "",
                "   VSR[VRT+32].word[i] := EXTS32(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Word To Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextsw2d",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "26"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[VRB+32].dword[i].bit[32:63]",
                "",
                "   VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Extract Byte Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractbm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "8"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   GPR[RT].bit[48+i] := VSR[VRB+32].byte[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:47] := 0"
            ],
            "body": [
                "The contents of bit 0 of each byte element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "48:63 of GPR[RT]. Bits 0:47 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Double Doubleword to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextddvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "30"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := src.byte[index:index+7]",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements index:index+7 of src ",
                "are placed into doubleword 0 of VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 24, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Doubleword to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextddvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := src.byte[24-index:31-index]",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements 24-index:31-index of ",
                "src are placed into doubleword 0 of VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 24, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Byte to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextdubvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "24"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte element index of vsrc are ",
                "zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Byte to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextdubvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "25"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte element 31-index of vsrc are ",
                "zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Halfword to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextduhvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "26"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[index:index+1])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements index:index+1 of vsrc ",
                "are zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 30, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Halfword to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextduhvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "27"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[30-index:31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements 30-index:31-index of ",
                "vsrc are zero-extended and placed into doubleword 0 ",
                "of VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 30, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Word to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextduwvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "28"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src.byte[index:index+3])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements index:index+3 of src ",
                "are zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 28, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Word to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextduwvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "29"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src.byte[28-index:31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements 28-index:31-index of ",
                "src are zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 28, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Doubleword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractdm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "11"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   GPR[RT].bit[62+i] := VSR[VRB+32].dword[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:61] := 0"
            ],
            "body": [
                "The contents of bit 0 of each doubleword element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "62:63 of GPR[RT]. Bits 0:61 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Doubleword to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractd",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "717"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+7]",
                "",
                "VSR[VRT+32].dword[0] := src",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte elements UIM:UIM+7 of ",
                "VSR[VRB+32]  are placed into VSR[VRT+32]. The contents ",
                "of doubleword element 1 of VSR[VRT+32] are set to 0.",
                "If the value of UIM is greater than 8, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Halfword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextracthm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "9"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   GPR[RT].bit[56+i] := VSR[VRB+32].hword[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:55] := 0"
            ],
            "body": [
                "The contents of bit 0 of each halfword element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "56:63 of GPR[RT]. Bits 0:55 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Quadword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractqm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "12"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RT] := EXTZ64(VSR[VRB+32].bit[0])"
            ],
            "body": [
                "The contents of bit 0 of VSR[VRB+32] are placed into bit ",
                "63 of GPR[RT]. Bits 0:62 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Byte to GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextublx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1549"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte element index of VSR[VRB+32] are ",
                "placed into bits 56:63 of GPR[RT].",
                "The contents of bits 0:55 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Byte to GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextubrx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1805"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[15-index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte element 15-index of VSR[VRB+32] ",
                "are placed into bits 56:63 of GPR[RT].",
                "The contents of bits 0:55 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Byte to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractub",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "525"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte element UIM of VSR[VRB+32] are ",
                "placed into bits 56:63 of VSR[VRT+32]. The contents of ",
                "the remaining byte elements of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Halfword to GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextuhlx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1613"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index:index+1])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements index:index+1 of ",
                "VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
                "The contents of bits 0:47 of GPR[RT] are set to 0.",
                "If the value of index is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Halfword to GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextuhrx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1869"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[14-index:15-index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements 14-index:15-index of ",
                "VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
                "The contents of bits 0:47 of GPR[RT] are set to 0.",
                "If the value of index is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Halfword to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractuh",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "589"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+1]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte elements UIM:UIM+1 of ",
                "VSR[VRB+32] are placed into halfword element 3 of ",
                "VSR[VRT+32]. The contents of the remaining halfword ",
                "elements of VSR[VRT+32] are set to 0.",
                "If the value of UIM is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Word to GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextuwlx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1677"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index:index+3])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements index:index+3 of ",
                "VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
                "The contents of bits 0:31 of GPR[RT] are set to 0.",
                "If the value of index is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Word to GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextuwrx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1933"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[12-index:15-index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements index:index+3 of ",
                "VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
                "The contents of bits 0:31 of GPR[RT] are set to 0.",
                "If the value of index is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Word to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractuw",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "653"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+3]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte elements UIM:UIM+3 of ",
                "VSR[VRB+32] are placed into word element 1 of ",
                "VSR[VRT+32]. The contents of the remaining word ",
                "elements of VSR[VRT+32] are set to 0.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Word Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vextractwm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "10"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1602"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   GPR[RT].bit[60+i] := VSR[VRB+32].word[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:59] := 0"
            ],
            "body": [
                "The contents of bit 0 of each word element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "60:63 of GPR[RT]. Bits 0:59 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Gather Bits by Bytes by Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vgbbd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1292"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "    do j = 0 to 7",
                "        do k = 0 to 7",
                "            b := VSR[VRB+32].dword[i].byte[k].bit[j]",
                "            VSR[VRT+32].dword[i].byte[j].bit[k] := b",
                "        end",
                "    end",
                "end"
            ],
            "body": [
                "Let src be the contents of VSR[VRB+32], composed of ",
                "two doubleword elements numbered 0 and 1.",
                "Let each doubleword element be composed of eight ",
                "bytes  numbered 0 through 7.",
                "An 8-bit \u00d7 8-bit bit-matrix transpose is performed on ",
                "the contents of each doubleword element of ",
                "VSR[VRB+32] (see Figure 106).",
                "For each integer value i from 0 to 1, do the following,"
            ]
        },
        {
            "description": "Vector Gather every Nth Bit",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vgnb",
                    "operands": [
                        "RT",
                        "VRB",
                        "N"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "N",
                    "size": "3"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1228"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "if N&lt;2 | N&gt;7 then",
                "   result := UNDEFINED",
                "else do",
                "   j := 0",
                "   result := 0x0000_0000_0000_0000",
                "   do i = 0 to 127 by N",
                "      result.bit[j] := VSR[VRB+32].bit[i]",
                "      j := j + 1",
                "   end",
                "end",
                "GPR[RT] := result"
            ],
            "body": [
                "Starting with bit 0, the contents of every Nth bit of ",
                "VSR[VRB+32] are concatenated and placed into GPR[RT].",
                "N can be any value between 2 and 7, inclusive."
            ]
        },
        {
            "description": "Vector Insert Byte from GPR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsblx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "527"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index] := GPR[RB].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of GPR[RB] are placed into ",
                "byte element index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsbrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "783"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[15-index] := GPR[RB].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of GPR[RB] are placed into ",
                "byte element 15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from VSR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsbvlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "15"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index] := VSR[VRB+32].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of VSR[VRB+32] are placed ",
                "into byte element index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from VSR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsbvrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "271"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[15-index] := VSR[VRB+32].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of VSR[VRB+32] are placed ",
                "into byte element 15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsertb",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "781"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM] := VSR[VRB+32].byte[7]"
            ],
            "body": [
                "The contents of byte element 7 of VSR[VRB+32] are ",
                "placed into byte element UIM of VSR[VRT+32]. The ",
                "contents of the remaining byte elements of ",
                "VSR[VRT+32] are not modified."
            ]
        },
        {
            "description": "Vector Insert Doubleword from GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsdlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "719"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+7] := GPR[RB]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of GPR[RB] are placed into byte elements ",
                "index:index+7 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 8, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Doubleword from GPR using GPR-specified Right-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsdrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "975"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[8-index:15-index] := GPR[RB]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of GPR[RB] are placed into byte elements ",
                "8-index:15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 8, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Doubleword from GPR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsd",
                    "operands": [
                        "VRT",
                        "RB",
                        "UIM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "463"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32].byte[UIM:UIM+7] := GPR[RB]"
            ],
            "body": [
                "The contents of GPR[RB] are placed into byte elements ",
                "UIM:UIM+7 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If UIM is greater than 8, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Doubleword from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsertd",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "973"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+7] := VSR[VRB+32].dword[0]"
            ],
            "body": [
                "The contents of doubleword element 0 of VSR[VRB+32] ",
                "are placed into byte elements UIM:UIM+7 of ",
                "VSR[VRT+32]. The contents of the remaining byte ",
                "elements of VSR[VRT+32] are not modified.",
                "If the value of UIM is greater than 8, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinshlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "591"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index:index+1] := GPR[RB].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of GPR[RB] are placed into ",
                "byte elements index:index+1 of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinshrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "847"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[14-index:15-index] := GPR[RB].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of GPR[RB] are placed into ",
                "byte elements 14-index:15-index of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from VSR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinshvlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "79"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index:index+1] := VSR[VRB+32].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of VSR[VRB+32] are placed ",
                "into byte elements index:index+1 of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from VSR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinshvrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "335"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[14-index:15-index] := VSR[VRB+32].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of VSR[VRB+32] are placed ",
                "into byte elements 14-index:15-index of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinserth",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "845"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+1] := VSR[VRB+32].hword[3]"
            ],
            "body": [
                "The contents of halfword element 3 of VSR[VRB+32] are ",
                "placed into byte elements UIM:UIM+1 of VSR[VRT+32]. ",
                "The contents of the remaining byte elements of ",
                "VSR[VRT+32] are not modified.",
                "If the value of UIM is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Insert Word from GPR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinswlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "655"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+3] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of GPR[RB] are placed into ",
                "byte elements index:index+3 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinswrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "911"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[12-index:15-index] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of GPR[RB] are placed into ",
                "byte elements 12-index:15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from GPR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsw",
                    "operands": [
                        "VRT",
                        "RB",
                        "UIM"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "207"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32].byte[UIM:UIM+3] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "The contents of bits 32:63 of GPR[RB] are placed into ",
                "byte elements UIM:UIM+3 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If UIM is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from VSR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinswvlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "143"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+3] := VSR[VRB+32].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of VSR[VRB+32] are placed ",
                "into byte elements index:index+3 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from VSR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinswvrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "399"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[12-index:15-index] := VSR[VRB+32].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of VSR[VRB+32] are placed ",
                "into byte elements 12-index:15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vinsertw",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "909"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+3] := VSR[VRB+32].word[1]"
            ],
            "body": [
                "The contents of word element 1 of VSR[VRB+32] are ",
                "placed into byte elements UIM:UIM+3 of VSR[VRT+32]. ",
                "The contents of the remaining byte elements of ",
                "VSR[VRT+32] are not modified.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Log Base 2 Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vlogefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "458"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_LOG_BASE2_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Let x be any single-precision floating-point input value. ",
                "Unless | x-1 | is less than or equal to 0.125 or the ",
                "single-precision floating-point result of computing the ",
                "base 2 logarithm of x would be an infinity or a QNaN, ",
                "the estimate has an absolute error in precision ",
                "(absolute value of the difference between the estimate ",
                "and the infinitely precise value) no greater than 2-5. ",
                "Under the same conditions, the estimate has a relative ",
                "error in precision no greater than one part in 8.",
                "The most significant 12 bits of the estimate\u2019s ",
                "significand are monotonic. The estimate is exact if ",
                "x=2y, where y is an integer between -149 and +127 ",
                "inclusive. Otherwise the value placed into the element ",
                "of VSR[VRT+32] may vary between implementations, ",
                "and between different executions on the same ",
                "implementation.",
                "The result for various special cases of the source ",
                "value is given below.  "
            ]
        },
        {
            "description": "Vector Logical AND",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vand",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1028"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] &amp; VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ANDed with the ",
                "contents of VSR[VRB+32] and the result is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical AND with Complement",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vandc",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1092"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] &amp; ~VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ANDed with the ",
                "complement of the contents of VSR[VRB+32] and the ",
                "result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical Equivalence",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "veqv",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1668"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] == VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are XORed with the ",
                "contents of VSR[VRB+32] and the complemented result ",
                "is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical NAND",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vnand",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1412"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := ~( VSR[VRA+32] &amp; VSR[VRB+32] )"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ANDed with the ",
                "contents of VSR[VRB+32] and the complemented result ",
                "is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical NOR",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vnor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1284"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := ~( VSR[VRA+32] | VSR[VRB+32] )"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ORed with the ",
                "contents of VSR[VRB+32] and the complemented result ",
                "is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical OR",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1156"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] | VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ORed with the ",
                "contents of VSR[VRB+32] and the result is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical OR with Complement",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vorc",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1348"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] | ~VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ORed with the ",
                "complement of the contents of VSR[VRB+32] and the ",
                "result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical XOR",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vxor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1220"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] ^ VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are XORed with the ",
                "contents of VSR[VRB+32] and the result is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Maximum Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1034"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_MAXIMUM(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "The maximum of +0.0 and -0.0 is +0.0. The maximum ",
                "of any value and a NaN is a QNaN."
            ]
        },
        {
            "description": "Vector Maximum Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "258"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   gt_flag := EXTS(src1) &gt; EXTS(src2)",
                "   VSR[VRT+32].byte[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Maximum Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "450"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   gt_flag := EXTS(src1) &gt; EXTS(src2)",
                "   VSR[VRT+32].dword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Maximum Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "322"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   gt_flag := EXTS(src1) &gt; EXTS(src2)",
                "   VSR[VRT+32].hword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Maximum Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "386"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   gt_flag := EXTS(src1) &gt; EXTS(src2)",
                "   VSR[VRT+32].word[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "2"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   gt_flag := EXTZ(src1) &gt; EXTZ(src2)",
                "   VSR[VRT+32].byte[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "194"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   gt_flag := EXTZ(src1) &gt; EXTZ(src2)",
                "   VSR[VRT+32].dword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "66"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   gt_flag := EXTZ(src1) &gt; EXTZ(src2)",
                "   VSR[VRT+32].hword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaxuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "130"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   gt_flag := EXTZ(src1) &gt; EXTZ(src2)",
                "   VSR[VRT+32].word[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Merge Even Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrgew",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1932"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[0]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[0]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[2]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[2]"
            ],
            "body": []
        },
        {
            "description": "Vector Merge High Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrghb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "12"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i].byte[0] := VSR[VRA+32].byte[i]",
                "   VSR[VRT+32].hword[i].byte[1] := VSR[VRB+32].byte[i]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Merge High Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrghh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "76"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i].hword[0] := VSR[VRA+32].hword[i]",
                "   VSR[VRT+32].word[i].hword[1] := VSR[VRB+32].hword[i]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Merge High Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrghw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "140"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[0]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[0]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[1]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[1]"
            ],
            "body": []
        },
        {
            "description": "Vector Merge Low Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrglb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "268"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i].byte[0] := VSR[VRA+32].byte[i+8]",
                "   VSR[VRT+32].hword[i].byte[1] := VSR[VRB+32].byte[i+8]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Merge Low Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrglh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "332"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i].hword[0] := VSR[VRA+32].hword[i+4]",
                "   VSR[VRT+32].word[i].hword[1] := VSR[VRB+32].hword[i+4]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Merge Low Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrglw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "396"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[2]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[2]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[3]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[3]"
            ],
            "body": []
        },
        {
            "description": "Vector Merge Odd Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmrgow",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1676"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[1]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[1]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[3]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[3]"
            ],
            "body": []
        },
        {
            "description": "Vector Minimum Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1098"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_MINIMUM(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "The minimum of +0.0 and -0.0 is -0.0. The minimum ",
                "of any value and a NaN is a QNaN."
            ]
        },
        {
            "description": "Vector Minimum Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "770"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   lt_flag := EXTS(src1) &lt; EXTS(src2)",
                "   VSR[VRT+32].byte[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Minimum Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "962"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   lt_flag := EXTS(src1) &lt; EXTS(src2)",
                "   VSR[VRT+32].dword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Minimum Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "834"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   lt_flag := EXTS(src1) &lt; EXTS(src2)",
                "   VSR[VRT+32].hword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Minimum Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "898"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   lt_flag := EXTS(src1) &lt; EXTS(src2)",
                "   VSR[VRT+32].word[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "514"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   lt_flag := EXTZ(src1) &lt; EXTZ(src2)",
                "   VSR[VRT+32].byte[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "706"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   lt_flag := EXTZ(src1) &lt; EXTZ(src2)",
                "   VSR[VRT+32].dword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "578"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   lt_flag := EXTZ(src1) &lt; EXTZ(src2)",
                "   VSR[VRT+32].hword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vminuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "642"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   lt_flag := EXTZ(src1) &lt; EXTZ(src2)",
                "   VSR[VRT+32].word[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Modulo Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmodsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1995"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTS(VSR[VRA+32].dword[i])",
                "   divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Modulo Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmodsq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1803"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32])",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend % divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "The remainder of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The remainder is the unique signed integer that ",
                "satisfies",
                "remainder = dividend - (quotient \u00d7 divisor)",
                "where 0\u00a3remainder&lt;|divisor| if the dividend is ",
                "nonnegative, and -|divisor|&lt;remainder\u00a30 if the ",
                "dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "&lt;anything&gt; % 0",
                "0x8000_0000_0000_0000 % -1",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Modulo Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmodsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1931"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTS(VSR[VRA+32].word[i])",
                "   divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Modulo Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmodud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1739"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTZ(VSR[VRA+32].dword[i])",
                "   divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Modulo Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmoduq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1547"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32])",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend % divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "The remainder of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The remainder is the unique signed integer that ",
                "satisfies",
                "remainder = dividend - (quotient \u00d7 divisor)",
                "where 0 \u00a3 remainder &lt; divisor.",
                "If an attempt is made to perform any of the divisions",
                "&lt;anything&gt; % 0",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Modulo Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmoduw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1675"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTZ(VSR[VRA+32].word[i])",
                "   divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulesb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "776"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].byte[2\u00d7i])",
                "   src2 := EXTS(VSR[VRB+32].byte[2\u00d7i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulesd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "968"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := EXTS(VSR[VRA+32].dword[0])",
                "src2 := EXTS(VSR[VRB+32].dword[0])",
                "",
                "VSR[VRT+32] := CHOP128(src1 \u00d7 src2)"
            ],
            "body": [
                "Let src1 be the signed integer value in doubleword ",
                "element 0 of VSR[VRA+32].",
                "Let src2 be the signed integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulesh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "840"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].hword[2\u00d7i])",
                "   src2 := EXTS(VSR[VRB+32].hword[2\u00d7i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulesw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "904"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].word[2\u00d7i])",
                "   src2 := EXTS(VSR[VRB+32].word[2\u00d7i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmuleub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "520"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].byte[2\u00d7i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[2\u00d7i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmuleud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "712"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32].dword[0])",
                "src2 := EXTZ(VSR[VRB+32].dword[0])",
                "",
                "VSR[VRT+32] := CHOP128(src1 \u00d7 src2)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in doubleword ",
                "element 0 of VSR[VRA+32].",
                "Let src2 be the unsigned integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmuleuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "584"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].hword[2\u00d7i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[2\u00d7i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmuleuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "648"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].word[2\u00d7i])",
                "   src2 := EXTZ(VSR[VRB+32].word[2\u00d7i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulhsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "969"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].dword[i])",
                "   src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64((src1 \u00d7 src2) &gt;&gt; 64)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulhsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "905"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32((src1 \u00d7 src2) &gt;&gt; 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulhud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "713"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64((src1 \u00d7 src2) &gt;&gt; 64)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulhuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "649"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32((src1 \u00d7 src2) &gt;&gt; 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Low Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulld",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "457"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].dword[i])",
                "   src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulosb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "264"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].byte[2\u00d7i+1])",
                "   src2 := EXTS(VSR[VRB+32].byte[2\u00d7i+1])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulosd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "456"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTS(VSR[VRA+32].dword[1])",
                "src2 := EXTS(VSR[VRB+32].dword[1])",
                "",
                "VSR[VRT+32] := CHOP128(src1 \u00d7 src2)"
            ],
            "body": [
                "Let src1 be the signed integer value in doubleword ",
                "element 1 of VSR[VRA+32].",
                "Let src2 be the signed integer value in doubleword ",
                "element 1 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulosh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "328"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].hword[2\u00d7i+1])",
                "   src2 := EXTS(VSR[VRB+32].hword[2\u00d7i+1])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulosw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "392"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].word[2\u00d7i+1])",
                "   src2 := EXTS(VSR[VRB+32].word[2\u00d7i+1])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmuloub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "8"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].byte[2\u00d7i+1])",
                "   src2 := EXTZ(VSR[VRB+32].byte[2\u00d7i+1])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmuloud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "200"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := EXTZ(VSR[VRA+32].dword[1])",
                "src2 := EXTZ(VSR[VRB+32].dword[1])",
                "",
                "VSR[VRT+32] := CHOP128(src1 \u00d7 src2)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in doubleword ",
                "element 1 of VSR[VRA+32].",
                "Let src2 be the unsigned integer value in doubleword ",
                "element 1 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulouh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "72"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].hword[2\u00d7i+1])",
                "   src2 := EXTZ(VSR[VRB+32].hword[2\u00d7i+1])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmulouw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "136"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].word[2\u00d7i+1])",
                "   src2 := EXTZ(VSR[VRB+32].word[2\u00d7i+1])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Unsigned Word Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmuluwm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "137"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 \u00d7 src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                " "
            ]
        },
        {
            "description": "Vector Multiply-Add Floating-Point",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmaddfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRC",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "46"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   src3 := VSR[VRC+32].word[i]",
                "   result := bfp32_MULTIPLY_ADD(src1,src3,src2)",
                "   VSR[VRT+32].word[i] := result",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                " "
            ]
        },
        {
            "description": "Vector Multiply-High-Add Signed Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmhaddshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "32"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "   src3 := EXTS(VSR[VRC+32].hword[i])",
                "",
                "   result := ((src1 \u00d7 src2)) &gt;&gt; 15) + src3 ",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(result)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply-High-Round-Add Signed Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmhraddshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "33"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "   src3 := EXTS(VSR[VRC+32].hword[i])",
                "",
                "   result := (((src1 \u00d7 src2) + 0x0000_4000) &gt;&gt; 15) + src3",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(result)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Low-Add Unsigned Halfword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmladduhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "34"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "   src3 := EXTZ(VSR[VRC+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := CHOP16((src1 \u00d7 src2) + src3)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Multiply-Sum & write Carry-out Unsigned Doubleword",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsumcud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "23"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTZ(VSR[VRC+32])",
                "do i = 0 to 1",
                "   src1  := EXTZ(VSR[VRA+32].dword[i])",
                "   src2  := EXTZ(VSR[VRB+32].dword[i])",
                "   temp := temp + (src1 \u00d7 src2)",
                "end",
                "",
                "VSR[VRT+32] := CHOP128(temp &gt;&gt; 128)"
            ],
            "body": [
                "Let prod0 be the quadword product of the unsigned ",
                "integer values in doubleword element 0 of VSR[VRA+32] ",
                "and doubleword element 0 of VSR[VRB+32]. ",
                "Let prod1 be the quadword product of the unsigned ",
                "integer values in doubleword element 1 of VSR[VRA+32] ",
                "and doubleword element 1 of VSR[VRB+32]. ",
                "The carry out of the low-order 128 bits of the sum of ",
                "prod0, prod1, and the unsigned integer value in ",
                "VSR[VRC+32] is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-Sum Mixed Byte Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsummbm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "37"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRC+32].word[i])",
                "   do j = 0 to 3",
                "      src1 := EXTS(VSR[VRA+32].word[i].byte[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].byte[j])",
                "      temp := temp + (src1 \u00d7 src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Signed Halfword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsumshm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "40"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTS(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTS(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + (src1 \u00d7 src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Signed Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsumshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "41"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTS(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTS(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + (src1 \u00d7 src2)",
                "   end",
                "   VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Byte Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsumubm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "36"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRC+32].word[i])",
                "   do j = 0 to 3",
                "      src1 := EXTZ(VSR[VRA+32].word[i].byte[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].byte[j])",
                "      temp := temp + (src1 \u00d7 src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Doubleword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsumudm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "35"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTZ(VSR[VRC+32])",
                "do i = 0 to 1",
                "   src1  := EXTZ(VSR[VRA+32].dword[i])",
                "   src2  := EXTZ(VSR[VRB+32].dword[i])",
                "   temp := temp + (src1 \u00d7 src2)",
                "end",
                "VSR[VRT+32] := CHOP128(temp)"
            ],
            "body": [
                "Let prod0 be the product of the unsigned integer values ",
                "in doubleword element 0 of VSR[VRA+32] and ",
                "doubleword element 0 of VSR[VRB+32]. ",
                "Let prod1 be the product of the unsigned integer values ",
                "in doubleword element 1 of VSR[VRA+32] and ",
                "doubleword element 1 of VSR[VRB+32]. ",
                "The low-order 128 bits of the sum of prod0, prod1, and ",
                "the unsigned integer value in VSR[VRC+32] are placed ",
                "into VSR[VRT+32].",
                "  "
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Halfword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsumuhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "38"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTZ(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + (src1 \u00d7 src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmsumuhs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "39"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTZ(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + src1 \u00d7 src2",
                "   end",
                "   VSR[VRT+32].word[i] := ui32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-by-10 & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmul10cuq",
                    "operands": [
                        "VRT",
                        "VRA"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "prod := (src &lt;&lt; 3) + (src &lt;&lt; 1)",
                "VSR[VRT+32] := CHOP128(prod &gt;&gt; 128)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "The product of src multiplied by the value 10 is shifted ",
                "right by 128 bits. The rightmost 128 bits of the shifted ",
                "result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-by-10 Extended & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmul10ecuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "65"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "cin  := EXTZ(VSR[VRB+32].bit[124:127])",
                "prod := (src &lt;&lt; 3) + (src &lt;&lt; 1) + cin",
                "VSR[VRT+32] := CHOP128(prod&gt;&gt;128)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "Let cin be the unsigned packed decimal value in bits ",
                "124:127 of VSR[VRA+32]. Values of cin greater than 9 ",
                "are undefined.",
                "The sum of cin and the product of src multiplied by the ",
                "value 10 is shifted right by 128 bits. The rightmost 128 ",
                "bits of the shifted result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-by-10 Extended Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmul10euq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "577"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "cin  := EXTZ(VSR[VRB+32].bit[124:127])",
                "prod := (src &lt;&lt; 3) + (src &lt;&lt; 1) + cin",
                "VSR[VRT+32] := CHOP128(prod)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "Let cin be the unsigned packed decimal value in bits ",
                "124:127 of VSR[VRB+32]. Values of cin greater than 9 ",
                "are undefined.",
                "The rightmost 128 bits of the sum of cin and the ",
                "product of src multiplied by the value 10 are placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-by-10 Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vmul10uq",
                    "operands": [
                        "VRT",
                        "VRA"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "513"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "prod := (src &lt;&lt; 3) + (src &lt;&lt; 1)",
                "VSR[VRT+32] := CHOP128(prod)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "The rightmost 128 bits of the product of src multiplied ",
                "by the value 10 are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Negate Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vnegd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "7"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32]dword[i] := CHOP64(~src + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Negate Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vnegw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "6"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(~src + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Negative Multiply-Subtract Floating-Point",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vnmsubfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRC",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "47"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   src3 := VSR[VRC+32].word[i]",
                "   result := bfp32_NEGATIVE_MULTIPLY_SUBTRACT(src1,src3,src2)",
                "   VSR[VRT+32].word[i] := result",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Pixel",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkpx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "782"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i].bit[0]     := vsrc.word[i].bit[7]",
                "   VSR[VRT+32].hword[i].bit[1:5]   := vsrc.word[i].bit[8:12]",
                "   VSR[VRT+32].hword[i].bit[6:10]  := vsrc.word[i].bit[16:20]",
                "   VSR[VRT+32].hword[i].bit[11:15] := vsrc.word[i].bit[24:28]",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Pack Signed Doubleword Signed Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpksdss",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1486"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := si32_CLAMP(EXTS(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := si32_CLAMP(EXTS(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := si32_CLAMP(EXTS(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := si32_CLAMP(EXTS(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Doubleword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpksdus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1358"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := ui32_CLAMP(EXTS(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := ui32_CLAMP(EXTS(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := ui32_CLAMP(EXTS(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := ui32_CLAMP(EXTS(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Halfword Signed Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkshss",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "398"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := si8_CLAMP(EXTS(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Halfword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkshus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "270"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := ui8_CLAMP(EXTS(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Word Signed Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkswss",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "462"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(EXTS(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Word Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkswus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "334"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := ui16_CLAMP(EXTS(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Doubleword Unsigned Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkudum",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1102"
                }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].dword[0].bit[32:63]",
                "VSR[VRT+32].word[1] := VSR[VRA+32].dword[1].bit[32:63]",
                "VSR[VRT+32].word[2] := VSR[VRB+32].dword[0].bit[32:63]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].dword[1].bit[32:63]"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Doubleword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkudus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1230"
                }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := ui32_CLAMP(EXTZ(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := ui32_CLAMP(EXTZ(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := ui32_CLAMP(EXTZ(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := ui32_CLAMP(EXTZ(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Halfword Unsigned Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkuhum",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "14"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := vsrc.hword[i].bit[8:15]",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Halfword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkuhus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "142"
                }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := ui8_CLAMP(EXTZ(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Word Unsigned Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkuwum",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "78"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := vsrc.word[i].bit[16:31]",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Word Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpkuwus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "206"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := ui16_CLAMP(EXTZ(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Parallel Bits Deposit Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpdepd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1485"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   VSR[VRT+32].dword[i] := 0",
                "   m := 0",
                "   k := 0",
                "   do while(m &lt; 64)",
                "      if VSR[VRB+32].dword[i].bit[63-m]=1 then do",
                "         result := VSR[VRA+32].dword[i].bit[63-k]",
                "         VSR[VRT+32].dword[i].bit[63-m] := result",
                "         k := k + 1",
                "      end",
                "      m := m + 1",
                "   end",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Parallel Bits Extract Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpextd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1421"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   result := 0",
                "   m := 0",
                "   k := 0",
                "   do while(m &lt; 64)",
                "      if VSR[VRB+32].dword[i].bit[63-m]=1 then do",
                "         result.bit[63-k] := VSR[VRA+32].dword[i].bit[63-m]",
                "         k := k + 1",
                "      end",
                "      m := m + 1",
                "   end",
                "   VSR[VRT+32].dword[i] := result",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Parity Byte Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vprtybd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "9"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   s := 0",
                "   do j = 0 to 7",
                "       s := s ^ VSR[VRB+32].dword[i].byte[j].bit[7]",
                "   end",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTZ(s))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following"
            ]
        },
        {
            "description": "Vector Parity Byte Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vprtybq",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "10"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "s := 0",
                "do j = 0 to 15",
                "   s := s ^ VSR[VRB+32].byte[j].bit[7]",
                "end",
                "VSR[VRT+32] := CHOP128(EXTZ(s))"
            ],
            "body": [
                "If the sum of the least significant bit in each byte ",
                "element of VSR[VRB+32] is odd, the value 1 is placed ",
                "into VSR[VRT+32]; otherwise the value 0 is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Parity Byte Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vprtybw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "8"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1538"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   s := 0",
                "   do j = 0 to 3",
                "      s := s ^ VSR[VRB+32].word[i].byte[j].bit[7]",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(EXTZ(s))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following"
            ]
        },
        {
            "description": "Vector Permute",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vperm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "43"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   index := VSR[VRC+32].byte[i].bit[3:7]",
                "   VSR[VRT+32].byte[i] := src.byte[index]",
                "end"
            ],
            "body": [
                "Let the source vector be the concatenation of the ",
                "contents of VSR[VRA+32] followed by the contents of ",
                "VSR[VRB+32]. ",
                "For each integer value i from 0 to 15, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Permute & Exclusive-OR",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpermxor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "45"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   indexA := VSR[VRC+32].byte[i].bit[0:3]",
                "   indexB := VSR[VRC+32].byte[i].bit[4:7]",
                "   src1   := VSR[VRA+32].byte[indexA]",
                "   src2   := VSR[VRB+32].byte[indexB]",
                "   VSR[VRT+32].byte[i] := src1 ^ src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Permute Right-indexed",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpermr",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "59"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   index := VSR[VRC+32].byte[i].bit[3:7]",
                "   VSR[VRT+32].byte[i] := src.byte[31-index]",
                "end"
            ],
            "body": [
                "Let the source vector be the concatenation of the ",
                "contents of VSR[VRA+32] followed by the contents of ",
                "VSR[VRB+32]. ",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1032"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   prod[i].bit[0:14] := 0",
                "   srcA := VSR[VRA+32].byte[i]",
                "   srcB := VSR[VRB+32].byte[i]",
                "   do j = 0 to 7",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] &amp; srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 8 to 14",
                "      do k = j-7 to 7",
                "         gbit := (srcA.bit[k] &amp; srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := 0b0 || (prod[2\u00d7i] ^ prod[2\u00d7i+1])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1224"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   prod[i].bit[0:126] := 0",
                "   srcA := VSR[VRA+32].doubleword[i]",
                "   srcB := VSR[VRB+32].doubleword[i]",
                "   do j = 0 to 63",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] &amp; srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 64 to 126",
                "      do k = j-63 to 63",
                "         gbit := (srcA.bit[k] &amp; srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "VSR[VRT+32] := 0b0 || (prod[0] ^ prod[1])"
            ],
            "body": [
                "Let prod[0] be the 127-bit result of a binary polynomial ",
                "multiplication of the contents of doubleword element 0 ",
                "of VSR[VRA+32] and the contents of doubleword ",
                "element 0 of VSR[VRB+32].",
                "Let prod[1] be the 127-bit result of a binary polynomial ",
                "multiplication of the contents of doubleword element 1 ",
                "of VSR[VRA+32] and the contents of doubleword ",
                "element 1 of VSR[VRB+32].",
                "The exclusive-OR of prod[0] and prod[1] is placed in ",
                "bits 1:127 of VSR[VRT+32]. Bit 0 of VSR[VRT+32] is set to ",
                "0."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1096"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   prod.bit[0:30] := 0",
                "   srcA := VSR[VRA+32].halfword[i]",
                "   srcB := VSR[VRB+32].halfword[i]",
                "   do j = 0 to 15",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] &amp; srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 16 to 30",
                "      do k = j-15 to 15",
                "         gbit := (srcA.bit[k] &amp; srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "VSR[VRT+32].word[0] := 0b0 || (prod[0] ^ prod[1])",
                "VSR[VRT+32].word[1] := 0b0 || (prod[2] ^ prod[3])",
                "VSR[VRT+32].word[2] := 0b0 || (prod[4] ^ prod[5])",
                "VSR[VRT+32].word[3] := 0b0 || (prod[6] ^ prod[7])"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1160"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   prod[i].bit[0:62] := 0",
                "   srcA := VSR[VRA+32].word[i]",
                "   srcB := VSR[VRB+32].word[i]",
                "   do j = 0 to 31",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] &amp; srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 32 to 62",
                "      do k = j-31 to 31",
                "         gbit := (srcA.bit[k] &amp; srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "VSR[VRT+32].dword[0] := 0b0 || (prod[0] ^ prod[1])",
                "VSR[VRT+32].dword[1] := 0b0 || (prod[2] ^ prod[3])"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Population Count Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpopcntb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1795"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   n := 0",
                "   do j = 0 to 7",
                "      n := n + VSR[VRB+32].byte[i].bit[j]",
                "   end",
                "   VSR[VRT+32].byte[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Population Count Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpopcntd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1987"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   n := 0",
                "   do j = 0 to 63",
                "      n := n + VSR[VRB+32].dword[i].bit[j]",
                "   end",
                "   VSR[VRT+32].dword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Population Count Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpopcnth",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1859"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   n := 0",
                "   do j = 0 to 15",
                "      n := n + VSR[VRB+32].hword[i].bit[j]",
                "   end",
                "   VSR[VRT+32].hword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Population Count Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vpopcntw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1923"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   n := 0",
                "   do j = 0 to 31",
                "      n := n + VSR[VRB+32].word[i].bit[j]",
                "   end",
                "   VSR[VRT+32].word[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Reciprocal Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "266"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_RECIPROCAL_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Unless the single-precision floating-point result of ",
                "computing the reciprocal of a value would be a zero, ",
                "an infinity, or a QNaN, the estimate has a relative error ",
                "in precision no greater than one part in 4096.",
                "Note that results may vary between implementations, ",
                "and between different executions on the same ",
                "implementation.",
                "The result for various special cases of the source ",
                "value is given below.  "
            ]
        },
        {
            "description": "Vector Reciprocal Square Root Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrsqrtefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "330"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_RECIPROCAL_SQRT_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Let x be any single-precision floating-point value. ",
                "Unless the single-precision floating-point result of ",
                "computing the reciprocal of the square root of x would ",
                "be a zero, an infinity, or a QNaN, the estimate has a ",
                "relative error in precision no greater than one part in ",
                "4096.",
                "Note that results may vary between implementations, ",
                "and between different executions on the same ",
                "implementation.",
                "The result for various special cases of the source ",
                "value is given below.  "
            ]
        },
        {
            "description": "Vector Rotate Left Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "4"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src := VSR[VRA+32].byte[i]",
                "   sh  := VSR[VRB+32].byte[i].bit[5:7]",
                "",
                "   VSR[VRT+32].byte[i] := src &lt;&lt;&lt; sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrld",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "196"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src := VSR[VRA+32].dword[i]",
                "   sh  := VSR[VRB+32].dword[i].bit[58:63]",
                "",
                "   VSR[VRT+32].dword[i] := src &lt;&lt;&lt; sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Doubleword then AND with Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrldnm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "453"
                }
            ],
            "code": [],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Doubleword then Mask Insert",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrldmi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "197"
                }
            ],
            "code": [],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "68"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src := VSR[VRA+32].hword[i]",
                "   sh  := VSR[VRB+32].hword[i].bit[12:15]",
                "",
                "   VSR[VRT+32].hword[i] := src &lt;&lt;&lt; sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "5"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := ROTL128(VSR[VRA+32], n)"
            ],
            "body": [
                "Let SH be the contents of bits 57:63 of VSR[VRB+32].",
                "Let src1 be the contents of VSR[VRA+32].",
                "src1 is rotated left by SH bits. Bits shifted out on the left ",
                "are shifted in on the right to replace vacated bits."
            ]
        },
        {
            "description": "Vector Rotate Left Quadword then AND with Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlqnm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "325"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "b := VSR[VRB+32].bit[41:47]",
                "e := VSR[VRB+32].bit[49:55]",
                "n := VSR[VRB+32].bit[57:63]",
                "r := ROTL128(VSR[VRA+32],n)",
                "m := MASK128(b, e)",
                "VSR[VRT+32] := r &amp; m"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "Let mb be the contents of bits 41:47 of src2.",
                "src1 is rotated left sh bits.",
                "A mask is generated having 1-bits from bit mb through ",
                "bit me and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Rotate Left Quadword then Mask Insert",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlqmi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "69"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := VSR[VRB+32].bit[41:47]",
                "e := VSR[VRB+32].bit[49:55]",
                "n := VSR[VRB+32].bit[57:63]",
                "r := ROTL128(VSR[VRA+32],n)",
                "m := MASK128(b, e)",
                "VSR[VRT+32] := (r &amp; m) | (VSR[VRT+32] &amp; ~m)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "Let mb be the contents of bits 41:47 of src2.",
                "src1 is rotated left sh bits.",
                "A mask is generated having 1-bits from bit mb through ",
                "bit me and 0-bits elsewhere.",
                "The rotated data are inserted into src3 under control of ",
                "the generated mask.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Rotate Left Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "132"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRA+32].word[i]",
                "   sh  := VSR[VRB+32].word[i].bit[27:31]",
                "",
                "   VSR[VRT+32].word[i] := src &lt;&lt;&lt; sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Word then AND with Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlwnm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "389"
                }
            ],
            "code": [],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Word then Mask Insert",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrlwmi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "133"
                }
            ],
            "code": [],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer Nearest",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrfin",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "522"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_NEAR(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                " ",
                " "
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer toward +Infinity",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrfip",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "650"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_CEIL(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer toward -Infinity",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrfim",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "714"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_FLOOR(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer toward Zero",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vrfiz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "586"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_TRUNC(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector SHA-256 Sigma Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vshasigmaw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "ST",
                        "SIX"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "ST",
                    "size": "1"
                },
                {
                    "name": "SIX",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1666"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRA+32].word[i]",
                "",
                "   if ST=0 &amp; SIX.bit[i]=0 then  // SHA-256 s0 function",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt;  7) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt; 18) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;  3)",
                "",
                "   if ST=0 &amp; SIX.bit[i]=1 then  // SHA-256 s1 function",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt; 17) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt; 19) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt; 10)",
                "",
                "   if ST=1 &amp; SIX.bit[i]=0 then  // SHA-256 S0 function",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt;  2) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt; 13) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt; 22)",
                "",
                "   if ST=1 &amp; SIX.bit[i]=1 then  // SHA-256 S1 function",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt;  6) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt; 11) ^",
                "      VSR[VRT+32].word[i] := (src &gt;&gt;&gt; 25)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector SHA-512 Sigma Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vshasigmad",
                    "operands": [
                        "VRT",
                        "VRA",
                        "ST",
                        "SIX"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "ST",
                    "size": "1"
                },
                {
                    "name": "SIX",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1730"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src := VSR[VRA+32].dword[i]",
                "",
                "   if ST=0 &amp; SIX.bit[2\u00d7i]=0 then  // SHA-512 s0 function",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt;  1) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt;  8) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt; 7)",
                "",
                "   if ST=0 &amp; SIX.bit[2\u00d7i]=1 then  // SHA-512 s1 function",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 19) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 61) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt; 6)",
                "",
                "   if ST=1 &amp; SIX.bit[2\u00d7i]=0 then  // SHA-512 S0 function",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 28) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 34) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 39)",
                "",
                "   if ST=1 &amp; SIX.bit[2\u00d7i]=1  then  // SHA-512 S1 function",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 14) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 18) ^",
                "      VSR[VRT+32].dword[i] := (src &gt;&gt;&gt; 41)",
                "end   "
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "Bits 1 and 3 of SIX are reserved."
            ]
        },
        {
            "description": "Vector Select",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsel",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "42"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32]",
                "mask := VSR[VRC+32]",
                "",
                "VSR[VRT+32] := (src1 &amp; ~mask) | (src2 &amp; mask)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "The value, (src1&amp;~mask)|(src2&amp;mask), is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Left",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsl",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "452"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[125:127]",
                "",
                "t := 1",
                "do i = 0 to 14",
                "   t := t &amp; (VSR[VRB+32].byte[i].bit[5:7] = sh)",
                "end",
                "if t=1 then",
                "   VSR[VRT+32] := VSR[VRA+32] &lt;&lt; sh",
                "else",
                "   VSR[VRT+32] := UNDEFINED"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted left by the ",
                "number of bits specified in bits 125:127 of VSR[VRB+32]. ",
                "The result is place into VSR[VRT+32], except if, for any ",
                "byte element in VSR[VRB+32], the low-order 3 bits are ",
                "not equal to the shift amount, then VSR[VRT+32] is ",
                "undefined."
            ]
        },
        {
            "description": "Vector Shift Left Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vslb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "260"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := src1 &lt;&lt; src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Shift Left Double by Bit Immediate",
            "form": "VN-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsldbi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "SH"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "0"
                },
                {
                    "name": "SH",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "22"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32]   := vsrc.bit[SH:SH+127]"
            ],
            "body": [
                "Let vsrc be the contents of VSR[VRA+32] concatenated ",
                "with the contents of VSR[VRB+32].",
                "The contents of bits SH:SH+127 of vsrc are placed into ",
                "VSR[VRT+32].",
                "SH can be any integer value between 0 and 7."
            ]
        },
        {
            "description": "Vector Shift Left Double by Octet Immediate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsldoi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "SHB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "SHB",
                    "size": "4"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "44"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32] := src.byte[SHB:SHB+15]"
            ],
            "body": [
                "Let vsrc be the contents of VSR[VRA+32] concatenated ",
                "with the contents of VSR[VRB+32].",
                "Bytes SHB:SHB+15 of vsrc are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Left Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsld",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1476"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "",
                "   VSR[VRT+32].dword[i] := src1 &lt;&lt; src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Shift Left Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vslh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "324"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "   VSR[VRT+32].hword[i] := src1 &lt;&lt; src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Shift Left Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vslq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "261"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := VSR[VRA+32] &lt;&lt; VSR[VRB+32].bit[57:63]"
            ],
            "body": [
                "Let n be the contents of bits 57:63 of VSR[VRB+32].",
                "Let src1 be the contents of VSR[VRA+32].",
                "Let src2 be the contents of VSR[VRB+32].",
                "src1 is shifted left by the number of bits specified in the ",
                "low-order 7 bits of src2.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Left Variable",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vslv",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1860"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable_Interrupt()",
                "",
                "vsrc.byte[0:15] := VSR[VRA+32]",
                "vsrc.byte[16]   := 0x00",
                "",
                "do i = 0 to 15",
                "   sh := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := src.byte[i:i+1].bit[sh:sh+7]",
                "end"
            ],
            "body": []
        },
        {
            "description": "Vector Shift Left Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vslw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "388"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i].bit[27:31]",
                "",
                "   VSR[VRT+32].word[i] := src1 &lt;&lt; src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Shift Left by Octet",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vslo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1036"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[121:124] &lt;&lt; 3",
                "",
                "VSR[VRT+32] := VSR[VRA+32] &lt;&lt; shb"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted left by the ",
                "number of bytes specified in bits 121:124 of ",
                "VSR[VRB+32]. ",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Right",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsr",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "708"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "sh := VSR[VRB+32].bit[125:127]",
                "",
                "t := 1",
                "do i = 0 to 14",
                "   t := t &amp; (VSR[VRB+32].byte[i].bit[5:7]=sh)",
                "end",
                "if t=1 then",
                "   VSR[VRT+32] := CHOP128(EXTZ(VSR[VRA+32]) &gt;&gt; sh)",
                "else",
                "   VSR[VRT+32] := UNDEFINED"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted right by the ",
                "number of bits specified in bits 125:127 of VSR[VRB+32]. ",
                "The result is place into VSR[VRT+32], except if, for any ",
                "byte element in VSR[VRB+32], the low-order 3 bits are ",
                "not equal to the shift amount, then VSR[VRT+32] is ",
                "undefined."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrab",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "772"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := CHOP8(EXTS(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrad",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "964"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTS(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrah",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "836"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "   VSR[VRT+32].hword[i] := CHOP16(EXTS(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsraq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "773"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := CHOP128(EXTS(src1) &gt;&gt; src2)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "src1 is shifted right by the number of bits specified in ",
                "the low-order 7 bits of src2.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsraw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "900"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i].bit[27:31]",
                "   VSR[VRT+32].word[i] := CHOP32(EXTS(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "516"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := CHOP8(EXTZ(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Double by Bit Immediate",
            "form": "VN-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrdbi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "SH"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "2",
                    "value": "1"
                },
                {
                    "name": "SH",
                    "size": "3"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "22"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32]   := vsrc.bit[128-SH:255-SH]"
            ],
            "body": [
                "Let vsrc be the contents of VSR[VRA+32] concatenated ",
                "with the contents of VSR[VRB+32].",
                "The contents of bits 128-SH:255-SH of vsrc are placed ",
                "into VSR[VRT+32].",
                "SH can be any integer value between 0 and 7."
            ]
        },
        {
            "description": "Vector Shift Right Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1732"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTZ(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "580"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "   VSR[VRT+32].hword[i] := CHOP16(EXTZ(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "517"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := CHOP128(EXTZ(src1) &gt;&gt; src2)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "src1 is shifted right by the number of bits specified in ",
                "the low-order 7 bits of src2.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Right Variable",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrv",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1796"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable_Interrupt()",
                "",
                "vsrc.byte[0]   := 0x00",
                "vsrc.byte[1:16] := VSR[VRA+32]",
                "",
                "do i = 0 to 15",
                "   sh := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := src.byte[i:i+1].bit[8-sh:15-sh]",
                "end"
            ],
            "body": []
        },
        {
            "description": "Vector Shift Right Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsrw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "644"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i].bit[27:31]",
                "   VSR[VRT+32].word[i] := CHOP32(EXTZ(src1) &gt;&gt; src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Shift Right by Octet",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsro",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1100"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[121:124] &lt;&lt; 3",
                "",
                "VSR[VRT+32] := VSR[VRA+32] &gt;&gt; shb"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted right by the ",
                "number of bytes specified in bits 121:124 of ",
                "VSR[VRB+32]. ",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Splat Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vspltb",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "524"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b000",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := VSR[VRB+32].bit[b:b+7]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Splat Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsplth",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "UIM",
                    "size": "3"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "588"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b0000",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := VSR[VRB+32].bit[b:b+15]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Splat Immediate Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vspltisb",
                    "operands": [
                        "VRT",
                        "SIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "SIM",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "780"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := EXTS8(SIM, 8)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Splat Immediate Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vspltish",
                    "operands": [
                        "VRT",
                        "SIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "SIM",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "844"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := EXTS16(SIM, 16)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Splat Immediate Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vspltisw",
                    "operands": [
                        "VRT",
                        "SIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "SIM",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "908"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i] := EXTS32(SIM, 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Splat Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vspltw",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "UIM",
                    "size": "2"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "652"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b00000",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i] := VSR[VRB+32].bit[b:b+31]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector String Isolate Byte Left-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vstribl",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "mnemonic": "vstribl.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "0"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "13"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 15",
                "   null_found := (VSR[VRB+32].byte[i]=0)",
                "   VSR[VRT+32].byte[i] := VSR[VRB+32].byte[i]",
                "end",
                "",
                "do j = i to 15",
                "   VSR[VRT+32].byte[j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From left-to-right, the contents of each byte element of ",
                "VSR[VRB+32] are placed into the corresponding byte ",
                "element in VSR[VRT+32]. If a byte element in ",
                "VSR[VRB+32] is found to contain 0, the corresponding ",
                "byte element and all byte elements to the right of that ",
                "byte element in VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector String Isolate Byte Right-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vstribr",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "mnemonic": "vstribr.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "13"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 15",
                "   null_found := (VSR[VRB+32].byte[15-i]=0)",
                "   VSR[VRT+32].byte[15-i] := VSR[VRB+32].byte[15-i]",
                "end",
                "",
                "do j = i to 15",
                "   VSR[VRT+32].byte[15-j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From right-to-left, the contents of each byte element of ",
                "VSR[VRB+32] are placed into the corresponding byte ",
                "element in VSR[VRT+32]. If a byte element in ",
                "VSR[VRB+32] is found to contain 0, the corresponding ",
                "byte element and all byte elements to the left of that ",
                "byte element in VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector String Isolate Halfword Left-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vstrihl",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "mnemonic": "vstrihl.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "2"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "13"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 7",
                "   null_found := (VSR[VRB+32].hword[i] = 0)",
                "   VSR[VRT+32].hword[i] := VSR[VRB+32].hword[i]",
                "end",
                "",
                "do j = i to 7",
                "   VSR[VRT+32].hword[j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From left-to-right, the contents of each halfword ",
                "element of VSR[VRB+32] are placed into the ",
                "corresponding halfword element in VSR[VRT+32]. If a ",
                "halfword element in VSR[VRB+32] is found to contain 0, ",
                "the corresponding halfword element and all halfword ",
                "elements to the right of that halfword element in ",
                "VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector String Isolate Halfword Right-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vstrihr",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "mnemonic": "vstrihr.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "5",
                    "value": "3"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "13"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 7",
                "   null_found := (VSR[VRB+32].hword[7-i] = 0)",
                "   VSR[VRT+32].hword[7-i] := VSR[VRB+32].hword[7-i]",
                "end",
                "",
                "do j = i to 7",
                "   VSR[VRT+32].hword[7-j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From right-to-left, the contents of each halfword ",
                "element of VSR[VRB+32] are placed into the ",
                "corresponding halfword element in VSR[VRT+32]. If a ",
                "halfword element in VSR[VRB+32] is found to contain 0, ",
                "the corresponding halfword element and all halfword ",
                "elements to the left of that halfword element in ",
                "VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector Subtract & Write Carry-Out Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubcuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1408"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(:=VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := EXTZ32((src1+src2+1) &gt;&gt; 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubcuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1344"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128((src1 + src2 + 1) &gt;&gt; 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1, the one\u2019s ",
                "complement of src2, and the value 1 is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Extended & write Carry-out Unsigned Quadword",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubecuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "63"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128((src1 + src2 + cin) &gt;&gt; 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1, the one\u2019s ",
                "complement of src2, and cin are placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Extended Unsigned Quadword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubeuqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "62"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + cin)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1, the one\u2019s ",
                "complement of src2, and cin are placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "74"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_SUBTRACT(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract Signed Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubsbs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1792"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTS(VSR[VRA+32].byte[i])",
                "   src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "   VSR[VRT+32].byte[i] := si8_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Subtract Signed Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1856"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Subtract Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubsws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1920"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := si32_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Byte Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsububm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1024"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "   VSR[VRT+32].byte[i] := CHOP8(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsububs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1536"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "   VSR[VRT+32].byte[i] := ui8_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Doubleword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubudm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1216"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Halfword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubuhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1088"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubuhs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1600"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "   VSR[VRT+32].hword[i] := ui16_CLAMP(src1 + ~src2 + 1)",
                "   VSCR.SAT := VSCR.SAT | sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Quadword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubuqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1280"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + 1)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1, the one\u2019s ",
                "complement of src2, and the value 1 are placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Word Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubuwm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1152"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "   VSR[VRT+32].word[i] := CHOP32(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsubuws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1664"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "   VSR[VRT+32].word[i] := ui32_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Sum across Half Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsum2sws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1672"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   temp := EXTS(VSR[VRB+32].dword[i].word[1])",
                "   do j = 0 to 1",
                "      temp := temp + EXTS(VSR[VRA+32].dword[i].word[j])",
                "   end",
                "   VSR[VRT+32].dword[i].word[0] := 0x0000_0000",
                "   VSR[VRT+32].dword[i].word[1] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "Word elements 0 and 2 of VSR[VRT+32] are set to 0.",
                "The sum of the signed integer values in word elements ",
                "0 and 1 in VSR[VRA+32] is added to the signed integer ",
                "value in word element 1 of VSR[VRB+32]. ",
                "The low-order 32 bits of the result are placed into word ",
                "element 1 of VSR[VRT+32]. ",
                "The sum of the signed integer values in word elements ",
                "2 and 3 in VSR[VRA+32] is added to the signed integer ",
                "value in word element 3 of VSR[VRB+32].",
                "The low-order 32 bits of the result are placed into word ",
                "element 3 of VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Sum across Quarter Signed Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsum4sbs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1800"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRB+32].word[i])",
                "   do j = 0 to 3",
                "      temp := temp + EXTS(VSR[VRA+32].word[i].byte[j])",
                "   end",
                "   VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Sum across Quarter Signed Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsum4shs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1608"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRB+32].word[i])",
                "   do j = 0 to 1",
                "      temp := temp + EXTS(VSR[VRA+32].word[i].hword[j])",
                "   end",
                "   VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Sum across Quarter Unsigned Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsum4ubs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1544"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRB+32].word[i])",
                "   do j = 0 to 3",
                "      temp := temp + EXTZ(VSR[VRA+32].word[i].byte[j])",
                "   end",
                "   VSR[VRT+32].word[i] := ui32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Sum across Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vsumsws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1928"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTS(VSR[VRB+32].word[3])",
                "do i = 0 to 3",
                "   temp := temp + EXTS(VSR[VRA+32].word[i])",
                "end",
                "VSR[VRT+32].word[0] := 0x0000_0000",
                "VSR[VRT+32].word[1] := 0x0000_0000",
                "VSR[VRT+32].word[2] := 0x0000_0000",
                "VSR[VRT+32].word[3] := si32_CLAMP(temp)",
                "VSCR.SAT := sat_flag"
            ],
            "body": [
                "The sum of the signed integer values in the four word ",
                "elements of VSR[VRA+32] is added to the signed integer ",
                "value in the word element 3 of VSR[VRB+32].",
                "The low-order 32 bits of the result are placed into word ",
                "element 3 of VSR[VRT+32].",
                "Word elements 0 to 2 of VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector Unpack High Pixel",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupkhpx",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "846"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].hword[i]",
                "",
                "   VSR[VRT+32].word[i].byte[0] := EXTS8(src.bit[0])",
                "   VSR[VRT+32].word[i].byte[1] := EXTZ8(src.bit[1:5])",
                "   VSR[VRT+32].word[i].byte[2] := EXTZ8(src.bit[6:10])",
                "   VSR[VRT+32].word[i].byte[3] := EXTZ8(src.bit[11:15])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Unpack High Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupkhsb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "526"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := EXTS16(VSR[VRB+32].byte[i])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Unpack High Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupkhsh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "590"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := EXTS32(VSR[VRB+32].hword[0])",
                "VSR[VRT+32].word[1] := EXTS32(VSR[VRB+32].hword[1])",
                "VSR[VRT+32].word[2] := EXTS32(VSR[VRB+32].hword[2])",
                "VSR[VRT+32].word[3] := EXTS32(VSR[VRB+32].hword[3])"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Unpack High Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupkhsw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1614"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].dword[0] := EXTS64(VSR[VRB+32].word[0])",
                "VSR[VRT+32].dword[1] := EXTS64(VSR[VRB+32].word[1])"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Unpack Low Pixel",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupklpx",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "974"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].hword[i+4]",
                "",
                "   VSR[VRT+32].word[i].byte[0] := EXTS8(src.bit[0])",
                "   VSR[VRT+32].word[i].byte[1] := EXTZ8(src.bit[1:5])",
                "   VSR[VRT+32].word[i].byte[2] := EXTZ8(src.bit[6:10])",
                "   VSR[VRT+32].word[i].byte[3] := EXTZ8(src.bit[11:15])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Vector Unpack Low Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupklsb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "654"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := EXTS16(VSR[VRB+32].byte[i+8])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Unpack Low Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupklsh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "718"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := EXTS32(VSR[VRB+32].hword[4])",
                "VSR[VRT+32].word[1] := EXTS32(VSR[VRB+32].hword[5])",
                "VSR[VRT+32].word[2] := EXTS32(VSR[VRB+32].hword[6])",
                "VSR[VRT+32].word[3] := EXTS32(VSR[VRB+32].hword[7])"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Unpack Low Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "vupklsw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "4"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "11",
                    "value": "1742"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].dword[0] := EXTS64(VSR[VRB+32].word[2])",
                "VSR[VRT+32].dword[1] := EXTS64(VSR[VRB+32].word[3])"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Wait",
            "form": "X-form",
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "mnemonic": "wait",
                    "operands": [
                        "WC",
                        "PL"
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "??",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "WC",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "PL",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "30"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                " ",
                "The wait instruction causes instruction fetching and ",
                "execution to be suspended under certain conditions, ",
                "depending on the values of the WC and PL fields.  ",
                "Instruction fetching and execution are resumed when ",
                "the events specified by the WC field occur or in the rare ",
                "case of an implementation-dependent event.",
                "The values of the WC field are as follows.",
                "0Resume instruction fetching and execution ",
                "when an exception or event-based branch ",
                "exception occurs.",
                "1Resume instruction fetching and execution ",
                "when an exception or event-based branch ",
                "exception occurs, or when a reservation made ",
                "by the processor does not exist (see Section ",
                "1.7.2.1).",
                "2Resume instruction fetching and execution ",
                "when an exception or event-based branch ",
                "exception occurs, or when the amount of time ",
                "specified by the PL field has passed.",
                "3Reserved.",
                "The values of the PL field are as follows.",
                "0b00A short wait time is specified.",
                "0b01:11Reserved.",
                "If WC=0, or if WC=1 and a reservation made by the ",
                "processor exists, or if WC=2 and a value for PL that is ",
                "not reserved is specified, the following applies.",
                "  ",
                "If WC=1 and a reservation made by the processor does ",
                "not exist, or if WC=2 and a reserved value of PL is ",
                "specified, the instruction is treated as a no-op.",
                "  ",
                "Examples of extended mnemonics for wait:",
                "Except in this section, references to \u201cwait\u201d in Books I-III ",
                "include all defined forms of wait unless otherwise ",
                "stated or obvious from context.",
                "  ",
                "  ",
                " ",
                " ",
                "",
                "  ",
                ""
            ]
        },
        {
            "description": "XOR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xor",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "mnemonic": "xor.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "31"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "316"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) ^ (RB)"
            ],
            "body": [
                "The contents of register RS are XORed with the con",
                "tents of register RB and the result is placed into register ",
                "RA."
            ]
        },
        {
            "description": "XOR Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xori",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "26"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) XOR (<sup>48</sup>0 || UI)",
                "xori   0,0,0"
            ],
            "body": [
                "The contents of register RS are XORed with 480||UI ",
                "and the result is placed into register RA.",
                "The executed form of a \u201cno-op\u201d (an instruction that ",
                "does nothing, but consumes execution resources nev",
                "ertheless) is:",
                "Example of extended mnemonics for XOR Immediate:",
                "  ",
                "  "
            ]
        },
        {
            "description": "XOR Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "mnemonic": "xoris",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "27"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) XOR (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "The contents of register RS are XORed with ",
                "320||UI||160 and the result is placed into register ",
                "RA."
            ]
        },
        {
            "description": "stop",
            "form": "XL-form",
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "mnemonic": "stop",
                    "operands": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "opcode",
                    "size": "6",
                    "value": "19"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "opcode",
                    "size": "10",
                    "value": "370"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "The thread is placed into power-saving mode and exe",
                "cution is stopped. ",
                "The power-saving level that is entered is determined by ",
                "the contents of the PSSCR (see Section 4.2.2). The ",
                "thread state that is maintained depends on the ",
                "power-saving level that is entered. The thread state ",
                "that is maintained at each power-saving level is imple",
                "mentation-dependent, subject to the restrictions speci",
                "fied in Section 4.3.2.MSR<sub>EE</sub>=0) or in the corresponding ",
                "interrupt handler (if MSR<sub>EE</sub>=1). ",
                "",
                "The thread remains in power-saving mode until either a ",
                "System Reset exception or certain other events occur. ",
                "The events that may cause exit from power-saving ",
                "mode are specified by PSSCR<sub>EC</sub>, LPCR<sub>PECE</sub>, and ",
                "SMFCTRL<sub>UDEE</sub>. If the event that causes the exit is a ",
                "System Reset, Machine Check, or Hypervisor Mainte",
                "nance exception, resource state that would be lost if ",
                "the exception occurred when the thread was not in ",
                "power-saving mode may be lost.",
                "This instruction should not be executed in ultravisor ",
                "state because that scenario may not be thoroughly ver",
                "ified.",
                "This instruction is privileged and context synchronizing.",
                "  ",
                "Before software executes the stop instruction, the ",
                "PSSCR is initialized. If the stop instruction is to be ",
                "used by the OS, the hypervisor initializes the fields that ",
                "are accessible only to the hypervisor before dispatch",
                "ing the OS. These fields include the SD, ESL, EC, and ",
                "PSLL fields. See the Programming Notes for these ",
                "fields in Section 4.2.2 for additional information. ",
                "If the stop instruction is to be executed by the hypervi",
                "sor when PSSCR<sub>EC</sub>=1, LPCR<sub>PECE</sub> and SMFCTR",
                "L<sub>UDEE</sub> must be set to the desired value (see Sections ",
                "2.2 and 3.4). Depending on the implementation and the ",
                "power-saving level to be entered, it may also be neces",
                "sary to save the state of certain resources and perform ",
                "synchronization procedures to ensure that all stores ",
                "have been performed with respect to other threads or ",
                "mechanisms that use the storage areas before execut",
                "ing the stop. See the the User\u2019s Manual for the imple",
                "mentation for details.",
                "Software must also specify the requested and maxi",
                "mum power-saving level limit fields (i.e RL and MTL ",
                "fields), and the Transition Rate (TR) field in the PSSCR ",
                "in order to bound the range of power-saving modes that ",
                "can be entered. If the value of the RL field is greater ",
                "than or equal to the value of the MTL field, the ",
                "power-saving level will not increase from the initial level ",
                "during power-saving mode. ",
                "After the thread has entered power-saving mode with ",
                "PSSCR<sub>EC</sub>=0, any exception may cause exit from ",
                "power-saving mode. When an exception occurs, ",
                "power-saving mode is exited either at the instruction ",
                "following the stop (if MSR<sub>EE</sub>=0) or in the corresponding ",
                "interrupt handler (if MSR<sub>EE</sub>=1). ",
                "After the thread has entered power-saving mode with ",
                "PSSCR<sub>EC</sub>=1, only the System Reset exception and the ",
                "exceptions enabled in LPCR<sub>PECE</sub> and SMFCTRL<sub>UDEE</sub> ",
                "will cause exit. If the event that causes exit is a ",
                "Machine Check exception, then a Machine Check inter",
                "rupt occurs; otherwise a System Reset interrupt occurs, ",
                "and the contents of SRR1 indicate the exception that ",
                "caused exit from power-saving mode.  If state loss has ",
                "occurred in an SMF-enabled system, the interrupt is ",
                "taken in ultravisor state.",
                "If the hypervisor has set PSSCR<sub>SD</sub>=0 prior to when the ",
                "stop instruction is executed, the instruction following ",
                "the stop may typically be a mfspr in order to read the ",
                "contents of PSSCR<sub>PLS</sub> to determine the maximum ",
                "power-saving level that was entered during power-sav",
                "ing mode. ",
                "  ",
                "",
                "The Event-Based Branch facility is described in Chap",
                "ter 6 of Book II, but only at the level required by the ",
                "application program. ",
                "Event-based branches can only occur in problem state ",
                "and when event-based branches and exceptions have ",
                "been enabled in the FSCR and HFSCR, and BES",
                "CR<sub>GE</sub>=1. Additionally, the following additional bits must ",
                "be set to one in order to enable EBB exceptions spe",
                "cific to a given function to occur.",
                "If an event-based exception exists (as indicated by ",
                "BESCR<sub>PMEO</sub>=1 or BESCR<sub>EEO</sub>=1) when MSR<sub>PR</sub>=0, the ",
                "corresponding event-based branch will occur when ",
                "MSR<sub>PR</sub>=1, FSCR<sub>EBB</sub>=1, HFSCR<sub>EBB</sub>=1, and BES",
                "CR<sub>GE</sub>=1. ",
                ""
            ]
        }
    ],
    "forms": [
        "8LS:D-form",
        "8RR:D-form",
        "8RR:XX4-form",
        "A-form",
        "B-form",
        "D-form",
        "DQ-form",
        "DS-form",
        "DX-form",
        "I-form",
        "M-form",
        "MD-form",
        "MDS-form",
        "MLS:D-form",
        "MMIRR:XX3-form",
        "MRR:*-form",
        "SC-form",
        "VA-form",
        "VC-form",
        "VN-form",
        "VX-form",
        "X-form",
        "XFL-form",
        "XFX-form",
        "XL-form",
        "XO-form",
        "XS-form",
        "XX2-form",
        "XX3-form",
        "XX4-form",
        "Z22-form",
        "Z23-form"
    ],
    "chapters": [
        {
            "name": "Branch Facility",
            "chapters": []
        },
        {
            "name": "Fixed-Point Facility",
            "chapters": []
        },
        {
            "name": "Floating-Point Facility",
            "chapters": []
        },
        {
            "name": "Decimal Floating-Point",
            "chapters": []
        },
        {
            "name": "Vector Facility ",
            "chapters": []
        },
        {
            "name": "Vector-Scalar Extension Facility",
            "chapters": []
        },
        {
            "name": "Storage Control Instructions",
            "chapters": []
        },
        {
            "name": "Time Base ",
            "chapters": []
        },
        {
            "name": "Event-Based Branch Facility ",
            "chapters": []
        },
        {
            "name": "Branch History Rolling Buffer",
            "chapters": []
        },
        {
            "name": "Storage Control",
            "chapters": []
        },
        {
            "name": "Processor Control  ",
            "chapters": []
        }
    ],
    "books": [
        {
            "shortname": "I",
            "title": "Book I: Power ISA User Instruction Set Architecture"
        },
        {
            "shortname": "II",
            "title": "Book II: Power ISA Virtual Environment Architecture"
        },
        {
            "shortname": "III",
            "title": "Book III: Power ISA Operating Environment Architecture"
        }
    ]
}
