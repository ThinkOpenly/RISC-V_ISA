{
  "instructions": [
    {
      "mnemonic": "sha256sig1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 17), xor_vec(rotater(inb, 19), shiftr(inb, 10))) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64dsm",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:329.27-329.28\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_inv(subrange_bits(sb, 63, 32)), aes_mixcolumn_inv(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum0r",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ wX_bits(rd, EXTS(64, xor_vec(shiftl(rX_bits(rs1), 25), xor_vec(shiftl(rX_bits(rs1), 30), xor_vec(shiftr(rX_bits(rs1), 28), xor_vec(shiftr(rX_bits(rs2), 7), xor_vec(shiftr(rX_bits(rs2), 2), shiftl(rX_bits(rs2), 4)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:398.27-398.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 28), xor_vec(rotater(input, 34), rotater(input, 39))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32esi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_fwd(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sum1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 6), xor_vec(rotater(inb, 11), rotater(inb, 25))) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.reserved.",
      "name": "TBD",
      "operands": [
        {
          "name": "fm",
          "type": "bits(4)"
        },
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        },
        {
          "name": "rs",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "fm",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "rs",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.",
      "name": "TBD",
      "operands": [
        {
          "name": "aq",
          "type": "bool"
        },
        {
          "name": "rl",
          "type": "bool"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "size",
          "type": "word_width"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, EXTZ(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) -> { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) -> { let aligned : bool = match width { BYTE -> true, HALF -> eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD -> eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE -> eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, EXTZ(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) -> { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) -> { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) -> mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) -> mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) -> mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) -> mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ -> internal_error(\"model/riscv_insts_aext.sail\", 218, \"STORECON expected word or double\") } in { match eares { MemException(e) -> { handle_mem_exception(addr, e); RETIRE_FAIL }, MemValue(_) -> { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) -> mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) -> mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) -> mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) -> mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ -> internal_error(\"model/riscv_insts_aext.sail\", 229, \"STORECON expected word or double\") } in { match res { MemValue(true) -> { wX_bits(rd, EXTZ(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) -> { wX_bits(rd, EXTZ(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) -> { handle_mem_exception(addr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmulh",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(xlen_val, i))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clz",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011000000000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from sub_atom(64, 1) to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "l",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "is_unsigned",
          "type": "bool"
        },
        {
          "name": "size",
          "type": "word_width"
        },
        {
          "name": "aq",
          "type": "bool"
        },
        {
          "name": "rl",
          "type": "bool"
        }
      ],
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "function": "{ let offset : xlenbits = EXTS(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) -> { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) -> if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) -> { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) -> match width { BYTE -> process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF -> process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD -> process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE when gteq_int(64, 64) -> process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ -> report_invalid_width(\"model/riscv_insts_base.sail\", 406, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.i.reserved.",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64es",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:321.27-321.28\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_fwd_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fl",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "width",
          "type": "word_width"
        }
      ],
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "function": "{ let offset : xlenbits = EXTS(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) -> { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) -> if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) -> { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) -> { let (aq, rl, res) = (false, false, false) in { match width { BYTE -> { handle_illegal(); RETIRE_FAIL }, HALF -> process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD -> process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE when gteq_int(64, 64) -> process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ -> report_invalid_width(\"model/riscv_insts_fext.sail\", 395, width, \"floating point load\") } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01110",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ wX_bits(rd, EXTS(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), shiftl(rX_bits(rs2), 24))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "xperm8",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 7), i)) in { result[add_atom(i, 7) .. i] = if lt_int(mult_atom(8, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(8, index), 7), mult_atom(8, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(8, __id(index)), 7), mult_atom(8, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "roriw",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(5)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "shamt",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : xlenbits = EXTS(64, rotate_bits_right(rs1_val, shamt)) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm4ks",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b11010",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(and_vec(x, 0x00000007), 29), xor_vec(shiftl(and_vec(x, 0x000000FE), 7), xor_vec(shiftl(and_vec(x, 0x00000001), 23), shiftl(and_vec(x, 0x000000F8), 13))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "cpop",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011000000010",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:406.27-406.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 14), xor_vec(rotater(input, 18), rotater(input, 41))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ctz",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011000000001",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to sub_atom(64, 1) by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64im",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:304.27-304.28\"); let w0 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 31, 0)) in { let w1 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 63, 32)) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm4ed",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(x, 8), xor_vec(shiftl(x, 2), xor_vec(shiftl(x, 18), xor_vec(shiftl(and_vec(x, 0x0000003F), 26), shiftl(and_vec(x, 0x000000C0), 10)))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm3p0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 9), rotatel(r1, 17))) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0l",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01010",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ wX_bits(rd, EXTS(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), xor_vec(shiftl(rX_bits(rs2), 25), shiftl(rX_bits(rs2), 24)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ks2",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b11111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:296.27-296.28\"); let w0 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), subrange_bits(rX_bits(rs2), 31, 0)) in { let w1 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), xor_vec(subrange_bits(rX_bits(rs2), 31, 0), subrange_bits(rX_bits(rs2), 63, 32))) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmul",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftl(rs1_val, i)) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm3p1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b01001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 15), rotatel(r1, 23))) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "packw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zbkb.sail:39.27-39.28\"); let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : bits(32) = bitvector_concat(subrange_bits(rs2_val, 15, 0), subrange_bits(rs1_val, 15, 0)) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "unzip",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b000010001111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 32), \"model/riscv_insts_zbkb.sail:78.27-78.28\"); exit () }",
      "description": "TBD"
    },
    {
      "mnemonic": "jalr",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1100111",
          "size": 7
        }
      ],
      "function": "{ let t : xlenbits = add_bits(rX_bits(rs1), EXTS(64, imm)) in { match ext_control_check_addr(t) { Ext_ControlAddr_Error(e) -> { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(addr) -> { let target = bitvector_update(addr, 0, bitzero) in { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(haveRVC())) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { wX_bits(rd, get_next_pc()); set_next_pc(target); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rori",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011000",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else rotate_bits_right(rs1_val, shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xperm4",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 4) by 4 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 3), i)) in { result[add_atom(i, 3) .. i] = if lt_int(mult_atom(4, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(4, index), 3), mult_atom(4, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(4, __id(index)), 3), mult_atom(4, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ds",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11101",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:338.27-338.28\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_inv_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rev8",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011010111000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = subrange_bits(rs1_val, sub_atom(sub_atom(64, i), 1), sub_atom(sub_atom(64, i), 8)); wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32dsmi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_inv(si) in { let mixed : bits(32) = aes_mixcolumn_byte_inv(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "brev8",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011010000111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = reverse_bits_in_byte(subrange_bits(rs1_val, add_atom(i, 7), i)); wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mulw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "function": "{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = signed(rs1_val) in { let rs2_int : int = signed(rs2_val) in { let result32 = subrange_bits(to_bits(64, mult_atom(rs1_int, rs2_int)), 31, 0) in { let result : xlenbits = EXTS(64, result32) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64esm",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:312.27-312.28\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_fwd(subrange_bits(sb, 63, 32)), aes_mixcolumn_fwd(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rem",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "s",
          "type": "bool"
        }
      ],
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b11",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, to_bits(64, r)); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clzw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011000000000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 31 to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sum0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 2), xor_vec(rotater(inb, 13), rotater(inb, 22))) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.",
      "name": "TBD",
      "operands": [
        {
          "name": "aq",
          "type": "bool"
        },
        {
          "name": "rl",
          "type": "bool"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "size",
          "type": "word_width"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) -> { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) -> { let aligned : bool = match width { BYTE -> true, HALF -> eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD -> eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE -> eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) -> { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) -> match (width, 64) { (BYTE, _) -> process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) -> process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) -> process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) -> process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ -> internal_error(\"model/riscv_insts_aext.sail\", 154, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "div",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "s",
          "type": "bool"
        }
      ],
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b10",
          "size": 2
        },
        {
          "field": "bool_not_bits(s)",
          "size": 1
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "function": "{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q' : int = if and_bool(s, gt_int(q, sub_atom(pow2(31), 1))) then sub_atom(0, int_power(2, 31)) else q in { wX_bits(rd, EXTS(64, to_bits(32, q'))); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sfence.vma",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0001001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "function": "{ let addr : option(xlenbits) = if eq_bits(rs1, 0b00000) then None() else Some(rX_bits(rs1)) in { let asid : option(xlenbits) = if eq_bits(rs2, 0b00000) then None() else Some(rX_bits(rs2)) in { match cur_privilege { User -> { handle_illegal(); RETIRE_FAIL }, Supervisor -> match (architecture(get_mstatus_SXL(mstatus)), _get_Mstatus_TVM(mstatus)) { (Some(_), 0b1) -> { handle_illegal(); RETIRE_FAIL }, (Some(_), 0b0) -> { flush_TLB(asid, addr); RETIRE_SUCCESS }, (_, _) -> internal_error(\"model/riscv_insts_base.sail\", 870, \"unimplemented sfence architecture\") }, Machine -> { flush_TLB(asid, addr); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "addiw",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "function": "{ let result : xlenbits = add_bits(EXTS(64, imm), rX_bits(rs1)) in { wX_bits(rd, EXTS(64, subrange_bits(result, 31, 0))); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "cpopw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011000000010",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to 31 by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum1r",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ wX_bits(rd, EXTS(64, xor_vec(shiftl(rX_bits(rs1), 23), xor_vec(shiftr(rX_bits(rs1), 14), xor_vec(shiftr(rX_bits(rs1), 18), xor_vec(shiftr(rX_bits(rs2), 9), xor_vec(shiftl(rX_bits(rs2), 18), shiftl(rX_bits(rs2), 14)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmulr",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(sub_atom(xlen_val, i), 1))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sig0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 7), xor_vec(rotater(inb, 18), shiftr(inb, 3))) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1l",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ wX_bits(rd, EXTS(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), xor_vec(shiftl(rX_bits(rs2), 26), shiftl(rX_bits(rs2), 13)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00110",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:382.27-382.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 1), xor_vec(rotater(input, 8), shiftr(input, 7))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.tso",
      "name": "TBD",
      "operands": [
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        }
      ],
      "fields": [
        {
          "field": "0b1000",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "function": "{ match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) -> __barrier(Barrier_RISCV_tso()), (_ : bits(2) @ 0b00, _ : bits(2) @ 0b00) -> (), _ -> { print(\"FIXME: unsupported fence\"); () } }; RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence",
      "name": "TBD",
      "operands": [
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        }
      ],
      "fields": [
        {
          "field": "0b0000",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "function": "{ match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) -> __barrier(Barrier_RISCV_rw_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b11) -> __barrier(Barrier_RISCV_r_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b10) -> __barrier(Barrier_RISCV_r_r()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b01) -> __barrier(Barrier_RISCV_rw_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b01) -> __barrier(Barrier_RISCV_w_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b11) -> __barrier(Barrier_RISCV_w_rw()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b10) -> __barrier(Barrier_RISCV_rw_r()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b01) -> __barrier(Barrier_RISCV_r_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b10) -> __barrier(Barrier_RISCV_w_r()), (_ : bits(4), _ : bits(2) @ 0b00) -> (), (_ : bits(2) @ 0b00, _ : bits(4)) -> (), _ -> { print(\"FIXME: unsupported fence\"); () } }; RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "ctzw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b011000000001",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to 31 by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "zip",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b000010001111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 32), \"model/riscv_insts_zbkb.sail:57.27-57.28\"); exit () }",
      "description": "TBD"
    },
    {
      "mnemonic": "slli.uw",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b000010",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = shift_bits_left(EXTZ(64, subrange_bits(rs1_val, 31, 0)), shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32esmi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_fwd(si) in { let mixed : bits(32) = aes_mixcolumn_byte_fwd(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "orc.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b001010000111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = if eq_bits(subrange_bits(rs1_val, add_atom(i, 7), i), zeros_implicit(add_atom(sub_atom(add_atom(__id(i), 7), __id(i)), 1))) then 0x00 else 0xFF; wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00111",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:390.27-390.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 19), xor_vec(rotater(input, 61), shiftr(input, 6))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ wX_bits(rd, EXTS(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), shiftl(rX_bits(rs2), 13))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32dsi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10101",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_inv(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, EXTS(64, result)); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    }
  ]
}
