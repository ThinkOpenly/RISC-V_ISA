{
  "instructions": [
    {
      "mnemonic": "sha256sig1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 17), xor_vec(rotater(inb, 19), shiftr(inb, 10))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addw",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPEW((rs2, rsd, rsd, RISCV_ADDW))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmvp.d.x",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1011001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_X = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val_X = subrange_bits(rX_bits(rs2), 31, 0) in { let rd_val_D = bitvector_concat(rs2_val_X, rs1_val_X) in { wF_D(rd, rd_val_D); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.li",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = sign_extend(12, imm) in { execute(ITYPE((imm, zreg, rd, RISCV_ADDI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64dsm",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:399.27-399.28\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_inv(subrange_bits(sb, 63, 32)), aes_mixcolumn_inv(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.slli.hint.",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rsd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.bnez",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(8)"
        },
        {
          "name": "rs",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "execute(BTYPE((sign_extend(13, bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), RISCV_BNE)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.xor",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_XOR))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmaxm.h",
      "name": "Floating-point maximum-number",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "R",
      "fields": [
        {
          "field": "0b0010110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_H(rs2_val_H, rs1_val_H, is_quiet) in { let rd_val_H = if or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then canonical_NaN_H() else if and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then rs2_val_H else if and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then rs1_val_H else if rs2_lt_rs1 then rs1_val_H else rs2_val_H in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "froundnx.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, true) in { write_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sub",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_SUB))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fsw",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE_FP((imm, rs2, rs1, WORD))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum0r",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 25), xor_vec(shiftl(rX_bits(rs1), 30), xor_vec(shiftr(rX_bits(rs1), 28), xor_vec(shiftr(rX_bits(rs2), 7), xor_vec(shiftr(rX_bits(rs2), 2), shiftl(rX_bits(rs2), 4)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:468.27-468.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 28), xor_vec(rotater(input, 34), rotater(input, 39))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32esi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_fwd(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.mv",
      "name": "TBD",
      "operands": [
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "execute(RTYPE((rs2, zreg, rd, RISCV_ADD)))",
      "description": "TBD"
    },
    {
      "mnemonic": "fround.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100000",
          "size": 7
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, false) in { write_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fround.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100010",
          "size": 7
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, false) in { write_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.subw",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPEW((rs2, rsd, rsd, RISCV_SUBW))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sdsp",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(6)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(STORE((imm, rs2, sp, DOUBLE, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.andi",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        },
        {
          "name": "rsd",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { execute(ITYPE((sign_extend(12, imm), rsd, rsd, RISCV_ANDI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sum1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 6), xor_vec(rotater(inb, 11), rotater(inb, 25))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.reserved.",
      "name": "TBD",
      "operands": [
        {
          "name": "fm",
          "type": "bits(4)"
        },
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        },
        {
          "name": "rs",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "fm",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "rs",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "c.add",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "execute(RTYPE((rs2, rsd, rsd, RISCV_ADD)))",
      "description": "TBD"
    },
    {
      "mnemonic": "sc.",
      "name": "TBD",
      "operands": [
        {
          "name": "aq",
          "type": "bool"
        },
        {
          "name": "rl",
          "type": "bool"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "size",
          "type": "word_width"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00011",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 220, \"STORECON expected word or double\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\"model/riscv_insts_aext.sail\", 231, \"STORECON expected word or double\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmulh",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(xlen_val, i))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clz",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from sub_atom(64, 1) to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "l",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "is_unsigned",
          "type": "bool"
        },
        {
          "name": "size",
          "type": "word_width"
        },
        {
          "name": "aq",
          "type": "bool"
        },
        {
          "name": "rl",
          "type": "bool"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "bool_bits(is_unsigned)",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 419, width, \"load\") } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addi",
      "name": "TBD",
      "operands": [
        {
          "name": "nzi",
          "type": "bits(6)"
        },
        {
          "name": "rsd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = sign_extend(12, nzi) in { execute(ITYPE((imm, rsd, rsd, RISCV_ADDI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.i.reserved.",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "RETIRE_SUCCESS",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64es",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:391.27-391.28\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_fwd_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.flw",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "rdc",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD_FP((imm, rs, rd, WORD))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fleq.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le_quiet(rs1_val_H, rs2_val_H) in { write_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addi4spn",
      "name": "TBD",
      "operands": [
        {
          "name": "rdc",
          "type": "cregidx"
        },
        {
          "name": "nzimm",
          "type": "bits(8)"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = bitvector_concat(0b00, bitvector_concat(nzimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { execute(ITYPE((imm, sp, rd, RISCV_ADDI))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.lui",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let res : bits(20) = sign_extend(20, imm) in { execute(UTYPE((res, rd, RISCV_LUI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fl",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        },
        {
          "name": "width",
          "type": "word_width"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0000111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 397, width, \"floating point load\") } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01110",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), shiftl(rX_bits(rs2), 24))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "fli.s",
      "name": "TBD",
      "operands": [
        {
          "name": "constantidx",
          "type": "bits(5)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111000",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 0
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let bits : bits(32) = match constantidx { 0b00000 => { 0xbf800000 }, 0b00001 => { 0x00800000 }, 0b00010 => { 0x37800000 }, 0b00011 => { 0x38000000 }, 0b00100 => { 0x3b800000 }, 0b00101 => { 0x3c000000 }, 0b00110 => { 0x3d800000 }, 0b00111 => { 0x3e000000 }, 0b01000 => { 0x3e800000 }, 0b01001 => { 0x3ea00000 }, 0b01010 => { 0x3ec00000 }, 0b01011 => { 0x3ee00000 }, 0b01100 => { 0x3f000000 }, 0b01101 => { 0x3f200000 }, 0b01110 => { 0x3f400000 }, 0b01111 => { 0x3f600000 }, 0b10000 => { 0x3f800000 }, 0b10001 => { 0x3fa00000 }, 0b10010 => { 0x3fc00000 }, 0b10011 => { 0x3fe00000 }, 0b10100 => { 0x40000000 }, 0b10101 => { 0x40200000 }, 0b10110 => { 0x40400000 }, 0b10111 => { 0x40800000 }, 0b11000 => { 0x41000000 }, 0b11001 => { 0x41800000 }, 0b11010 => { 0x43000000 }, 0b11011 => { 0x43800000 }, 0b11100 => { 0x47000000 }, 0b11101 => { 0x47800000 }, 0b11110 => { 0x7f800000 }, _ : bitvector(5) => { canonical_NaN_S() } } in { wF_S(rd, bits); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fs",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "width",
          "type": "word_width"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 0
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "imm5",
          "size": 0
        },
        {
          "field": "0b0100111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\"model/riscv_insts_fext.sail\", 470, width, \"floating point store\") } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "s",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "size",
          "type": "word_width"
        },
        {
          "name": "aq",
          "type": "bool"
        },
        {
          "name": "rl",
          "type": "bool"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "imm7",
          "size": 0
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "imm5",
          "size": 0
        },
        {
          "field": "0b0100011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\"model/riscv_insts_base.sail\", 482, width, \"store\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\"model/riscv_insts_base.sail\", 486, \"store got false from mem_write_value\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xperm8",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 7), i)) in { result[add_atom(i, 7) .. i] = if lt_int(mult_atom(8, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(8, index), 7), mult_atom(8, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(8, __id(index)), 7), mult_atom(8, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.ld",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "rdc",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD((imm, rs, rd, false, DOUBLE, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "roriw",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(5)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0110000",
          "size": 7
        },
        {
          "field": "shamt",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : xlenbits = sign_extend(64, rotate_bits_right(rs1_val, shamt)) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm4ks",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b11010",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(and_vec(x, 0x00000007), 29), xor_vec(shiftl(and_vec(x, 0x000000FE), 7), xor_vec(shiftl(and_vec(x, 0x00000001), 23), shiftl(and_vec(x, 0x000000F8), 13))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "cpop",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000010",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:476.27-476.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 14), xor_vec(rotater(input, 18), rotater(input, 41))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "ctz",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000001",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to sub_atom(64, 1) by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64im",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:374.27-374.28\"); let w0 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 31, 0)) in { let w1 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 63, 32)) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm4ed",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(x, 8), xor_vec(shiftl(x, 2), xor_vec(shiftl(x, 18), xor_vec(shiftl(and_vec(x, 0x0000003F), 26), shiftl(and_vec(x, 0x000000C0), 10)))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm3p0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 9), rotatel(r1, 17))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0l",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01010",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), xor_vec(shiftl(rX_bits(rs2), 25), shiftl(rX_bits(rs2), 24)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "fltq.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010010",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Lt_quiet(rs1_val_H, rs2_val_H) in { write_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "froundnx.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100010",
          "size": 7
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, true) in { write_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ks2",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b11111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:366.27-366.28\"); let w0 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), subrange_bits(rX_bits(rs2), 31, 0)) in { let w1 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), xor_vec(subrange_bits(rX_bits(rs2), 31, 0), subrange_bits(rX_bits(rs2), 63, 32))) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmaxm.s",
      "name": "Floating-point maximum-number",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "R",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_S(rs2_val_S, rs1_val_S, is_quiet) in { let rd_val_S = if or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then canonical_NaN_S() else if and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then rs2_val_S else if and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then rs1_val_S else if rs2_lt_rs1 then rs1_val_S else rs2_val_S in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "Floating-point minimum-number and maximum-number instructions FMIN.S and FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd. For the purposes of these instructions only, the value −0.0 is considered to be less than the value +0.0. If both inputs are NaNs, the result is the canonical NaN. If only one operand is a NaN, the result is the non-NaN operand. Signaling NaN inputs set the invalid operation exception flag, even when the result is not NaN."
    },
    {
      "mnemonic": "fleq.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le_quiet(rs1_val_S, rs2_val_S) in { write_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmul",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftl(rs1_val, i)) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sm3p1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b01001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 15), rotatel(r1, 23))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "packw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zbkb.sail:109.27-109.28\"); let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : bits(32) = bitvector_concat(subrange_bits(rs2_val, 15, 0), subrange_bits(rs1_val, 15, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sd",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE((imm, rs2, rs1, DOUBLE, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmaxm.d",
      "name": "Floating-point maximum-number",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "R",
      "fields": [
        {
          "field": "0b0010101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b011",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_bits(rs1) in { let rs2_val_D = rF_bits(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_D(rs2_val_D, rs1_val_D, is_quiet) in { let rd_val_D = if or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then canonical_NaN_D() else if and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then rs2_val_D else if and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then rs1_val_D else if rs2_lt_rs1 then rs1_val_D else rs2_val_D in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "froundnx.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100001",
          "size": 7
        },
        {
          "field": "0b00101",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, true) in { write_fflags(fflags); wF_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "unzip",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b000010001111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 32), \"model/riscv_insts_zbkb.sail:148.27-148.28\"); exit () }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fld",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "rdc",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD_FP((imm, rs, rd, DOUBLE))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fswsp",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(STORE_FP((imm, rs2, sp, WORD))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fltq.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010000",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Lt_quiet(rs1_val_S, rs2_val_S) in { write_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "jalr",
      "name": "jump and link register",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "I",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1100111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let t : xlenbits = add_bits(rX_bits(rs1), sign_extend(64, imm)) in { match ext_control_check_addr(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(addr) => { let target = bitvector_update(addr, 0, bitzero) in { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(haveRVC())) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { wX_bits(rd, get_next_pc()); set_next_pc(target); RETIRE_SUCCESS } } } } } }",
      "description": "\nThe target address is obtained by adding the sign-extended 12-bit\nI-immediate to the register rs1, then setting the\nleast-significant bit of the result to zero. The address of the\ninstruction following the jump (pc+4) is written to register rd.\nRegister x0 can be used as the destination if the result is not\nrequired.\n "
    },
    {
      "mnemonic": "rori",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else rotate_bits_right(rs1_val, shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "xperm4",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 4) by 4 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 3), i)) in { result[add_atom(i, 3) .. i] = if lt_int(mult_atom(4, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(4, index), 3), mult_atom(4, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(4, __id(index)), 3), mult_atom(4, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ds",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11101",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:408.27-408.28\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_inv_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "rev8",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011010111000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = subrange_bits(rs1_val, sub_atom(sub_atom(64, i), 1), sub_atom(sub_atom(64, i), 8)); wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fsd",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE_FP((imm, rs2, rs1, DOUBLE))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32dsmi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_inv(si) in { let mixed : bits(32) = aes_mixcolumn_byte_inv(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "brev8",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011010000111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = reverse_bits_in_byte(subrange_bits(rs1_val, add_atom(i, 7), i)); wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "mulw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0111011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = signed(rs1_val) in { let rs2_int : int = signed(rs2_val) in { let result32 = subrange_bits(to_bits(64, mult_atom(rs1_int, rs2_int)), 31, 0) in { let result : xlenbits = sign_extend(64, result32) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.srai",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rsd",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SRAI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.srli",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rsd",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SRLI))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64esm",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:382.27-382.28\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_fwd(subrange_bits(sb, 63, 32)), aes_mixcolumn_fwd(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clzw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000000",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 31 to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes64ks1i",
      "name": "TBD",
      "operands": [
        {
          "name": "rcon",
          "type": "bits(4)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b11000",
          "size": 5
        },
        {
          "field": "0b1",
          "size": 1
        },
        {
          "field": "rnum",
          "size": 0
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:356.27-356.28\"); let prev : bits(32) = subrange_bits(rX_bits(rs1), 63, 32) in { let subwords : bits(32) = aes_subword_fwd(prev) in { let result : bits(32) = if eq_bits(rnum, 0xA) then subwords else xor_vec(rotater(subwords, 8), aes_decode_rcon(rnum)) in { wX_bits(rd, bitvector_concat(result, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fminm.h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010110",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_H(rs1_val_H, rs2_val_H, is_quiet) in { let rd_val_H = if or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then canonical_NaN_H() else if and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then rs1_val_H else if and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then rs2_val_H else if rs1_lt_rs2 then rs1_val_H else rs2_val_H in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sum0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 2), xor_vec(rotater(inb, 13), rotater(inb, 22))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.sw",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc1",
          "type": "cregidx"
        },
        {
          "name": "rsc2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE((imm, rs2, rs1, WORD, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.beqz",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(8)"
        },
        {
          "name": "rs",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "execute(BTYPE((sign_extend(13, bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), RISCV_BEQ)))",
      "description": "TBD"
    },
    {
      "mnemonic": "lr.",
      "name": "TBD",
      "operands": [
        {
          "name": "aq",
          "type": "bool"
        },
        {
          "name": "rl",
          "type": "bool"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "size",
          "type": "word_width"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "bool_bits(aq)",
          "size": 1
        },
        {
          "field": "bool_bits(rl)",
          "size": 1
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b0",
          "size": 1
        },
        {
          "field": "size_bits(size)",
          "size": 2
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\"model/riscv_insts_aext.sail\", 156, \"Unexpected AMO width\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.or",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_OR))) } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.slli",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rsd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SLLI)))",
      "description": "TBD"
    },
    {
      "mnemonic": "sfence.vma",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "format": "R",
      "fields": [
        {
          "field": "0b0001001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b1110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let addr : option(xlenbits) = if eq_bits(rs1, 0b00000) then None() else Some(rX_bits(rs1)) in { let asid : option(xlenbits) = if eq_bits(rs2, 0b00000) then None() else Some(rX_bits(rs2)) in { match cur_privilege { User => { handle_illegal(); RETIRE_FAIL }, Supervisor => match (architecture(get_mstatus_SXL(mstatus)), _get_Mstatus_TVM(mstatus)) { (Some(_), 0b1) => { handle_illegal(); RETIRE_FAIL }, (Some(_), 0b0) => { flush_TLB(asid, addr); RETIRE_SUCCESS }, (_, _) => internal_error(\"model/riscv_insts_base.sail\", 887, \"unimplemented sfence architecture\") }, Machine => { flush_TLB(asid, addr); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "addiw",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(12)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "I",
      "fields": [
        {
          "field": "imm",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let result : xlenbits = add_bits(sign_extend(64, imm), rX_bits(rs1)) in { wX_bits(rd, sign_extend(64, subrange_bits(result, 31, 0))); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "cpopw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000010",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to 31 by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sum1r",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01001",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 23), xor_vec(shiftr(rX_bits(rs1), 14), xor_vec(shiftr(rX_bits(rs1), 18), xor_vec(shiftr(rX_bits(rs2), 9), xor_vec(shiftl(rX_bits(rs2), 18), shiftl(rX_bits(rs2), 14)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "fli.h",
      "name": "TBD",
      "operands": [
        {
          "name": "constantidx",
          "type": "bits(5)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111010",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 0
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfh",
        "Zfa"
      ],
      "function": "{ let bits : bits(16) = match constantidx { 0b00000 => { 0xbc00 }, 0b00001 => { 0x0400 }, 0b00010 => { 0x0100 }, 0b00011 => { 0x0200 }, 0b00100 => { 0x1c00 }, 0b00101 => { 0x2000 }, 0b00110 => { 0x2c00 }, 0b00111 => { 0x3000 }, 0b01000 => { 0x3400 }, 0b01001 => { 0x3500 }, 0b01010 => { 0x3600 }, 0b01011 => { 0x3700 }, 0b01100 => { 0x3800 }, 0b01101 => { 0x3900 }, 0b01110 => { 0x3a00 }, 0b01111 => { 0x3b00 }, 0b10000 => { 0x3c00 }, 0b10001 => { 0x3d00 }, 0b10010 => { 0x3e00 }, 0b10011 => { 0x3f00 }, 0b10100 => { 0x4000 }, 0b10101 => { 0x4100 }, 0b10110 => { 0x4200 }, 0b10111 => { 0x4400 }, 0b11000 => { 0x4800 }, 0b11001 => { 0x4c00 }, 0b11010 => { 0x5800 }, 0b11011 => { 0x5c00 }, 0b11100 => { 0x7800 }, 0b11101 => { 0x7c00 }, 0b11110 => { 0x7c00 }, _ : bitvector(5) => { canonical_NaN_H() } } in { wF_H(rd, bits); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "clmulr",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0000101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(sub_atom(xlen_val, i), 1))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fleq.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b100",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { let rs2_val_D = rF_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le_quiet(rs1_val_D, rs2_val_D) in { write_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fltq.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1010001",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { let rs2_val_D = rF_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Lt_quiet(rs1_val_D, rs2_val_D) in { write_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.swsp",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(STORE((imm, rs2, sp, WORD, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha256sig0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00010",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 7), xor_vec(rotater(inb, 18), shiftr(inb, 3))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1l",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), xor_vec(shiftl(rX_bits(rs2), 26), shiftl(rX_bits(rs2), 13)))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "fcvtmod.w.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1100001",
          "size": 7
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_D(rs1) in { let (fflags, rd_val) = fcvtmod_helper(rs1_val_D) in { write_fflags(fflags); wX_bits(rd, sign_extend(64, rd_val)); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fldsp",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(LOAD_FP((imm, sp, rd, DOUBLE))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig0",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00110",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:452.27-452.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 1), xor_vec(rotater(input, 8), shiftr(input, 7))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence.tso",
      "name": "TBD",
      "operands": [
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        }
      ],
      "format": "I",
      "fields": [
        {
          "field": "0b1000",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_tso()), (_ : bits(2) @ 0b00, _ : bits(2) @ 0b00) => (), _ => { print(\"FIXME: unsupported fence\"); () } }; RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.fsdsp",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(6)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(STORE_FP((imm, rs2, sp, DOUBLE))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.flwsp",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(imm, 0b00)) in { execute(LOAD_FP((imm, sp, rd, WORD))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fence",
      "name": "TBD",
      "operands": [
        {
          "name": "pred",
          "type": "bits(4)"
        },
        {
          "name": "succ",
          "type": "bits(4)"
        }
      ],
      "format": "I",
      "fields": [
        {
          "field": "0b0000",
          "size": 4
        },
        {
          "field": "pred",
          "size": 4
        },
        {
          "field": "succ",
          "size": 4
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "0b00000",
          "size": 5
        },
        {
          "field": "0b0001111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_rw_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_r_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_r_r()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_rw_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_w_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_w_rw()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_rw_r()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_r_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_w_r()), (_ : bits(4), _ : bits(2) @ 0b00) => (), (_ : bits(2) @ 0b00, _ : bits(4)) => (), _ => { print(\"FIXME: unsupported fence\"); () } }; RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "ctzw",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b011000000001",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to 31 by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.addiw",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(6)"
        },
        {
          "name": "rsd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "execute(ADDIW((sign_extend(12, imm), rsd, rsd)))",
      "description": "TBD"
    },
    {
      "mnemonic": "c.ldsp",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(LOAD((imm, sp, rd, false, DOUBLE, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "zip",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b000010001111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 32), \"model/riscv_insts_zbkb.sail:127.27-127.28\"); exit () }",
      "description": "TBD"
    },
    {
      "mnemonic": "fminm.s",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010100",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_S(rs1_val_S, rs2_val_S, is_quiet) in { let rd_val_S = if or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then canonical_NaN_S() else if and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then rs1_val_S else if and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then rs2_val_S else if rs1_lt_rs2 then rs1_val_S else rs2_val_S in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "slli.uw",
      "name": "TBD",
      "operands": [
        {
          "name": "shamt",
          "type": "bits(6)"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b000010",
          "size": 6
        },
        {
          "field": "shamt",
          "size": 6
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0011011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fmvh.x.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1110001",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = subrange_bits(rF_D(rs1), 63, 32) in { let rd_val_X : xlenbits = sign_extend(64, rs1_val_D) in { wX_bits(rd, rd_val_X); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fminm.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0010101",
          "size": 7
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b010",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_bits(rs1) in { let rs2_val_D = rF_bits(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_D(rs1_val_D, rs2_val_D, is_quiet) in { let rd_val_D = if or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then canonical_NaN_D() else if and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then rs1_val_D else if and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then rs2_val_D else if rs1_lt_rs2 then rs1_val_D else rs2_val_D in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.lwsp",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(6)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(LOAD((imm, sp, rd, false, WORD, false, false))) } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.lw",
      "name": "TBD",
      "operands": [
        {
          "name": "uimm",
          "type": "bits(5)"
        },
        {
          "name": "rsc",
          "type": "cregidx"
        },
        {
          "name": "rdc",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD((imm, rs, rd, false, WORD, false, false))) } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32esmi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10011",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_fwd(si) in { let mixed : bits(32) = aes_mixcolumn_byte_fwd(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "orc.b",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b001010000111",
          "size": 12
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b101",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = if eq_bits(subrange_bits(rs1_val, add_atom(i, 7), i), zeros_implicit(add_atom(sub_atom(add_atom(__id(i), 7), __id(i)), 1))) then 0x00 else 0xFF; wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fround.d",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rm",
          "type": "rounding_mode"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b0100001",
          "size": 7
        },
        {
          "field": "0b00100",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "encdec_rounding_mode(rm)",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let rs1_val_D = rF_bits(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm') => { let rm_3b = encdec_rounding_mode_forwards(rm') in { let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, false) in { write_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "fli.d",
      "name": "TBD",
      "operands": [
        {
          "name": "constantidx",
          "type": "bits(5)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b1111001",
          "size": 7
        },
        {
          "field": "0b00001",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 0
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1010011",
          "size": 7
        }
      ],
      "extensions": [
        "Zfa"
      ],
      "function": "{ let bits : bits(64) = match constantidx { 0b00000 => { 0xbff0000000000000 }, 0b00001 => { 0x0010000000000000 }, 0b00010 => { 0x3Ef0000000000000 }, 0b00011 => { 0x3f00000000000000 }, 0b00100 => { 0x3f70000000000000 }, 0b00101 => { 0x3f80000000000000 }, 0b00110 => { 0x3fb0000000000000 }, 0b00111 => { 0x3fc0000000000000 }, 0b01000 => { 0x3fd0000000000000 }, 0b01001 => { 0x3fd4000000000000 }, 0b01010 => { 0x3fd8000000000000 }, 0b01011 => { 0x3fdc000000000000 }, 0b01100 => { 0x3fe0000000000000 }, 0b01101 => { 0x3fe4000000000000 }, 0b01110 => { 0x3fe8000000000000 }, 0b01111 => { 0x3fec000000000000 }, 0b10000 => { 0x3ff0000000000000 }, 0b10001 => { 0x3ff4000000000000 }, 0b10010 => { 0x3ff8000000000000 }, 0b10011 => { 0x3ffc000000000000 }, 0b10100 => { 0x4000000000000000 }, 0b10101 => { 0x4004000000000000 }, 0b10110 => { 0x4008000000000000 }, 0b10111 => { 0x4010000000000000 }, 0b11000 => { 0x4020000000000000 }, 0b11001 => { 0x4030000000000000 }, 0b11010 => { 0x4060000000000000 }, 0b11011 => { 0x4070000000000000 }, 0b11100 => { 0x40e0000000000000 }, 0b11101 => { 0x40f0000000000000 }, 0b11110 => { 0x7ff0000000000000 }, _ : bitvector(5) => { canonical_NaN_D() } } in { wF_D(rd, bits); RETIRE_SUCCESS } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1",
      "name": "TBD",
      "operands": [
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b00",
          "size": 2
        },
        {
          "field": "0b01000",
          "size": 5
        },
        {
          "field": "0b00111",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b001",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0010011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ assert(eq_int(64, 64), \"model/riscv_insts_zkn.sail:460.27-460.28\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 19), xor_vec(rotater(input, 61), shiftr(input, 6))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "jal",
      "name": "TBD",
      "operands": [
        {
          "name": "imm",
          "type": "bits(21)"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "imm_19",
          "size": 0
        },
        {
          "field": "imm_18_13",
          "size": 0
        },
        {
          "field": "imm_12_9",
          "size": 0
        },
        {
          "field": "imm_8",
          "size": 0
        },
        {
          "field": "imm_7_0",
          "size": 0
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b1101111",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(haveRVC())) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { wX_bits(rd, get_next_pc()); set_next_pc(target); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "sha512sig1h",
      "name": "TBD",
      "operands": [
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "0b01",
          "size": 2
        },
        {
          "field": "0b01111",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), shiftl(rX_bits(rs2), 13))))))); RETIRE_SUCCESS }",
      "description": "TBD"
    },
    {
      "mnemonic": "aes32dsi",
      "name": "TBD",
      "operands": [
        {
          "name": "bs",
          "type": "bits(2)"
        },
        {
          "name": "rs2",
          "type": "regidx"
        },
        {
          "name": "rs1",
          "type": "regidx"
        },
        {
          "name": "rd",
          "type": "regidx"
        }
      ],
      "format": "TBD",
      "fields": [
        {
          "field": "bs",
          "size": 2
        },
        {
          "field": "0b10101",
          "size": 5
        },
        {
          "field": "rs2",
          "size": 5
        },
        {
          "field": "rs1",
          "size": 5
        },
        {
          "field": "0b000",
          "size": 3
        },
        {
          "field": "rd",
          "size": 5
        },
        {
          "field": "0b0110011",
          "size": 7
        }
      ],
      "extensions": [],
      "function": "{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_inv(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } }",
      "description": "TBD"
    },
    {
      "mnemonic": "c.and",
      "name": "TBD",
      "operands": [
        {
          "name": "rsd",
          "type": "cregidx"
        },
        {
          "name": "rs2",
          "type": "cregidx"
        }
      ],
      "format": "TBD",
      "fields": [],
      "extensions": [],
      "function": "{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_AND))) } } }",
      "description": "TBD"
    }
  ],
  "formats": [
    "I",
    "R",
    "TBD"
  ],
  "extensions": [
    "Zfa",
    "Zfh"
  ]
}
